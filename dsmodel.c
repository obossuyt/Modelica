/* DSblock model generated by Dymola from Modelica model DriveLib.MotorDriveTest
 Dymola Version 2015 FD01 (32-bit), 2014-11-04 translated this at Sat Feb 27 21:44:50 2016

   */

#include <matrixop.h>
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
BreakSectionFunctionDef(2)
#include <moutil.c>
PreNonAliasDef(0)
PreNonAliasDef(1)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="DriveLib.MotorDriveTest";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/ottelien/appdata/roaming/dynasim/dymola.lic";
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
W_[2] = false;
W_[10] = false;
W_[15] = 3;
W_[25] = 1;
W_[38] = false;
W_[43] = 3;
W_[24] = 5;
W_[28] = 3;
W_[32] = 1;
W_[45] = false;
W_[46] = true;
W_[41] = 0;
W_[40] = 0;
W_[8] = 0;
W_[14] = 0.0;
W_[12] = 0.0;
W_[44] = 0.0;
W_[9] = 0.0;
BoundParameterSection
AssertModelica(DP_[20] >= DP_[21],"limiter.uMax >= limiter.uMin", StringAdd(
  StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DP_[20], true, 0)),") < uMin (="),Real2String2(DP_[21], true, 0)),
  ")"));
PopAllMarks();
W_[3] = DP_[1];
AssertModelica(1+DP_[2]*(W_[3]-DP_[1]) >= 1E-015,"1+motor.Ra.alpha*(motor.Ra.T-motor.Ra.T_ref) >= 1E-015",
   "Temperature outside scope of model!");
W_[27] = divmacro(1,"1",DP_[8],"controller.Ti");
W_[29] = DP_[11];
W_[30] = DP_[9];
helpvar[0] = divmacro(1.0,"1.0",DP_[10],"controller.Nd");
W_[31] = RealBmax(helpvar[0]*DP_[9], 1E-013);
W_[33] = DP_[12];
if (NewParameters) {
helpvar[1] = fabs(W_[30]);
}
W_[35] = fabs(W_[30]) < 1E-015;
W_[36] = DP_[7];
W_[42] = 0.5*DP_[23]*sqr(DP_[22]);
W_[5] = DP_[0]*(1+DP_[2]*(W_[3]-DP_[1]));
InitialSection
InitialSection
InitialStartSection
InitialStartSection2
X_[1] = W_[29];
X_[2] = W_[33];
InitialSection
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
W_[9] = 0.0;
X_[1] = W_[29];
 /* Linear system of equations to solve. */
X_[4] = 0.0;
SolveScalarLinearParametric( -DP_[19]," -gearbox.ratio",  -W_[17]," -motor.Jm.w",
   X_[4],"load.w");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
X_[3] = 0.0;
SolveScalarLinearParametric( -DP_[19]," -gearbox.ratio",  -W_[16],
  " -motor.Jm.phi", X_[3],"load.phi");
 /* End of Equation Block */ 

X_[2] = W_[33];
InitialSection
Init=false;InitializeData(2);Init=true;
EndInitialSection

OutputSection

DynamicsSection
W_[21] = DP_[25]+(IF LessTime(DP_[26], 0) THEN 0 ELSE DP_[24]);
W_[22] = W_[21]-X_[3];
F_[1] = W_[27]*W_[22];
W_[0] = W_[5]*X_[0];
W_[26] = DP_[14]*W_[22];
W_[34] = IF W_[35] THEN 0 ELSE divmacro(W_[30]*(W_[22]-X_[2]),"controller.D.k*(positionerror.y-controller.D.x)",
  W_[31],"controller.D.T");
W_[37] = DP_[16]*W_[26]+DP_[17]*X_[1]+DP_[18]*W_[34];
W_[23] = W_[36]*W_[37];
W_[19] = IF GreaterS(W_[23],"controller.y", DP_[20],"limiter.uMax", 0) THEN 
  DP_[20] ELSE IF LessS(W_[23],"controller.y", DP_[21],"limiter.uMin", 1) THEN 
  DP_[21] ELSE W_[23];
W_[1] = W_[19]-W_[0];
W_[17] = DP_[19]*X_[4];
W_[7] = DP_[4]*W_[17];
W_[6] = W_[1]-W_[7];
 /* Linear system of equations to solve. */
F_[0] = RememberSimple_(F_[0], 0);
SolveScalarLinearParametric(DP_[3],"motor.La.L", W_[6],"motor.La.v", F_[0],
  "der(motor.La.i)");
 /* End of Equation Block */ 

W_[13] =  -DP_[4]*X_[0];
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
 /* Linear system of equations to solve. */
F_[4] = RememberSimple_(F_[4], 1);
SolveScalarLinearParametric(W_[42]+DP_[6]*DP_[19]*DP_[19],"load.J+motor.Jm.J*gearbox.ratio*gearbox.ratio",
    -DP_[19]*W_[13]," -gearbox.ratio*motor.emf.flange.tau", F_[4],"der(load.w)");
W_[18] = DP_[19]*F_[4];
W_[20] = DP_[6]*W_[18]+W_[13];
W_[39] = DP_[19]*W_[20];
 /* End of Equation Block */ 

BreakSectionFunctionEnd()
BreakSectionFunctionStart(2);
F_[3] = X_[4];
F_[2] = IF W_[35] THEN 0 ELSE divmacro(W_[22]-X_[2],"positionerror.y-controller.D.x",
  W_[31],"controller.D.T");

AcceptedSection1

AcceptedSection2
W_[16] = DP_[19]*X_[3];
W_[11] = W_[16]-DP_[5];
W_[4] = W_[0]*X_[0];

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("motor.Ra.R", "Resistance at temperature T_ref [Ohm]", 0, 0.5, \
0.0,0.0,0.0,0,560)
DeclareParameter("motor.Ra.T_ref", "Reference temperature [K|degC]", 1, 300.15, \
0.0,1E+100,300.0,0,560)
DeclareParameter("motor.Ra.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 2, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("motor.Ra.v", "Voltage drop between the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.Ra.i", "Current flowing from pin p to pin n [A]", \
"motor.La.i", 1, 1, 0, 0)
DeclareAlias2("motor.Ra.p.v", "Potential at the pin [V]", "motor.v1", 1, 5, 19, 4)
DeclareAlias2("motor.Ra.p.i", "Current flowing into the pin [A]", "motor.La.i", 1,\
 1, 0, 132)
DeclareVariable("motor.Ra.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("motor.Ra.n.i", "Current flowing into the pin [A]", "motor.La.i", -1,\
 1, 0, 132)
DeclareVariable("motor.Ra.useHeatPort", "=true, if HeatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("motor.Ra.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("motor.Ra.LossPower", "Loss power leaving component via HeatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.Ra.T_heatPort", "Temperature of HeatPort [K|degC]", \
"motor.Ra.T", 1, 5, 3, 0)
DeclareVariable("motor.Ra.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.La.v", "Voltage drop between the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("motor.La.i", "Current flowing from pin p to pin n [A]", 0, 0, \
0.0,0.0,0.0,0,560)
DeclareDerivative("motor.La.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.La.p.v", "Potential at the pin [V]", "motor.Ra.n.v", 1, 5, 1,\
 4)
DeclareAlias2("motor.La.p.i", "Current flowing into the pin [A]", "motor.La.i", 1,\
 1, 0, 132)
DeclareVariable("motor.La.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("motor.La.n.i", "Current flowing into the pin [A]", "motor.La.i", -1,\
 1, 0, 132)
DeclareParameter("motor.La.L", "Inductance [H]", 3, 0.05, 0.0,0.0,0.0,0,560)
DeclareVariable("motor.G.p.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("motor.G.p.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,\
0.0,0,777)
DeclareVariable("motor.emf.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("motor.emf.k", "Transformation coefficient [N.m/A]", 4, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("motor.emf.v", "Voltage drop between the two pins [V]", \
"motor.La.n.v", 1, 5, 7, 0)
DeclareAlias2("motor.emf.i", "Current flowing from positive to negative pin [A]",\
 "motor.La.i", 1, 1, 0, 0)
DeclareVariable("motor.emf.phi", "Angle of shaft flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.emf.der(phi)", "der(Angle of shaft flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "motor.Jm.w", 1, 5, 17, 0)
DeclareAlias2("motor.emf.w", "Angular velocity of flange relative to support [rad/s]",\
 "motor.Jm.w", 1, 5, 17, 0)
DeclareAlias2("motor.emf.p.v", "Potential at the pin [V]", "motor.La.n.v", 1, 5,\
 7, 4)
DeclareAlias2("motor.emf.p.i", "Current flowing into the pin [A]", "motor.La.i", 1,\
 1, 0, 132)
DeclareVariable("motor.emf.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("motor.emf.n.i", "Current flowing into the pin [A]", "motor.La.i", -1,\
 1, 0, 132)
DeclareAlias2("motor.emf.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.Jm.phi", 1, 5, 16, 4)
DeclareVariable("motor.emf.flange.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareParameter("motor.emf.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 5, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("motor.emf.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.emf.fixed.phi0", 1, 7, 5, 1028)
DeclareAlias2("motor.emf.fixed.flange.tau", "Cut torque in the flange [N.m]", \
"motor.emf.flange.tau", 1, 5, 13, 1156)
DeclareAlias2("motor.emf.internalSupport.tau", "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 "motor.emf.flange.tau", -1, 5, 13, 1024)
DeclareAlias2("motor.emf.internalSupport.phi", "External support angle (= flange.phi) [rad|deg]",\
 "motor.emf.fixed.phi0", 1, 7, 5, 1024)
DeclareAlias2("motor.emf.internalSupport.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.emf.fixed.phi0", 1, 7, 5, 1028)
DeclareAlias2("motor.emf.internalSupport.flange.tau", "Cut torque in the flange [N.m]",\
 "motor.emf.flange.tau", -1, 5, 13, 1156)
DeclareAlias2("motor.Vs.p.v", "Potential at the pin [V]", "motor.v1", 1, 5, 19, 4)
DeclareAlias2("motor.Vs.p.i", "Current flowing into the pin [A]", "motor.La.i", -1,\
 1, 0, 132)
DeclareVariable("motor.Vs.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("motor.Vs.n.i", "Current flowing into the pin [A]", "motor.La.i", 1,\
 1, 0, 132)
DeclareAlias2("motor.Vs.v", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 "motor.v1", 1, 5, 19, 0)
DeclareAlias2("motor.Vs.i", "Current flowing from pin p to pin n [A]", \
"motor.La.i", -1, 1, 0, 0)
DeclareAlias2("motor.Jm.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.Jm.phi", 1, 5, 16, 4)
DeclareAlias2("motor.Jm.flange_a.tau", "Cut torque in the flange [N.m]", \
"motor.emf.flange.tau", -1, 5, 13, 132)
DeclareAlias2("motor.Jm.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.Jm.phi", 1, 5, 16, 4)
DeclareAlias2("motor.Jm.flange_b.tau", "Cut torque in the flange [N.m]", \
"motor.flange_b1.tau", 1, 5, 20, 132)
DeclareParameter("motor.Jm.J", "Moment of inertia [kg.m2]", 6, 0.001, 0.0,1E+100,\
0.0,0,560)
DeclareVariable("motor.Jm.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("motor.Jm.phi", "Absolute rotation angle of component [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,528)
DeclareAlias2("motor.Jm.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "motor.Jm.w", 1, 5, 17, 0)
DeclareVariable("motor.Jm.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,528)
DeclareVariable("motor.Jm.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.Jm.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "motor.Jm.der(w)", 1, 5, 18, 0)
DeclareVariable("motor.v1", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.flange_b1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.Jm.phi", 1, 5, 16, 4)
DeclareVariable("motor.flange_b1.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("positionerror.u1", "[rad]", 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("positionerror.u2", "[rad]", "load.phi", 1, 1, 3, 0)
DeclareVariable("positionerror.y", "[rad]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.u", "Connector of Real input signal [rad]", \
"positionerror.y", 1, 5, 22, 0)
DeclareVariable("controller.y", "Connector of Real output signal [V]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("controller.k", "Gain [1]", 7, 2.0, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.Ti", "Time Constant of Integrator [s]", 8, 1000.0, \
1E-060,1E+100,0.0,0,560)
DeclareParameter("controller.Td", "Time Constant of Derivative block [s]", 9, \
0.001, 0.0,1E+100,0.0,0,560)
DeclareParameter("controller.Nd", "The higher Nd, the more ideal the derivative block",\
 10, 10, 1E-060,1E+100,0.0,0,560)
DeclareVariable("controller.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.InitPID)]",\
 5, 1.0,5.0,0.0,0,517)
DeclareParameter("controller.xi_start", "Initial or guess value value for integrator output (= integrator state) [s.rad]",\
 11, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.xd_start", "Initial or guess value for state of derivative block [rad]",\
 12, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.y_start", "Initial value of output [V]", 13, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("controller.unitTime", "[s]", 1, 0.0,0.0,0.0,0,1537)
DeclareParameter("controller.P.k", "Gain value multiplied with input signal [1]",\
 14, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.P.u", "Input signal connector [rad]", "positionerror.y", 1,\
 5, 22, 0)
DeclareVariable("controller.P.y", "Output signal connector [rad]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("controller.I.k", "Integrator gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("controller.I.y_start", "Initial or guess value of output (= state) [s.rad]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.I.u", "Connector of Real input signal [rad]", \
"positionerror.y", 1, 5, 22, 0)
DeclareState("controller.I.y", "Connector of Real output signal [s.rad]", 1, 0.0,\
 0.0,0.0,0.0,0,544)
DeclareDerivative("controller.I.der(y)", "der(Connector of Real output signal) [rad]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.D.k", "Gains [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.D.T", "Time constants (T>0 required; T=0 is ideal derivative block) [s]",\
 1E-060, 1E-060,1E+100,0.0,0,513)
DeclareVariable("controller.D.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("controller.D.x_start", "Initial or guess value of state [rad]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("controller.D.y_start", "Initial value of output (= state) [rad/s]",\
 15, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.D.u", "Connector of Real input signal [rad]", \
"positionerror.y", 1, 5, 22, 0)
DeclareVariable("controller.D.y", "Connector of Real output signal [rad/s]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareState("controller.D.x", "State of block [rad]", 2, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("controller.D.der(x)", "der(State of block) [rad/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("controller.D.zeroGain", "[:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,2563)
DeclareVariable("controller.Gain.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.Gain.u", "Input signal connector", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareAlias2("controller.Gain.y", "Output signal connector [V]", "controller.y", 1,\
 5, 23, 0)
DeclareParameter("controller.Add.k1", "Gain of upper input", 16, 1, 0.0,0.0,0.0,\
0,560)
DeclareParameter("controller.Add.k2", "Gain of middle input", 17, 1, 0.0,0.0,0.0,\
0,560)
DeclareParameter("controller.Add.k3", "Gain of lower input", 18, 1, 0.0,0.0,0.0,\
0,560)
DeclareAlias2("controller.Add.u1", "Connector 1 of Real input signals [rad]", \
"controller.P.y", 1, 5, 26, 0)
DeclareAlias2("controller.Add.u2", "Connector 2 of Real input signals [s.rad]", \
"controller.I.y", 1, 1, 1, 0)
DeclareAlias2("controller.Add.u3", "Connector 3 of Real input signals [rad/s]", \
"controller.D.y", 1, 5, 34, 0)
DeclareAlias2("controller.Add.y", "Connector of Real output signals", \
"controller.Gain.u", 1, 5, 37, 0)
DeclareVariable("gearbox.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("gearbox.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.Jm.phi", 1, 5, 16, 4)
DeclareAlias2("gearbox.flange_a.tau", "Cut torque in the flange [N.m]", \
"motor.flange_b1.tau", -1, 5, 20, 132)
DeclareAlias2("gearbox.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "load.phi", 1, 1, 3, 4)
DeclareVariable("gearbox.flange_b.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("gearbox.phi_support", "Absolute angle of support flange [rad|deg]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareParameter("gearbox.ratio", "Transmission ratio (flange_a.phi/flange_b.phi) [1]",\
 19, 3, 0.0,0.0,0.0,0,560)
DeclareAlias2("gearbox.phi_a", "Angle between left shaft flange and support [rad|deg]",\
 "motor.Jm.phi", 1, 5, 16, 0)
DeclareAlias2("gearbox.phi_b", "Angle between right shaft flange and support [rad|deg]",\
 "load.phi", 1, 1, 3, 0)
DeclareAlias2("load.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "load.phi", 1, 1, 3, 4)
DeclareAlias2("load.flange_a.tau", "Cut torque in the flange [N.m]", \
"gearbox.flange_b.tau", -1, 5, 39, 132)
DeclareAlias2("load.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "load.phi", 1, 1, 3, 4)
DeclareVariable("load.flange_b.tau", "Cut torque in the flange [N.m]", 0, \
0.0,0.0,0.0,0,777)
DeclareVariable("load.J", "Moment of inertia [kg.m2]", 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("load.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareState("load.phi", "Absolute rotation angle of component [rad|deg]", 3, \
0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("load.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("load.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 4, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("load.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("load.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "load.der(w)", 1, 6, 4, 0)
DeclareAlias2("phiload.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "load.phi", 1, 1, 3, 4)
DeclareVariable("phiload.flange.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,777)
DeclareAlias2("phiload.phi", "Absolute angle of flange as output signal [rad|deg]",\
 "load.phi", 1, 1, 3, 0)
DeclareParameter("limiter.uMax", "Upper limits of input signals [V]", 20, 100, \
0.0,0.0,0.0,0,560)
DeclareParameter("limiter.uMin", "Lower limits of input signals [V]", 21, -100, \
0.0,0.0,0.0,0,560)
DeclareVariable("limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("limiter.limitsAtInit", "= false, if limits are ignored during initialization (i.e., y=u) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("limiter.u", "Connector of Real input signal [V]", "controller.y", 1,\
 5, 23, 0)
DeclareAlias2("limiter.y", "Connector of Real output signal [V]", "motor.v1", 1,\
 5, 19, 0)
DeclareParameter("r", "Radius of load [m]", 22, 0.5, 0.0,1E+100,0.0,0,560)
DeclareParameter("m", "mass of load [kg]", 23, 80, 0.0,1E+100,0.0,0,560)
DeclareParameter("step.height", "Height of step [rad]", 24, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("step.y", "Connector of Real output signal [rad]", \
"positionerror.u1", 1, 5, 21, 0)
DeclareParameter("step.offset", "Offset of output signal y [rad]", 25, 0, \
0.0,0.0,0.0,0,560)
DeclareParameter("step.startTime", "Output y = offset for time < startTime [s]",\
 26, 0, 0.0,0.0,0.0,0,560)
EndNonAlias(0)
#define NX_    5
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    47
#define NP_    27
#define NPS_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -505455692
#define NHash2_ 1283713302
#define NHash3_ 0
#define NI_    0
#define NRelF_ 2
#define NRel_  2
#define NTim_  1
#define NSamp_ 0
#define NCons_ 0
#define NA_    58
#define SizePre_ 0
#define SizeEq_ 2
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 2
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double *time, double X_[], double XD_[], double U_[], 
double DP_[], long IP_[], Dymola_bool LP_[], double F_[], double Y_[], double W_[], double QZ_[], double duser_[], long iuser_[], void*cuser_[]) {
static Real initStore[1];
}
StartDataBlock
StartEqBlock
DoRemember_(F_[4], 0.0, 1);
DoRemember_(F_[0], 0.0, 0);
EndEqBlock
EndDataBlock
BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionCallNew(2);
BreakSectionFunctionEnd()
