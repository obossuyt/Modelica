/* DSblock model generated by Dymola from Modelica model TestPipeModel.Example01
 Dymola Version 2015 FD01 (64-bit), 2014-11-04 translated this at Sat Mar 05 14:54:32 2016

   */

#include <matrixop.h>
static double DymArrays0[1]={0.0};
static const char* DymArrays1[1]={"WaterDetailed"};
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  RealArray   V_flow_0member;
  RealArray   eta_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(RealArray    V_flow_02, 
  RealArray    eta_02) {
  struct DymStruc0 dummy_0;
  dummy_0.V_flow_0member = V_flow_02;
  dummy_0.eta_0member = eta_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency
  (struct DymStruc0 per0_0, double  Vx_0flow, RealArray   d0_0, double  rx_0N, 
  double  delta0_0);
DYMOLA_STATIC double   IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency__derf
  (struct DymStruc0 per0_0, double  Vx_0flow, RealArray   d0_0, double  rx_0N, 
  double  delta0_0, struct DymStruc0 perx_0der9, double  Vx_0flowx_0der9, 
  RealArray   dx_0der9, double  rx_0Nx_0der9, double  deltax_0der9);
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction
  (double  pos0_0, double  neg0_0, double  x0_0, double  deltax0_0, double  
  dpos0_0, double  dneg0_0, double  dx0_0, double  ddeltax0_0);
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
  (double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0);
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_cubicHermiteLinearExtrapolation__der
  (double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0, double  xx_0der, double  x1x_0der, double  
  x2x_0der, double  y1x_0der, double  y2x_0der, double  y1dx_0der, double  
  y2dx_0der);
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_smoothMax(double  x10_0, 
  double  x20_0, double  deltaX0_0);
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_smoothMax__der(double  
  x10_0, double  x20_0, double  deltaX0_0, double  x1x_0der, double  x2x_0der, 
  double  deltaXx_0der);
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_spliceFunction(double  
  pos0_0, double  neg0_0, double  x0_0, double  deltax0_0);
struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct {
  RealArray    cr0_0_0member;
  RealArray    c00_0_0member;
  RealArray    c10_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
   Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne(
  RealArray   den10_0, RealArray   den20_0);
DYMOLA_STATIC RealArray    Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping
  (int  order0_0, int  normalized0_0);
struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct {
  RealArray    cr0_0_0member;
  RealArray    c00_0_0member;
  RealArray    c10_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass(RealArray   
  crx_0in, RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut);
struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct {
  RealArray    r0_0_0member;
  RealArray    a0_0_0member;
  RealArray    b0_0_0member;
  RealArray    ku0_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealArray   crx_0in,
   RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut);
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_cubicHermite(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_cubicHermite__der(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0, double  xx_0der, double  x1x_0der, double  x2x_0der, double  
  y1x_0der, double  y2x_0der, double  y1dx_0der, double  y2dx_0der);
/* Codes used in model */

/* Flattened Modelica model:

function IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency
parameter input IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters per;
discrete input Real V_flow(unit = "m3/s") "Volumetric flow rate";
discrete input Real d[:] "Derivatives at support points for spline interpolation";
discrete input Real r_N(unit = "1") "Relative revolution, r_N=N/N_nominal";
discrete input Real delta "Small value for switching implementation around zero rpm";
discrete output Real eta(unit = "1", min = 0.0) "Efficiency";
protected 
Integer n(start = size(per.V_flow, 1)) "Number of data points";
discrete Real rat "Ratio of V_flow/r_N";
Integer i "Integer to select data interval";
public 
algorithm 
if (n == 1) then 
eta := per.eta[1];
else
rat := V_flow/IDEAS.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta);
i := 1;
for j in (1:n-1) loop
if (rat > per.V_flow[j]) then 
i := j;
end if;
end for;
eta := IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(rat, per.V_flow[i], per.V_flow[i+1], per.eta[i], per.eta[i+1], d[i], d[i+1]);
end if;
annotation(derivative=IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency:derf, smoothOrder=1);
end IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency;

  */
DYMOLA_STATIC double   IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency
  (struct DymStruc0 per0_0, double  Vx_0flow, RealArray   d0_0, double  rx_0N, 
  double  delta0_0) {
  PushContext("IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency")
  {
    /* Declare outputs and temporaries */
    double   eta0_0;
    int   n0_0;
    double   rat0_0;
    int   i0_0;
    MarkObject retmark_ = PushMark();
    eta0_0=0;
    n0_0 = RealSize( per0_0.V_flow_0member, 1);
    rat0_0=0;
    i0_0=0;
    /* Start of real code */
      if (n0_0 == 1) {
        eta0_0 = RealVectorElement( per0_0.eta_0member, (SizeType)(1));
      }
      else{
        rat0_0 = divmacro(Vx_0flow,"V_flow",IDEAS_Utilities_Math_Functions_smoothMax
          (rx_0N, 0.1, delta0_0),"IDEAS.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta)");
        i0_0 = 1;
        {
          int end_ = (n0_0-1);
          int j0_0_0;
          for(j0_0_0 = 1;j0_0_0 <= end_;j0_0_0 += 1) {
            if (rat0_0 > RealElement( per0_0.V_flow_0member, (SizeType)(j0_0_0)))
               {
              i0_0 = j0_0_0;
            }
          }
        }
        eta0_0 = IDEAS_Utilities_Math_Functions_cubicHermiteLinearExtrapolation(
          rat0_0, RealElement( per0_0.V_flow_0member, (SizeType)(i0_0)), 
          RealElement( per0_0.V_flow_0member, (SizeType)(i0_0+1)), RealElement( 
          per0_0.eta_0member, (SizeType)(i0_0)), RealElement( per0_0.eta_0member,
           (SizeType)(i0_0+1)), RealElement( d0_0, (SizeType)(i0_0)), 
          RealElement( d0_0, (SizeType)(i0_0+1)));
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return eta0_0;
  }}

/* Flattened Modelica model:

function IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency:derf
parameter input IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters per;
discrete input Real V_flow;
discrete input Real d[:];
discrete input Real r_N;
discrete input Real delta;
protected 
discrete Real eta;
Integer n(start = size(per.V_flow, 1));
discrete Real rat;
Integer i;
public 
parameter input IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters per_der9;
discrete input Real V_flow_der9;
discrete input Real d_der9[:];
discrete input Real r_N_der9;
discrete input Real delta_der9;
discrete output Real eta_der9;
protected 
discrete Real rat_der9;
public 
algorithm 
if (n == 1) then 
eta_der9 := per_der9.eta[1];
else
rat_der9 := V_flow_der9/IDEAS.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta)-V_flow*IDEAS.Utilities.Math.Functions.smoothMax:der(r_N, 0.1, delta, r_N_der9, 0.0, delta_der9)/IDEAS.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta)^2;
rat := V_flow/IDEAS.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta);
i := 1;
for j in (1:n-1) loop
if (rat > per.V_flow[j]) then 
i := j;
end if;
end for;
eta_der9 := IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation:der(rat, per.V_flow[i], per.V_flow[1+i], per.eta[i], per.eta[1+i], d[i], d[1+i], rat_der9, per_der9.V_flow[i], per_der9.V_flow[1+i], per_der9.eta[i], per_der9.eta[1+i], d_der9[i], d_der9[1+i]);
end if;
end IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency:derf;

  */
DYMOLA_STATIC double   IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency__derf
  (struct DymStruc0 per0_0, double  Vx_0flow, RealArray   d0_0, double  rx_0N, 
  double  delta0_0, struct DymStruc0 perx_0der9, double  Vx_0flowx_0der9, 
  RealArray   dx_0der9, double  rx_0Nx_0der9, double  deltax_0der9) {
  PushContext("IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency:derf")
  {
    /* Declare outputs and temporaries */
    double   eta0_0;
    int   n0_0;
    double   rat0_0;
    int   i0_0;
    double   etax_0der9;
    double   ratx_0der9;
    MarkObject retmark_ = PushMark();
    eta0_0=0;
    n0_0 = RealSize( per0_0.V_flow_0member, 1);
    rat0_0=0;
    i0_0=0;
    etax_0der9=0;
    ratx_0der9=0;
    /* Start of real code */
      if (n0_0 == 1) {
        etax_0der9 = RealVectorElement( perx_0der9.eta_0member, (SizeType)(1));
      }
      else{
        ratx_0der9 = divmacro(Vx_0flowx_0der9,"V_flow_der9",IDEAS_Utilities_Math_Functions_smoothMax
          (rx_0N, 0.1, delta0_0),"IDEAS.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta)")
          -divmacro(Vx_0flow*IDEAS_Utilities_Math_Functions_smoothMax__der(rx_0N,
           0.1, delta0_0, rx_0Nx_0der9, 0.0, deltax_0der9),"V_flow*IDEAS.Utilities.Math.Functions.smoothMax:der(r_N, 0.1, delta, r_N_der9, 0.0, delta_der9)",
          sqr(IDEAS_Utilities_Math_Functions_smoothMax(rx_0N, 0.1, delta0_0)),
          "IDEAS.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta)^2");
        rat0_0 = divmacro(Vx_0flow,"V_flow",IDEAS_Utilities_Math_Functions_smoothMax
          (rx_0N, 0.1, delta0_0),"IDEAS.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta)");
        i0_0 = 1;
        {
          int end_ = (n0_0-1);
          int j0_0_0;
          for(j0_0_0 = 1;j0_0_0 <= end_;j0_0_0 += 1) {
            if (rat0_0 > RealElement( per0_0.V_flow_0member, (SizeType)(j0_0_0)))
               {
              i0_0 = j0_0_0;
            }
          }
        }
        etax_0der9 = IDEAS_Utilities_Math_Functions_cubicHermiteLinearExtrapolation__der
          (rat0_0, RealElement( per0_0.V_flow_0member, (SizeType)(i0_0)), 
          RealElement( per0_0.V_flow_0member, (SizeType)(1+i0_0)), RealElement( 
          per0_0.eta_0member, (SizeType)(i0_0)), RealElement( per0_0.eta_0member,
           (SizeType)(1+i0_0)), RealElement( d0_0, (SizeType)(i0_0)), 
          RealElement( d0_0, (SizeType)(1+i0_0)), ratx_0der9, RealElement( 
          perx_0der9.V_flow_0member, (SizeType)(i0_0)), RealElement( perx_0der9.
          V_flow_0member, (SizeType)(1+i0_0)), RealElement( perx_0der9.
          eta_0member, (SizeType)(i0_0)), RealElement( perx_0der9.eta_0member, 
          (SizeType)(1+i0_0)), RealElement( dx_0der9, (SizeType)(i0_0)), 
          RealElement( dx_0der9, (SizeType)(1+i0_0)));
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return etax_0der9;
  }}

/* Flattened Modelica model:

function IDEAS.Utilities.Math.Functions.BaseClasses.der_spliceFunction
discrete input Real pos;
discrete input Real neg;
discrete input Real x;
discrete input Real deltax(start = 1);
discrete input Real dpos;
discrete input Real dneg;
discrete input Real dx;
discrete input Real ddeltax(start = 0);
discrete output Real out;
protected 
discrete Real scaledX;
discrete Real scaledX1;
discrete Real dscaledX1;
discrete Real y;
constant Real asin1 = 1.5707963267948966;
public 
algorithm 
scaledX1 := x/deltax;
if (scaledX1 <= -0.99999999999) then 
out := dneg;
elseif (scaledX1 >= 0.9999999999) then 
out := dpos;
else
scaledX := scaledX1*asin1;
dscaledX1 := (dx-scaledX1*ddeltax)/deltax;
y := (tanh(tan(scaledX))+1)/2;
out := dpos*y+(1-y)*dneg;
out := out+(pos-neg)*dscaledX1*asin1/2/(cosh(tan(scaledX))*cos(scaledX))^2;
end if;
end IDEAS.Utilities.Math.Functions.BaseClasses.der_spliceFunction;

  */
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction
  (double  pos0_0, double  neg0_0, double  x0_0, double  deltax0_0, double  
  dpos0_0, double  dneg0_0, double  dx0_0, double  ddeltax0_0) {
  PushContext("IDEAS.Utilities.Math.Functions.BaseClasses.der_spliceFunction")
  {
    /* Declare outputs and temporaries */
    double   out0_0;
    double   scaledX0_0;
    double   scaledX10_0;
    double   dscaledX10_0;
    double   y0_0;
    double   asin10_0;
    out0_0=0;
    scaledX0_0=0;
    scaledX10_0=0;
    dscaledX10_0=0;
    y0_0=0;
    asin10_0 = 1.5707963267948966;
    /* Start of real code */
      scaledX10_0 = divmacro(x0_0,"x",deltax0_0,"deltax");
      if (scaledX10_0 <= -0.99999999999) {
        out0_0 = dneg0_0;
      }
      else if (scaledX10_0 >= 0.9999999999) {
        out0_0 = dpos0_0;
      }
      else{
        scaledX0_0 = scaledX10_0*asin10_0;
        dscaledX10_0 = divmacro(dx0_0-scaledX10_0*ddeltax0_0,"dx-scaledX1*ddeltax",
          deltax0_0,"deltax");
        y0_0 = (tanh(tan(scaledX0_0))+1)/(double)(2);
        out0_0 = dpos0_0*y0_0+(1-y0_0)*dneg0_0;
        out0_0 = out0_0+divmacro((pos0_0-neg0_0)*dscaledX10_0*asin10_0/(double)(2),
          "(pos-neg)*dscaledX1*asin1/2",sqr(cosh(tan(scaledX0_0))*cos(scaledX0_0)),
          "(cosh(tan(scaledX))*cos(scaledX))^2");
      }
    /* Output section */
    PopContext()
    return out0_0;
  }}

/* Flattened Modelica model:

function IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower gradient";
discrete input Real y2d "Upper gradient";
discrete output Real y "Interpolated ordinate value";

algorithm 
if (x > x1 and x < x2) then 
y := Modelica.Fluid.Utilities.cubicHermite(x, x1, x2, y1, y2, y1d, y2d);
elseif (x <= x1) then 
y := y1+(x-x1)*y1d;
else
y := y2+(x-x2)*y2d;
end if;
annotation(derivative=IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation:der, smoothOrder=1);
end IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation;

  */
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
  (double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0) {
  PushContext("IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      if (x0_0 > x10_0 AND x0_0 < x20_0) {
        y0_0 = Modelica_Fluid_Utilities_cubicHermite(x0_0, x10_0, x20_0, y10_0, 
          y20_0, y1d0_0, y2d0_0);
      }
      else if (x0_0 <= x10_0) {
        y0_0 = y10_0+(x0_0-x10_0)*y1d0_0;
      }
      else{
        y0_0 = y20_0+(x0_0-x20_0)*y2d0_0;
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation:der
discrete input Real x;
discrete input Real x1;
discrete input Real x2;
discrete input Real y1;
discrete input Real y2;
discrete input Real y1d;
discrete input Real y2d;
protected 
discrete Real y;
public 
discrete input Real x_der;
discrete input Real x1_der;
discrete input Real x2_der;
discrete input Real y1_der;
discrete input Real y2_der;
discrete input Real y1d_der;
discrete input Real y2d_der;
discrete output Real y_der;

algorithm 
if (x > x1 and x < x2) then 
y_der := Modelica.Fluid.Utilities.cubicHermite:der(x, x1, x2, y1, y2, y1d, y2d, x_der, x1_der, x2_der, y1_der, y2_der, y1d_der, y2d_der);
elseif (x <= x1) then 
y_der := y1_der+(x_der-x1_der)*y1d+(x-x1)*y1d_der;
else
y_der := y2_der+(x_der-x2_der)*y2d+(x-x2)*y2d_der;
end if;
end IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation:der;

  */
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_cubicHermiteLinearExtrapolation__der
  (double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0, double  xx_0der, double  x1x_0der, double  
  x2x_0der, double  y1x_0der, double  y2x_0der, double  y1dx_0der, double  
  y2dx_0der) {
  PushContext("IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   yx_0der;
    y0_0=0;
    yx_0der=0;
    /* Start of real code */
      if (x0_0 > x10_0 AND x0_0 < x20_0) {
        yx_0der = Modelica_Fluid_Utilities_cubicHermite__der(x0_0, x10_0, x20_0,
           y10_0, y20_0, y1d0_0, y2d0_0, xx_0der, x1x_0der, x2x_0der, y1x_0der, 
          y2x_0der, y1dx_0der, y2dx_0der);
      }
      else if (x0_0 <= x10_0) {
        yx_0der = y1x_0der+(xx_0der-x1x_0der)*y1d0_0+(x0_0-x10_0)*y1dx_0der;
      }
      else{
        yx_0der = y2x_0der+(xx_0der-x2x_0der)*y2d0_0+(x0_0-x20_0)*y2dx_0der;
      }
    /* Output section */
    PopContext()
    return yx_0der;
  }}

/* Flattened Modelica model:

function IDEAS.Utilities.Math.Functions.smoothMax
discrete input Real x1 "First argument";
discrete input Real x2 "Second argument";
discrete input Real deltaX "Width of transition interval";
discrete output Real y "Result";

algorithm 
y := IDEAS.Utilities.Math.Functions.spliceFunction(x1, x2, x1-x2, deltaX);
annotation(derivative=IDEAS.Utilities.Math.Functions.smoothMax:der, smoothOrder=1);
end IDEAS.Utilities.Math.Functions.smoothMax;

  */
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_smoothMax(double  x10_0, 
  double  x20_0, double  deltaX0_0) {
  PushContext("IDEAS.Utilities.Math.Functions.smoothMax")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = IDEAS_Utilities_Math_Functions_spliceFunction(x10_0, x20_0, x10_0-
        x20_0, deltaX0_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function IDEAS.Utilities.Math.Functions.smoothMax:der
discrete input Real x1;
discrete input Real x2;
discrete input Real deltaX;
protected 
discrete Real y;
public 
discrete input Real x1_der;
discrete input Real x2_der;
discrete input Real deltaX_der;
discrete output Real y_der;

algorithm 
y_der := IDEAS.Utilities.Math.Functions.BaseClasses.der_spliceFunction(x1, x2, x1-x2, deltaX, x1_der, x2_der, x1_der-x2_der, deltaX_der);
end IDEAS.Utilities.Math.Functions.smoothMax:der;

  */
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_smoothMax__der(double  
  x10_0, double  x20_0, double  deltaX0_0, double  x1x_0der, double  x2x_0der, 
  double  deltaXx_0der) {
  PushContext("IDEAS.Utilities.Math.Functions.smoothMax:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   yx_0der;
    y0_0=0;
    yx_0der=0;
    /* Start of real code */
      yx_0der = IDEAS_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(
        x10_0, x20_0, x10_0-x20_0, deltaX0_0, x1x_0der, x2x_0der, x1x_0der-
        x2x_0der, deltaXx_0der);
    /* Output section */
    PopContext()
    return yx_0der;
  }}

/* Flattened Modelica model:

function IDEAS.Utilities.Math.Functions.spliceFunction
discrete input Real pos "Argument of x > 0";
discrete input Real neg "Argument of x < 0";
discrete input Real x "Independent value";
discrete input Real deltax "Half width of transition interval";
discrete output Real out "Smoothed value";
protected 
discrete Real scaledX1;
discrete Real y;
constant Real asin1 = 1.5707963267948966;
public 
algorithm 
scaledX1 := x/deltax;
if (scaledX1 <= -0.999999999) then 
out := neg;
elseif (scaledX1 >= 0.999999999) then 
out := pos;
else
y := (tanh(tan(scaledX1*asin1))+1)/2;
out := pos*y+(1-y)*neg;
end if;
annotation(derivative=IDEAS.Utilities.Math.Functions.BaseClasses.der_spliceFunction, smoothOrder=1);
end IDEAS.Utilities.Math.Functions.spliceFunction;

  */
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_spliceFunction(double  
  pos0_0, double  neg0_0, double  x0_0, double  deltax0_0) {
  PushContext("IDEAS.Utilities.Math.Functions.spliceFunction")
  {
    /* Declare outputs and temporaries */
    double   out0_0;
    double   scaledX10_0;
    double   y0_0;
    double   asin10_0;
    out0_0=0;
    scaledX10_0=0;
    y0_0=0;
    asin10_0 = 1.5707963267948966;
    /* Start of real code */
      scaledX10_0 = divmacro(x0_0,"x",deltax0_0,"deltax");
      if (scaledX10_0 <= -0.999999999) {
        out0_0 = neg0_0;
      }
      else if (scaledX10_0 >= 0.999999999) {
        out0_0 = pos0_0;
      }
      else{
        y0_0 = (tanh(tan(scaledX10_0*asin10_0))+1)/(double)(2);
        out0_0 = pos0_0*y0_0+(1-y0_0)*neg0_0;
      }
    /* Output section */
    PopContext()
    return out0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping
input Integer order(min = 1.0) "Order of filter";
input Boolean normalized(start = true) "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";
discrete output Real cr[order] "Coefficients of real poles";
protected 
discrete Real alpha(start = 1.0) "Frequency correction factor";
discrete Real alpha2 "= alpha*alpha";
discrete Real den1[order] "[p] coefficients of denominator first order polynomials (a*p + 1)";
discrete Real den2[0, 2] "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
discrete Real c0[0] "Coefficients of s^0 term if conjugate complex pole";
discrete Real c1[0] "Coefficients of s^1 term if conjugate complex pole";
public 
algorithm 
if (normalized) then 
alpha := sqrt(10^(0.3/order)-1);
else
alpha := 1.0;
end if;
for i in (1:order) loop
den1[i] := alpha;
end for;
(cr, c0, c1)  := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1, den2);
end Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping;

  */
DYMOLA_STATIC RealArray    Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping
  (int  order0_0, int  normalized0_0) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping")
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    double   alpha0_0;
    double   alpha20_0;
    RealArray    den10_0;
    RealArray    den20_0;
    RealArray    c00_0;
    RealArray    c10_0;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, order0_0);
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    alpha0_0 = 1.0;
    alpha20_0=0;
    den10_0=RealTemporary( 1, order0_0);
    PushMark();
    RealFillAssign( den10_0, 0);
    den20_0=RealTemporary( 2, 0, 2);
    PushMark();
    RealFillAssign( den20_0, 0);
    c00_0=RealTemporary( 1, 0);
    PushMark();
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, 0);
    PushMark();
    RealFillAssign( c10_0, 0);
    /* Start of real code */
      if (normalized0_0) {
        alpha0_0 = sqrtGuarded(powmacro(10,"10",divmacro(0.3,"0.3",order0_0,
          "order"),"0.3/order")-1,"10^(0.3/order)-1");
      }
      else{
        alpha0_0 = 1.0;
      }
      {
        int end_ = order0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(alpha0_0, den10_0, (SizeType)(i0_0_0));
        }
      }
      {
        struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
           dummy_mult_=Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne
          (den10_0, den20_0);
        RealAssign (cr0_0, dummy_mult_.cr0_0_0member);
        RealAssign (c00_0, dummy_mult_.c00_0_0member);
        RealAssign (c10_0, dummy_mult_.c10_0_0member);
      }
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return cr0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass
discrete input Real cr_in[:] "Coefficients of real poles of base filter";
discrete input Real c0_in[:] "Coefficients of s^0 term of base filter if conjugate complex pole";
discrete input Real c1_in[size(c0_in, 1)] "Coefficients of s^1 term of base filter if conjugate complex pole";
discrete input Real f_cut(unit = "Hz") "Cut-off frequency";
discrete output Real r[size(cr_in, 1)] "Real eigenvalues";
discrete output Real a[size(c0_in, 1)] "Real parts of complex conjugate eigenvalues";
discrete output Real b[size(c0_in, 1)] "Imaginary parts of complex conjugate eigenvalues";
discrete output Real ku[size(c0_in, 1)] "Input gain";
protected 
discrete Real c0[size(c0_in, 1)];
discrete Real c1[size(c0_in, 1)];
discrete Real cr[size(cr_in, 1)];
public 
algorithm 
(cr, c0, c1)  := Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass(cr_in, c0_in, c1_in, f_cut);
for i in (1:size(cr_in, 1)) loop
r[i] :=  -cr[i];
end for;
for i in (1:size(c0_in, 1)) loop
a[i] :=  -c1[i]/2;
b[i] := sqrt(c0[i]-a[i]*a[i]);
ku[i] := c0[i]/b[i];
end for;
end Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealArray   crx_0in,
   RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass")
  AssertModelica(RealSize( c1x_0in,1)==RealSize( c0x_0in, 1),"size(c1_in, 1) == size(c0_in, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    r0_0;
    RealArray    a0_0;
    RealArray    b0_0;
    RealArray    ku0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    RealArray    cr0_0;
    MarkObject retmark_ = PushMark();
    r0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( r0_0, 0);
    a0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( a0_0, 0);
    b0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( b0_0, 0);
    ku0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( ku0_0, 0);
    c00_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    PushMark();
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    PushMark();
    RealFillAssign( c10_0, 0);
    cr0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    PushMark();
    RealFillAssign( cr0_0, 0);
    /* Start of real code */
      {
        struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
           dummy_mult_=Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass
          (crx_0in, c0x_0in, c1x_0in, fx_0cut);
        RealAssign (cr0_0, dummy_mult_.cr0_0_0member);
        RealAssign (c00_0, dummy_mult_.c00_0_0member);
        RealAssign (c10_0, dummy_mult_.c10_0_0member);
      }
      Release();
      {
        int end_ = RealSize( crx_0in, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement( -RealElement( cr0_0, (SizeType)(i0_0_0)), r0_0, 
            (SizeType)(i0_0_0));
        }
      }
      {
        int end_ = RealSize( c0x_0in, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement( -RealElement( c10_0, (SizeType)(i0_0_0))/(double)(2), 
            a0_0, (SizeType)(i0_0_0));
          SetRealElement(sqrtGuarded(RealElement( c00_0, (SizeType)(i0_0_0))-
            RealElement( a0_0, (SizeType)(i0_0_0))*RealElement( a0_0, (SizeType)
            (i0_0_0)),"c0[i]-a[i]*a[i]"), b0_0, (SizeType)(i0_0_0));
          SetRealElement(divmacro(RealElement( c00_0, (SizeType)(i0_0_0)),
            "c0[i]",RealElement( b0_0, (SizeType)(i0_0_0)),"b[i]"), ku0_0, 
            (SizeType)(i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct out_;
      out_.r0_0_0member = r0_0;
      out_.a0_0_0member = a0_0;
      out_.b0_0_0member = b0_0;
      out_.ku0_0_0member = ku0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.checkBoundary
input String mediumName;
input String substanceNames[:] "Names of substances";
input Boolean singleState;
input Boolean define_p;
discrete input Real X_boundary[:];
input String modelName(start = "??? boundary ???");
protected 
Integer nX(start = size(X_boundary, 1));
String X_str;
public 
algorithm 
assert( not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""+modelName+"\":
The selected medium \""+mediumName+"\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");
for i in (1:nX) loop
assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\":
The boundary value X_boundary("+       String(i, true, 0)+") = "+       String(X_boundary[i], true, 0)+"
is negative. It must be positive.
");
end for;
if (nX > 0 and abs(sum(X_boundary)-1.0) > 1E-010) then 
X_str := "";
for i in (1:nX) loop
X_str := X_str+"   X_boundary["+       String(i, true, 0)+"] = "+       String(X_boundary[i], true, 0)+" \""+substanceNames[i]+"\"\n";
end for;
ModelicaError("The boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\"\n"+"do not sum up to 1. Instead, sum(X_boundary) = "+       String(sum(X_boundary), true, 0)+":\n"+X_str);
end if;
end Modelica.Fluid.Utilities.checkBoundary;

  */
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Fluid.Utilities.checkBoundary")
  {
    /* Declare outputs and temporaries */
    int   nX0_0;
    const char*   Xx_0str;
    MarkObject retmark_ = PushMark();
    nX0_0 = RealSize( Xx_0boundary, 1);
    Xx_0str="";
    /* Start of real code */
      AssertModelica( NOT singleState0_0 OR singleState0_0 AND definex_0p,
        " not singleState or singleState and define_p", StringAdd(StringAdd(
        StringAdd(StringAdd("\nWrong value of parameter define_p (= false) in model \"",
        modelName0_0),"\":\nThe selected medium \""),mediumName0_0),
        "\" has Medium.singleState=true.\nTherefore, an boundary density cannot be defined and\ndefine_p = true is required.\n"));
      {
        int end_ = nX0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          AssertModelica(RealElement( Xx_0boundary, (SizeType)(i0_0_0)) >= 0.0,
            "X_boundary[i] >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
            StringAdd(StringAdd(StringAdd(StringAdd("\nWrong boundary mass fractions in medium \"",
            mediumName0_0),"\" in model \""),modelName0_0),"\":\nThe boundary value X_boundary("),
            Integer2String2(i0_0_0, true, 0)),") = "),Real2String2(RealElement( 
            Xx_0boundary, (SizeType)(i0_0_0)), true, 0)),"\nis negative. It must be positive.\n"));
        }
      }
      if (nX0_0 > 0 AND fabs(Realsum( Xx_0boundary)-1.0) > 1E-010) {
        Xx_0str = "";
        Release();
        {
          int end_ = nX0_0;
          int i0_0_0;
          for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
            Xx_0str = StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
              StringAdd(StringAdd(Xx_0str,"   X_boundary["),Integer2String2(
              i0_0_0, true, 0)),"] = "),Real2String2(RealElement( Xx_0boundary, 
              (SizeType)(i0_0_0)), true, 0))," \""),StringElement( 
              substanceNames0_0, (SizeType)(i0_0_0))),"\"\n");
          }
        }
        ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd(StringAdd("The boundary mass fractions in medium \"",
          mediumName0_0),"\" in model \""),modelName0_0),"\"\n"),
          "do not sum up to 1. Instead, sum(X_boundary) = "),Real2String2(
          Realsum( Xx_0boundary), true, 0)),":\n"),Xx_0str));
        Release();
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.cubicHermite
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower gradient";
discrete input Real y2d "Upper gradient";
discrete output Real y "Interpolated ordinate value";
protected 
discrete Real h "Distance between x1 and x2";
discrete Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
discrete Real h00 "Basis function 00 of cubic Hermite spline";
discrete Real h10 "Basis function 10 of cubic Hermite spline";
discrete Real h01 "Basis function 01 of cubic Hermite spline";
discrete Real h11 "Basis function 11 of cubic Hermite spline";
discrete Real aux3 "t cube";
discrete Real aux2 "t square";
public 
algorithm 
h := x2-x1;
if (abs(h) > 0) then 
t := (x-x1)/h;
aux3 := t^3;
aux2 := t^2;
h00 := 2*aux3-3*aux2+1;
h10 := aux3-2*aux2+t;
h01 := ( -2*aux3)+3*aux2;
h11 := aux3-aux2;
y := y1*h00+h*y1d*h10+y2*h01+h*y2d*h11;
else
y := (y1+y2)/2;
end if;
annotation(derivative=Modelica.Fluid.Utilities.cubicHermite:der, smoothOrder=3);
end Modelica.Fluid.Utilities.cubicHermite;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_cubicHermite(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0) {
  PushContext("Modelica.Fluid.Utilities.cubicHermite")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   h0_0;
    double   t0_0;
    double   h000_0;
    double   h100_0;
    double   h010_0;
    double   h110_0;
    double   aux30_0;
    double   aux20_0;
    y0_0=0;
    h0_0=0;
    t0_0=0;
    h000_0=0;
    h100_0=0;
    h010_0=0;
    h110_0=0;
    aux30_0=0;
    aux20_0=0;
    /* Start of real code */
      h0_0 = x20_0-x10_0;
      if (fabs(h0_0) > 0) {
        t0_0 = divmacro(x0_0-x10_0,"x-x1",h0_0,"h");
        aux30_0 = powmacro(t0_0,"t",3,"3");
        aux20_0 = sqr(t0_0);
        h000_0 = 2*aux30_0-3*aux20_0+1;
        h100_0 = aux30_0-2*aux20_0+t0_0;
        h010_0 = ( -2*aux30_0)+3*aux20_0;
        h110_0 = aux30_0-aux20_0;
        y0_0 = y10_0*h000_0+h0_0*y1d0_0*h100_0+y20_0*h010_0+h0_0*y2d0_0*h110_0;
      }
      else{
        y0_0 = (y10_0+y20_0)/(double)(2);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.cubicHermite:der
discrete input Real x;
discrete input Real x1;
discrete input Real x2;
discrete input Real y1;
discrete input Real y2;
discrete input Real y1d;
discrete input Real y2d;
protected 
discrete Real y;
discrete Real h;
discrete Real t;
discrete Real h00;
discrete Real h10;
discrete Real h01;
discrete Real h11;
discrete Real aux3;
discrete Real aux2;
public 
discrete input Real x_der;
discrete input Real x1_der;
discrete input Real x2_der;
discrete input Real y1_der;
discrete input Real y2_der;
discrete input Real y1d_der;
discrete input Real y2d_der;
discrete output Real y_der;
protected 
discrete Real h_der;
discrete Real t_der;
discrete Real h00_der;
discrete Real h10_der;
discrete Real h01_der;
discrete Real h11_der;
discrete Real aux3_der;
discrete Real aux2_der;
public 
algorithm 
h_der := x2_der-x1_der;
h := x2-x1;
if (abs(h) > 0) then 
t_der := (x_der-x1_der)/h-(x-x1)*h_der/h^2;
t := (x-x1)/h;
aux3_der := 3.0*(t^2*t_der);
aux3 := t^3;
aux2_der := 2.0*(t*t_der);
aux2 := t^2;
h00_der := 2*aux3_der-3*aux2_der;
h00 := 1+2*aux3-3*aux2;
h10_der := aux3_der-2*aux2_der+t_der;
h10 := aux3-2*aux2+t;
h01_der := 3*aux2_der-2*aux3_der;
h01 := 3*aux2-2*aux3;
h11_der := aux3_der-aux2_der;
h11 := aux3-aux2;
y_der := y1_der*h00+y1*h00_der+(h_der*y1d+h*y1d_der)*h10+h*y1d*h10_der+y2_der*h01+y2*h01_der+(h_der*y2d+h*y2d_der)*h11+h*y2d*h11_der;
else
y_der := 0.5*(y1_der+y2_der);
end if;
annotation(smoothOrder=2);
end Modelica.Fluid.Utilities.cubicHermite:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_cubicHermite__der(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0, double  xx_0der, double  x1x_0der, double  x2x_0der, double  
  y1x_0der, double  y2x_0der, double  y1dx_0der, double  y2dx_0der) {
  PushContext("Modelica.Fluid.Utilities.cubicHermite:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   h0_0;
    double   t0_0;
    double   h000_0;
    double   h100_0;
    double   h010_0;
    double   h110_0;
    double   aux30_0;
    double   aux20_0;
    double   yx_0der;
    double   hx_0der;
    double   tx_0der;
    double   h00x_0der;
    double   h10x_0der;
    double   h01x_0der;
    double   h11x_0der;
    double   aux3x_0der;
    double   aux2x_0der;
    y0_0=0;
    h0_0=0;
    t0_0=0;
    h000_0=0;
    h100_0=0;
    h010_0=0;
    h110_0=0;
    aux30_0=0;
    aux20_0=0;
    yx_0der=0;
    hx_0der=0;
    tx_0der=0;
    h00x_0der=0;
    h10x_0der=0;
    h01x_0der=0;
    h11x_0der=0;
    aux3x_0der=0;
    aux2x_0der=0;
    /* Start of real code */
      hx_0der = x2x_0der-x1x_0der;
      h0_0 = x20_0-x10_0;
      if (fabs(h0_0) > 0) {
        tx_0der = divmacro(xx_0der-x1x_0der,"x_der-x1_der",h0_0,"h")-divmacro((
          x0_0-x10_0)*hx_0der,"(x-x1)*h_der",sqr(h0_0),"h^2");
        t0_0 = divmacro(x0_0-x10_0,"x-x1",h0_0,"h");
        aux3x_0der = 3.0*sqr(t0_0)*tx_0der;
        aux30_0 = powmacro(t0_0,"t",3,"3");
        aux2x_0der = 2.0*t0_0*tx_0der;
        aux20_0 = sqr(t0_0);
        h00x_0der = 2*aux3x_0der-3*aux2x_0der;
        h000_0 = 1+2*aux30_0-3*aux20_0;
        h10x_0der = aux3x_0der-2*aux2x_0der+tx_0der;
        h100_0 = aux30_0-2*aux20_0+t0_0;
        h01x_0der = 3*aux2x_0der-2*aux3x_0der;
        h010_0 = 3*aux20_0-2*aux30_0;
        h11x_0der = aux3x_0der-aux2x_0der;
        h110_0 = aux30_0-aux20_0;
        yx_0der = y1x_0der*h000_0+y10_0*h00x_0der+(hx_0der*y1d0_0+h0_0*y1dx_0der)
          *h100_0+h0_0*y1d0_0*h10x_0der+y2x_0der*h010_0+y20_0*h01x_0der+(hx_0der
          *y2d0_0+h0_0*y2dx_0der)*h110_0+h0_0*y2d0_0*h11x_0der;
      }
      else{
        yx_0der = 0.5*(y1x_0der+y2x_0der);
      }
    /* Output section */
    PopContext()
    return yx_0der;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne
discrete input Real den1[:] "[s] coefficients of polynomials (den1[i]*s + 1)";
discrete input Real den2[:, 2] "[s^2, s] coefficients of polynomials (den2[i,1]*s^2 + den2[i,2]*s + 1)";
discrete output Real cr[size(den1, 1)] "[s^0] coefficients of polynomials cr[i]*(s+1/cr[i])";
discrete output Real c0[size(den2, 1)] "[s^0] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";
discrete output Real c1[size(den2, 1)] "[s^1] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";

algorithm 
for i in (1:size(den1, 1)) loop
cr[i] := 1/den1[i];
end for;
for i in (1:size(den2, 1)) loop
c1[i] := den2[i, 2]/den2[i, 1];
c0[i] := 1/den2[i, 1];
end for;
end Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
   Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne(
  RealArray   den10_0, RealArray   den20_0) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne")
  AssertModelica(RealSize( den20_0,2)==2,"size(den2, 2) == 2","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, RealSize( den10_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    c00_0=RealTemporary( 1, RealSize( den20_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( den20_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( c10_0, 0);
    /* Start of real code */
      {
        int end_ = RealSize( den10_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(divmacro(1,"1",RealElement( den10_0, (SizeType)(i0_0_0)),
            "den1[i]"), cr0_0, (SizeType)(i0_0_0));
        }
      }
      {
        int end_ = RealSize( den20_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(divmacro(RealElement( den20_0, (SizeType)(i0_0_0), 
            (SizeType)(2)),"den2[i, 2]",RealElement( den20_0, (SizeType)(i0_0_0),
             (SizeType)(1)),"den2[i, 1]"), c10_0, (SizeType)(i0_0_0));
          SetRealElement(divmacro(1,"1",RealElement( den20_0, (SizeType)(i0_0_0),
             (SizeType)(1)),"den2[i, 1]"), c00_0, (SizeType)(i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct out_;
      out_.cr0_0_0member = cr0_0;
      out_.c00_0_0member = c00_0;
      out_.c10_0_0member = c10_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass
discrete input Real cr_in[:] "Coefficients of real poles";
discrete input Real c0_in[:] "Coefficients of s^0 term if conjugate complex pole";
discrete input Real c1_in[size(c0_in, 1)] "Coefficients of s^1 term if conjugate complex pole";
discrete input Real f_cut(unit = "Hz") "Cut-off frequency";
discrete output Real cr[size(cr_in, 1)] "Coefficient of real pole";
discrete output Real c0[size(c0_in, 1)] "Coefficients of s^0 term if conjugate complex pole";
discrete output Real c1[size(c0_in, 1)] "Coefficients of s^1 term if conjugate complex pole";
protected 
constant Real pi = 3.141592653589793;
discrete Real w_cut(start = 2.0*(pi*f_cut), unit = "rad/s") "Cut-off angular frequency";
discrete Real w_cut2(start = w_cut*w_cut);
public 
algorithm 
assert(f_cut > 0, "Cut-off frequency f_cut must be positive");
cr := w_cut*cr_in;
c1 := w_cut*c1_in;
c0 := w_cut2*c0_in;
end Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass(RealArray   
  crx_0in, RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass")
  AssertModelica(RealSize( c1x_0in,1)==RealSize( c0x_0in, 1),"size(c1_in, 1) == size(c0_in, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    double   pi0_0;
    double   wx_0cut;
    double   wx_0cut2;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    c00_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( c10_0, 0);
    pi0_0 = 3.141592653589793;
    wx_0cut = 2.0*pi0_0*fx_0cut;
    wx_0cut2 = wx_0cut*wx_0cut;
    /* Start of real code */
      AssertModelica(fx_0cut > 0,"f_cut > 0", "Cut-off frequency f_cut must be positive");
      RealAssign (cr0_0, RealScale (crx_0in,wx_0cut));
      Release();
      RealAssign (c10_0, RealScale (c1x_0in,wx_0cut));
      Release();
      RealAssign (c00_0, RealScale (c0x_0in,wx_0cut2));
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct out_;
      out_.cr0_0_0member = cr0_0;
      out_.c00_0_0member = c00_0;
      out_.c10_0_0member = c10_0;
      return out_;
    }
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
BreakSectionFunctionDef(2)
BreakSectionFunctionDef(4)
BreakSectionFunctionDef(5)
BreakSectionFunctionDef(6)
#include <moutil.c>
PreNonAliasDef(0)
PreNonAliasDef(1)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="TestPipeModel.Example01";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/ottelien/appdata/roaming/dynasim/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC long QJacobianCG_[10]={4 , 2 , 1 , 2 , 1 , 3 , 1 , 4 , 1 , 5};
DYMOLA_STATIC long QJacobianGC_[21]={
1 , 2 , 2 , 1 , 1 , 0 , 0 , 3 , 3 , 3 , 4 , 0 , 0 , 4 , 4 , 0 , 0 , 0 , 5 , 5 , 
  0};
DYMOLA_STATIC double QJacobianCD_[6]={0  , 44 , 55 , 60 , 63 , 64};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
W_[15] = 1;
W_[16] = 1;
W_[17] = 1;
W_[18] = 1;
W_[20] = false;
W_[21] = false;
W_[22] = true;
W_[24] = 2;
W_[26] = true;
W_[29] = 1;
W_[35] = false;
W_[44] = 0.016;
W_[46] = 0.001;
W_[47] = true;
W_[50] = 0.016;
W_[52] = false;
W_[55] = 0.001;
W_[60] = 0.016;
W_[61] = 0.001;
W_[69] = 1;
W_[70] = 1;
W_[71] = 1;
W_[75] = true;
W_[82] = 0.016;
W_[84] = false;
W_[86] = 1;
W_[87] = 1;
W_[88] = 1;
W_[89] = 1;
W_[94] = false;
W_[95] = true;
W_[96] = true;
W_[98] = 2;
W_[109] = false;
W_[114] = true;
W_[115] = true;
W_[120] = true;
W_[127] = false;
W_[128] = true;
W_[131] = true;
W_[160] = true;
W_[164] = true;
W_[168] = 1;
W_[169] = 1;
W_[170] = 2;
W_[173] = 2;
W_[176] = 2;
W_[177] = 0;
W_[178] = 0;
W_[179] = 2;
W_[185] = true;
W_[187] = 0.016;
W_[189] = false;
W_[193] = 0.001;
W_[202] = true;
W_[203] = 0.016;
W_[205] = false;
W_[208] = 0.001;
W_[213] = 0.016;
W_[214] = 0.001;
W_[219] = true;
W_[224] = false;
W_[225] = false;
W_[244] = 0.016;
W_[245] = 0.001;
W_[246] = 1;
W_[264] = 3;
W_[265] = false;
W_[266] = false;
W_[267] = false;
W_[268] = false;
W_[283] = false;
W_[284] = true;
W_[285] = 2;
DYNSetAuxString("WaterDetailed", 0);
W_[322] = false;
W_[323] = true;
W_[324] = 2;
W_[19] = 1;
W_[45] = 0.001;
W_[116] = 1;
W_[165] = 4;
W_[194] = false;
W_[195] = 0.1;
W_[23] = 0.016;
W_[25] = 1.6000000000000001E-006;
W_[27] = 0.001;
W_[30] = 293.15;
W_[31] = 300000.0;
W_[32] = 998.1931899999996;
W_[36] = 0;
W_[51] = 1.6000000000000001E-006;
W_[54] = false;
W_[56] = true;
W_[57] = false;
W_[65] = true;
W_[62] = false;
W_[63] = 0.3;
W_[58] = 0.0048;
W_[64] = 0.5059644256269408;
W_[66] = 0.001;
W_[72] = 1;
W_[73] = 1;
W_[74] = 1;
W_[81] = false;
W_[83] = 1.6000000000000001E-006;
W_[93] = 1;
W_[97] = 0.016;
W_[99] = 1.6000000000000001E-006;
W_[100] = true;
W_[112] = 1.0;
W_[104] = 293.15;
W_[106] = 998.1931899999996;
W_[113] = 1.6028961287543954E-005;
W_[101] = 1.6028961287543954E-005;
W_[105] = 300000.0;
W_[110] = 0;
W_[123] = false;
W_[124] = false;
W_[126] = 1.6000000000000001E-006;
W_[137] = false;
W_[138] = true;
W_[162] = 300000;
W_[172] = 4;
W_[175] = 0.016;
W_[188] = 1.6000000000000001E-006;
W_[191] = true;
W_[192] = false;
W_[198] = 4;
W_[199] = true;
W_[204] = 1.6000000000000001E-006;
W_[207] = false;
W_[209] = true;
W_[210] = false;
W_[218] = true;
W_[215] = false;
W_[216] = 0.1;
W_[211] = 0.0016;
W_[217] = 0.5059644256269408;
W_[220] = false;
W_[221] = false;
W_[222] = 0;
W_[223] = 1.6000000000000001E-006;
W_[229] = 0.016;
W_[232] = 4;
W_[242] = 0.016;
W_[257] = true;
W_[258] = true;
W_[269] = 300000;
W_[270] = 293.15;
W_[271] = 1;
W_[275] = 1;
W_[276] = 1;
W_[277] = 1;
W_[278] = 1;
W_[282] = 1.0;
W_[293] = true;
W_[294] = true;
W_[302] = 0.001;
W_[310] = 293.15;
W_[312] = 998.1931899999996;
W_[307] = 4184;
W_[303] = 0.0;
W_[309] = false;
W_[311] = 300000.0;
W_[314] = 1;
W_[315] = 1;
W_[316] = 1;
W_[317] = 1;
W_[321] = 1.0;
W_[332] = true;
W_[333] = true;
W_[341] = 1.6028961287543954E-005;
W_[349] = 293.15;
W_[351] = 998.1931899999996;
W_[346] = 4184;
W_[342] = 0.0;
W_[348] = false;
W_[350] = 300000.0;
W_[196] = 1E+060;
W_[197] = -1E+060;
W_[184] = 1.0;
W_[67] = 0;
W_[263] = 83680.0;
W_[226] = 0;
W_[12] = 300000;
W_[274] = 1.0;
W_[13] = 4184;
W_[37] = 0;
W_[111] = 0;
W_[132] = 0;
W_[238] = 0;
W_[239] = 0;
W_[240] = 1;
W_[241] = 1;
W_[249] = 998.1931899999996;
W_[251] = 1.0;
W_[252] = 83379.45697585856;
W_[259] = 20.0;
W_[260] = 3.0000000000000004;
W_[288] = 1.0;
W_[327] = 1.0;
W_[273] = 293.15;
W_[254] = 0.018015268;
W_[253] = 8.314472;
W_[250] = 293.15;
W_[248] = 83680.0;
W_[247] = 300000.0;
W_[255] = 293.15;
W_[256] = 300000.0;
W_[272] = 300000.0;
W_[262] = 300000.0;
W_[243] = 0.016;
W_[167] = 0.016;
W_[118] = 0.0;
W_[166] = 0.016;
W_[80] = 300000.0;
W_[122] = 300000.0;
W_[343] = 0.0;
W_[331] = 0.018015268;
W_[330] = 8.314472;
W_[39] = 300000.0;
W_[48] = 300000.0;
W_[68] = 83680.0;
W_[304] = 0.0;
W_[292] = 0.018015268;
W_[291] = 8.314472;
BoundParameterSection
AssertModelica(DP_[39] > 0,"fan.filter.A_ripple > 0", "A_ripple > 0 required");
W_[9] = DP_[7];
W_[10] = DP_[8];
W_[33] = DP_[4];
W_[28] = IF W_[33] < 278.15 THEN 1011.9695761-0.042860825*W_[33] ELSE IF W_[33]
   < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(W_[33],"pipe.vol.state_start.T",3,
  "3")-0.01813488505*sqr(W_[33])+6.5619527954075*W_[33] ELSE 1220.35045233-
  0.7025109*W_[33];
W_[34] = DP_[3];
W_[59] = (IF DP_[12] < 278.15 THEN 1011.9695761-0.042860825*DP_[12] ELSE IF 
  DP_[12] < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(DP_[12],
  "pipe.res.sta_default.T",3,"3")-0.01813488505*sqr(DP_[12])+6.5619527954075*
  DP_[12] ELSE 1220.35045233-0.7025109*DP_[12])*(IF DP_[12] < 278.15 THEN 
  1.44011135763E-005-4.63023776563E-008*DP_[12] ELSE 1E-006*exp(40.4003044106506
  +0.00080910285895*sqr(DP_[12])-7.22111E-007*powmacro(DP_[12],"pipe.res.sta_default.T",3,
  "3")-0.312920238272193*DP_[12]));
W_[90] = DP_[16];
W_[91] = DP_[17];
W_[92] = DP_[18];
W_[107] = W_[91];
W_[103] = IF W_[107] < 278.15 THEN 1011.9695761-0.042860825*W_[107] ELSE IF 
  W_[107] < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(W_[107],
  "fan.vol.state_start.T",3,"3")-0.01813488505*sqr(W_[107])+6.5619527954075*
  W_[107] ELSE 1220.35045233-0.7025109*W_[107];
W_[108] = W_[90];
W_[125] = DP_[37];
W_[134] = DP_[17];
W_[135] = DP_[16];
W_[136] = 4184*(W_[134]-273.15);
W_[139] = IF DP_[34] < 278.15 THEN 1011.9695761-0.042860825*DP_[34] ELSE IF 
  DP_[34] < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(DP_[34],
  "fan.sta_default.T",3,"3")-0.01813488505*sqr(DP_[34])+6.5619527954075*DP_[34]
   ELSE 1220.35045233-0.7025109*DP_[34];
W_[148] = DP_[26];
W_[149] = DP_[27];
W_[150] = DP_[28];
W_[151] = DP_[29];
W_[152] = DP_[30];
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
W_[153] = DP_[31];
W_[154] = DP_[32];
W_[155] = DP_[33];
W_[163] = divmacro(0.016,"0.016",W_[139],"fan.rho_default");
W_[156] = 0.001*W_[163];
W_[171] = divmacro(5,"5",6.283185307179586*DP_[36],"6.283185307179586*fan.riseTime");
W_[174] = DP_[37];
W_[212] = (IF DP_[52] < 278.15 THEN 1011.9695761-0.042860825*DP_[52] ELSE IF 
  DP_[52] < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(DP_[52],
  "hea.preDro.sta_default.T",3,"3")-0.01813488505*sqr(DP_[52])+6.5619527954075*
  DP_[52] ELSE 1220.35045233-0.7025109*DP_[52])*(IF DP_[52] < 278.15 THEN 
  1.44011135763E-005-4.63023776563E-008*DP_[52] ELSE 1E-006*exp(40.4003044106506
  +0.00080910285895*sqr(DP_[52])-7.22111E-007*powmacro(DP_[52],"hea.preDro.sta_default.T",3,
  "3")-0.312920238272193*DP_[52]));
W_[227] = W_[196];
W_[228] = W_[197];
W_[230] = DP_[47];
W_[231] = DP_[48];
W_[233] = NotEqual(W_[227], 1E+060, 0);
W_[234] = NotEqual(W_[228], -1E+060, 1);
W_[235] = 0.01*DP_[58]*W_[223];
W_[236] = W_[230] > 1E-010 OR W_[230] < -1E-010;
W_[279] = DP_[3];
W_[280] = DP_[4];
W_[281] = DP_[5];
W_[308] = IF W_[280] < 278.15 THEN 1011.9695761-0.042860825*W_[280] ELSE IF 
  W_[280] < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(W_[280],
  "pipe.vol.dynBal.T_start",3,"3")-0.01813488505*sqr(W_[280])+6.5619527954075*
  W_[280] ELSE 1220.35045233-0.7025109*W_[280];
W_[313] = 4184*(W_[280]-273.15);
W_[318] = W_[90];
W_[319] = W_[91];
W_[320] = W_[92];
W_[347] = IF W_[319] < 278.15 THEN 1011.9695761-0.042860825*W_[319] ELSE IF 
  W_[319] < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(W_[319],
  "fan.vol.dynBal.T_start",3,"3")-0.01813488505*sqr(W_[319])+6.5619527954075*
  W_[319] ELSE 1220.35045233-0.7025109*W_[319];
W_[352] = 4184*(W_[319]-273.15);
W_[7] = DP_[2]*(W_[10]-W_[9])+4184.0*(W_[10]-W_[9]);
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
W_[11] = 293.15;
W_[38] = 0;
W_[42] = 0;
W_[53] = 0;
W_[76] = 300000;
W_[85] = 0;
W_[161] = 1;
W_[190] = 0;
W_[200] = 288.15;
W_[206] = 0;
F_[0] = 0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
W_[2] = DP_[4];
W_[40] = W_[313];
W_[43] = W_[279];
W_[77] = W_[136];
W_[79] =  -W_[125];
W_[117] = W_[91];
W_[121] = W_[136];
W_[129] = DP_[22];
W_[286] = W_[308];
W_[297] = 0.001*W_[308]*(4184*(W_[280]-273.15)-divmacro(300000,"300000",IF 
  W_[280] < 278.15 THEN 1011.9695761-0.042860825*W_[280] ELSE IF W_[280] < 
  373.15 THEN 254.900074971947+1.5009E-005*powmacro(W_[280],"pipe.vol.dynBal.T_start",3,
  "3")-0.01813488505*sqr(W_[280])+6.5619527954075*W_[280] ELSE 1220.35045233-
  0.7025109*W_[280],"smooth(1, (if pipe.vol.dynBal.T_start < 278.15 then 1011.9695761-0.042860825*pipe.vol.dynBal.T_start else (if pipe.vol.dynBal.T_start < 373.15 then 254.900074971947+1.5009E-005*pipe.vol.dynBal.T_start^3-0.01813488505*pipe.vol.dynBal.T_start^2+6.5619527954075*pipe.vol.dynBal.T_start else 1220.35045233-0.7025109*pipe.vol.dynBal.T_start)))"));
W_[299] = 0.001*W_[28];
W_[325] = W_[347];
W_[336] = 1.6028961287543954E-005*W_[347]*(4184*(W_[319]-273.15)-divmacro(300000,
  "300000",IF W_[319] < 278.15 THEN 1011.9695761-0.042860825*W_[319] ELSE IF 
  W_[319] < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(W_[319],
  "fan.vol.dynBal.T_start",3,"3")-0.01813488505*sqr(W_[319])+6.5619527954075*
  W_[319] ELSE 1220.35045233-0.7025109*W_[319],"smooth(1, (if fan.vol.dynBal.T_start < 278.15 then 1011.9695761-0.042860825*fan.vol.dynBal.T_start else (if fan.vol.dynBal.T_start < 373.15 then 254.900074971947+1.5009E-005*fan.vol.dynBal.T_start^3-0.01813488505*fan.vol.dynBal.T_start^2+6.5619527954075*fan.vol.dynBal.T_start else 1220.35045233-0.7025109*fan.vol.dynBal.T_start)))"));
W_[338] = 1.6028961287543954E-005*W_[103];
InitialStartSection
Aux_[6] = W_[136];
Aux_[6] = W_[136];
InitialStartSection2
X_[3] = W_[280];
X_[4] = W_[319];
InitialSection
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
F_[1] = 0.0;
W_[9] = DP_[7];
W_[10] = DP_[8];
W_[33] = DP_[4];
W_[28] = IF W_[33] < 278.15 THEN 1011.9695761-0.042860825*W_[33] ELSE IF W_[33]
   < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(W_[33],"pipe.vol.state_start.T",3,
  "3")-0.01813488505*sqr(W_[33])+6.5619527954075*W_[33] ELSE 1220.35045233-
  0.7025109*W_[33];
W_[34] = DP_[3];
W_[59] = (IF DP_[12] < 278.15 THEN 1011.9695761-0.042860825*DP_[12] ELSE IF 
  DP_[12] < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(DP_[12],
  "pipe.res.sta_default.T",3,"3")-0.01813488505*sqr(DP_[12])+6.5619527954075*
  DP_[12] ELSE 1220.35045233-0.7025109*DP_[12])*(IF DP_[12] < 278.15 THEN 
  1.44011135763E-005-4.63023776563E-008*DP_[12] ELSE 1E-006*exp(40.4003044106506
  +0.00080910285895*sqr(DP_[12])-7.22111E-007*powmacro(DP_[12],"pipe.res.sta_default.T",3,
  "3")-0.312920238272193*DP_[12]));
W_[90] = DP_[16];
W_[91] = DP_[17];
W_[92] = DP_[18];
W_[107] = W_[91];
W_[103] = IF W_[107] < 278.15 THEN 1011.9695761-0.042860825*W_[107] ELSE IF 
  W_[107] < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(W_[107],
  "fan.vol.state_start.T",3,"3")-0.01813488505*sqr(W_[107])+6.5619527954075*
  W_[107] ELSE 1220.35045233-0.7025109*W_[107];
W_[108] = W_[90];
W_[125] = DP_[37];
W_[134] = DP_[17];
W_[135] = DP_[16];
W_[136] = 4184*(W_[134]-273.15);
W_[139] = IF DP_[34] < 278.15 THEN 1011.9695761-0.042860825*DP_[34] ELSE IF 
  DP_[34] < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(DP_[34],
  "fan.sta_default.T",3,"3")-0.01813488505*sqr(DP_[34])+6.5619527954075*DP_[34]
   ELSE 1220.35045233-0.7025109*DP_[34];
W_[148] = DP_[26];
W_[149] = DP_[27];
W_[150] = DP_[28];
W_[151] = DP_[29];
W_[152] = DP_[30];
W_[153] = DP_[31];
W_[163] = divmacro(0.016,"0.016",W_[139],"fan.rho_default");
W_[156] = 0.001*W_[163];
W_[171] = divmacro(5,"5",6.283185307179586*DP_[36],"6.283185307179586*fan.riseTime");
AssertModelica(W_[171] > 0,"fan.filter.f_cut > 0", "f_cut > 0 required");
W_[174] = DP_[37];
W_[212] = (IF DP_[52] < 278.15 THEN 1011.9695761-0.042860825*DP_[52] ELSE IF 
  DP_[52] < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(DP_[52],
  "hea.preDro.sta_default.T",3,"3")-0.01813488505*sqr(DP_[52])+6.5619527954075*
  DP_[52] ELSE 1220.35045233-0.7025109*DP_[52])*(IF DP_[52] < 278.15 THEN 
  1.44011135763E-005-4.63023776563E-008*DP_[52] ELSE 1E-006*exp(40.4003044106506
  +0.00080910285895*sqr(DP_[52])-7.22111E-007*powmacro(DP_[52],"hea.preDro.sta_default.T",3,
  "3")-0.312920238272193*DP_[52]));
W_[227] = W_[196];
W_[228] = W_[197];
W_[230] = DP_[47];
W_[231] = DP_[48];
W_[235] = 0.01*DP_[58]*W_[223];
W_[279] = DP_[3];
W_[280] = DP_[4];
W_[281] = DP_[5];
W_[308] = IF W_[280] < 278.15 THEN 1011.9695761-0.042860825*W_[280] ELSE IF 
  W_[280] < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(W_[280],
  "pipe.vol.dynBal.T_start",3,"3")-0.01813488505*sqr(W_[280])+6.5619527954075*
  W_[280] ELSE 1220.35045233-0.7025109*W_[280];
W_[313] = 4184*(W_[280]-273.15);
W_[318] = W_[90];
W_[319] = W_[91];
W_[320] = W_[92];
W_[347] = IF W_[319] < 278.15 THEN 1011.9695761-0.042860825*W_[319] ELSE IF 
  W_[319] < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(W_[319],
  "fan.vol.dynBal.T_start",3,"3")-0.01813488505*sqr(W_[319])+6.5619527954075*
  W_[319] ELSE 1220.35045233-0.7025109*W_[319];
W_[352] = 4184*(W_[319]-273.15);
W_[154] = DP_[32];
W_[155] = DP_[33];
W_[233] = NotEqual(W_[227], 1E+060, 0);
W_[234] = NotEqual(W_[228], -1E+060, 1);
W_[236] = W_[230] > 1E-010 OR W_[230] < -1E-010;
  RealAssign (RealTemporaryDense( &W_[157], 1, 1), RealConvertInteger (IF 
    W_[155] THEN IntegerFill( 0, 1, (SizeType)(1)) ELSE IntegerTemporaryDense( 
    DymArrays0, 1, 1)));
  PopAllMarks();
  RealAssign (RealTemporaryDense( &W_[158], 1, 1), RealConvertInteger (IF 
    W_[155] THEN IntegerFill( 0, 1, (SizeType)(1)) ELSE IntegerTemporaryDense( 
    DymArrays0, 1, 1)));
  PopAllMarks();
RealAssign (RealTemporaryDense( &W_[180], 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping(2, fan.filter.normalized)")
  Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping(2, DP_[41])));
PopAllMarks();
{
  struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
     dummy_mult_=(PushModelContext(1,"Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass(fan.filter.cr, fan.filter.c0, fan.filter.c1, fan.filter.f_cut)")
    Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealTemporaryDense( 
    &W_[180], 1, 2), RealTemporaryDense( (Real*)(0), 1, 0), RealTemporaryDense( 
    (Real*)(0), 1, 0), W_[171]));
  RealAssign (RealTemporaryDense( &W_[182], 1, 2), dummy_mult_.r0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.a0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.b0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.ku0_0_0member);
}
PopAllMarks();
W_[7] = DP_[2]*(W_[10]-W_[9])+4184.0*(W_[10]-W_[9]);
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
helpvar[0] =  -W_[182];
X_[1] = 0.0;
SolveScalarLinearParametric(helpvar[0]," -fan.filter.r[1]", helpvar[0],
  " -fan.filter.r[1]", X_[1],"fan.filter.x[1]");
 /* End of Equation Block */ 

W_[79] =  -W_[174];
 /* Linear system of equations to solve. */
X_[2] = 0.0;
SolveScalarLinearParametric(0.016*DP_[38],"0.016*fan.filter.gain",  -W_[79],
  " -fan.port_b.m_flow", X_[2],"fan.filter.x[2]");
 /* End of Equation Block */ 

X_[3] = W_[280];
X_[4] = W_[319];
W_[77] = 4184*(X_[4]-273.15);
W_[325] = IF X_[4] < 278.15 THEN 1011.9695761-0.042860825*X_[4] ELSE IF X_[4] < 
  373.15 THEN 254.900074971947+1.5009E-005*powmacro(X_[4],"fan.vol.dynBal.medium.T",3,
  "3")-0.01813488505*sqr(X_[4])+6.5619527954075*X_[4] ELSE 1220.35045233-
  0.7025109*X_[4];
W_[328] = W_[77]-divmacro(300000,"300000",W_[325],"fan.vol.dynBal.medium.d");
W_[338] = 1.6028961287543954E-005*W_[325];
W_[200] = DP_[60]+(IF LessTime(DP_[61], 0) THEN 0 ELSE DP_[59]);
W_[186] = 4184*(W_[200]-273.15);
W_[40] = 4184*(X_[3]-273.15);
W_[117] = 273.15+0.0002390057361376673*W_[77];
W_[119] = IF 273.15+0.0002390057361376673*W_[186] < 278.15 THEN 1000.26214175125
  -1.0243983030592733E-005*W_[186] ELSE IF 273.15+0.0002390057361376673*W_[186]
   < 373.15 THEN 2047.2974810375053+1.5009E-005*powmacro(273.15+0.0002390057361376673
  *W_[186],"273.15+0.0002390057361376673*hea.port_b.h_outflow",3,"3")-
  0.01813488505*sqr(273.15+0.0002390057361376673*W_[186])+0.0015683443583669931*
  W_[186] ELSE 1028.459599995-0.0001679041347992352*W_[186];
W_[286] = IF X_[3] < 278.15 THEN 1011.9695761-0.042860825*X_[3] ELSE IF X_[3] < 
  373.15 THEN 254.900074971947+1.5009E-005*powmacro(X_[3],"pipe.vol.dynBal.medium.T",3,
  "3")-0.01813488505*sqr(X_[3])+6.5619527954075*X_[3] ELSE 1220.35045233-
  0.7025109*X_[3];
W_[289] = W_[40]-divmacro(300000,"300000",W_[286],"pipe.vol.dynBal.medium.d");
W_[299] = 0.001*W_[286];
W_[2] = 273.15+0.0002390057361376673*W_[40];
W_[1] = W_[2]-X_[0];
 /* Linear system of equations to solve. */
W_[0] = 0.0;
SolveScalarLinearParametric( -DP_[0]," -pipe.Rfg.R",  -W_[1]," -pipe.Rfg.dT", 
  W_[0],"pipe.Rfg.Q_flow");
 /* End of Equation Block */ 

InitialSection
BreakSectionFunctionEnd()
BreakSectionFunctionStart(2);
if (DymolaHomotopyLambda==0){
  BreakSectionCall(3);
}
else {
  { /* Non-linear system of equations to solve. */
    /* Nonlinear system of equations number = 2. */
  /* Introducing 126 common subexpressions used in 255 expressions */
  /* Of the common subexpressions 118 are reals, 0 are integers, and 8
     are booleans. */
  const char*const varnames_[]={"pipe.vol.dynBal.medium.der(T)", 
    "fan.vol.dynBal.medium.der(T)", "fan.WHyd", "fan.dp"};
  const double nominal_[]={1, 1, 1, 1e5};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 4, 0, 2, 7);
  SetInitVectorSimple(x__, 1, F_[3], 0.0);
  SetInitVectorSimple(x__, 2, F_[4], 0.0);
  SetInitVectorSimple(x__, 3, W_[141], 0.0);
  SetInitVectorSimple(x__, 4, W_[85], 0);
  Residues;
    helpvar[63] = X_[3] < 278.15;
    W_[287] = IF helpvar[63] THEN (-0.042860825)*F_[3] ELSE IF X_[3] < 373.15
       THEN 4.5027E-005*sqr(X_[3])*F_[3]-0.0362697701*X_[3]*F_[3]+
      6.5619527954075*F_[3] ELSE (-0.7025109)*F_[3];
    W_[41] = 4184*F_[3];
    helpvar[64] = sqr(W_[286]);
    helpvar[65] = divmacro(1.0,"1.0",helpvar[64],"pipe.vol.dynBal.medium.d^2");
    W_[290] = W_[41]+helpvar[65]*300000*W_[287];
    W_[300] = 0.001*W_[287];
    helpvar[66] = X_[4] < 278.15;
    W_[326] = IF helpvar[66] THEN (-0.042860825)*F_[4] ELSE IF X_[4] < 373.15
       THEN 4.5027E-005*sqr(X_[4])*F_[4]-0.0362697701*X_[4]*F_[4]+
      6.5619527954075*F_[4] ELSE (-0.7025109)*F_[4];
    W_[339] = 1.6028961287543954E-005*W_[326];
    W_[42] = W_[79]-W_[339];
    W_[38] = W_[300]-W_[42];
    W_[261] =  -(W_[79]+W_[38]);
    helpvar[67] = RealBmax( -W_[79], 0.0);
    helpvar[68] =  -W_[261];
    helpvar[69] = RealBmax(helpvar[68], 0.0);
    Aux_[16] = helpvar[67]+helpvar[69];
    helpvar[70] = Aux_[16] > 1E-010;
    Aux_[17] = IF helpvar[70] THEN 1.0 ELSE IF Aux_[16] > 0.0 THEN sqr(
      10000000000.0*Aux_[16])*(3.0-20000000000.0*Aux_[16]) ELSE 0.0;
    helpvar[71] = 1.0-Aux_[17];
    helpvar[72] = 1E-010*helpvar[71];
    helpvar[73] = Aux_[17]*helpvar[67]+helpvar[72];
    helpvar[74] = Aux_[17]*helpvar[69]+helpvar[72];
    helpvar[75] = helpvar[73]*W_[77]+83680.0*helpvar[74];
    helpvar[76] = helpvar[73]+helpvar[74];
    helpvar[77] = divmacro(1.0,"1.0",helpvar[76],"stream_alpha1*max( -fan.port_b.m_flow, 0.0)+1E-010*(1.0-stream_alpha1)+stream_alpha1*max( -boundary.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha1)");
    W_[49] = helpvar[77]*helpvar[75];
    helpvar[78] = W_[38] >= 0;
    W_[306] = IF helpvar[78] THEN W_[49]*W_[38] ELSE W_[40]*W_[38];
    W_[78] = 4184*F_[4];
    helpvar[79] = sqr(W_[325]);
    helpvar[80] = divmacro(1.0,"1.0",helpvar[79],"fan.vol.dynBal.medium.d^2");
    W_[329] = W_[78]+helpvar[80]*300000*W_[326];
    helpvar[81] =  -W_[38];
    helpvar[82] = RealBmax(helpvar[81], 0.0);
    Aux_[18] = helpvar[82]+helpvar[69];
    helpvar[83] = Aux_[18] > 1E-010;
    Aux_[19] = IF helpvar[83] THEN 1.0 ELSE IF Aux_[18] > 0.0 THEN sqr(
      10000000000.0*Aux_[18])*(3.0-20000000000.0*Aux_[18]) ELSE 0.0;
    helpvar[84] = 1.0-Aux_[19];
    helpvar[85] = 1E-010*helpvar[84];
    helpvar[86] = Aux_[19]*helpvar[82]+helpvar[85];
    helpvar[87] = Aux_[19]*helpvar[69]+helpvar[85];
    helpvar[88] = helpvar[86]*W_[40]+83680.0*helpvar[87];
    helpvar[89] = helpvar[86]+helpvar[87];
    helpvar[90] = divmacro(1.0,"1.0",helpvar[89],"stream_alpha3*max( -pipe.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha3)+stream_alpha3*max( -boundary.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha3)");
    W_[121] = helpvar[90]*helpvar[88];
    helpvar[91] = W_[79] >= 0;
    W_[345] = IF helpvar[91] THEN W_[121]*W_[79] ELSE W_[77]*W_[79];
    helpvar[92] =  -W_[42];
    helpvar[93] = helpvar[92] >= 0;
    W_[344] = IF helpvar[93] THEN  -W_[186]*W_[42] ELSE  -W_[77]*W_[42];
    helpvar[94] = divmacro(1.0,"1.0",W_[119],"fan.rho_in");
    W_[147] =  -helpvar[94]*W_[42];
    W_[146] = (PushModelContext(1,"IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency(\nfan.per.motorEfficiency, \nfan.VMachine_flow, \nfan.motDer, \n1, \n0.0001)")
      IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc0_construct(
      RealTemporaryDense( &DP_[28], 1, 1), RealTemporaryDense( &DP_[29], 1, 1)),
       W_[147], RealTemporaryDense( &W_[157], 1, 1), 1, 0.0001));
    PopAllMarks();
    W_[145] = (PushModelContext(1,"IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency(\nfan.per.hydraulicEfficiency, \nfan.VMachine_flow, \nfan.hydDer, \n1, \n0.0001)")
      IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc0_construct(
      RealTemporaryDense( &DP_[26], 1, 1), RealTemporaryDense( &DP_[27], 1, 1)),
       W_[147], RealTemporaryDense( &W_[158], 1, 1), 1, 0.0001));
    PopAllMarks();
    W_[144] = W_[145]*W_[146];
    W_[206] = homotopy((PushModelContext(1,"IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow( -pipe.port_b.m_flow, 0.5059644256269408, 0.0016)")
      IF helpvar[92] > 0.0016 THEN sqr((-1.9764235376052368)*W_[42]) ELSE IF 
      helpvar[92] < -0.0016 THEN  -sqr((-1.9764235376052368)*W_[42]) ELSE 
      1.9531249999999996*(625.0*powmacro(helpvar[92]," -pipe.port_b.m_flow",3,
      "3")-0.0016*W_[42])), (-0.0625)*W_[42]);
    PopModelContext();
    W_[53] = homotopy((PushModelContext(1,"IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(pipe.port_a.m_flow, 0.5059644256269408, 0.0048)")
      IF W_[38] > 0.0048 THEN sqr(1.9764235376052368*W_[38]) ELSE IF W_[38] < 
      -0.0048 THEN  -sqr(1.9764235376052368*W_[38]) ELSE 1.9531249999999996*(
      0.0048*W_[38]+208.33333333333334*powmacro(W_[38],"pipe.port_a.m_flow",3,
      "3"))), 0.0625*W_[38]);
    PopModelContext();
    W_[43] = 300000.0-W_[53];
    W_[76] = 300000.0+W_[85];
    W_[142] =  -W_[85]*W_[147];
    helpvar[95] = W_[144]-1E-005;
    helpvar[96] = (PushModelContext(1,"IDEAS.Utilities.Math.Functions.spliceFunction(fan.eta, 1E-005, fan.eta-1E-005, 1E-006)")
      IDEAS_Utilities_Math_Functions_spliceFunction(W_[144], 1E-005, helpvar[95],
       1E-006));
    PopModelContext();
    helpvar[97] = divmacro(1.0,"1.0",helpvar[96],"IDEAS.Utilities.Math.Functions.spliceFunction(fan.eta, 1E-005, fan.eta-1E-005, 1E-006)");
    W_[140] = helpvar[97]*W_[142];
    W_[159] = (IF W_[154] THEN W_[140] ELSE W_[141])-W_[142];
    helpvar[98] = fabs(W_[147])-2*W_[156];
    W_[143] = homotopy((PushModelContext(1,"IDEAS.Utilities.Math.Functions.spliceFunction(fan.QThe_flow, 0, noEvent(abs(fan.VMachine_flow))-2*fan.delta_V_flow, fan.delta_V_flow)")
      IDEAS_Utilities_Math_Functions_spliceFunction(W_[159], 0, helpvar[98], 
      W_[156])), 0);
    PopModelContext();
    W_[133] = W_[143]+W_[142];
    helpvar[99] = DP_[24]*(W_[117]-DP_[23]);
    helpvar[100] = 1+helpvar[99];
    W_[102] = W_[133]*helpvar[100];
    W_[337] = W_[339]*W_[328]+W_[338]*W_[329];
    helpvar[101] = W_[42] >= 0;
    W_[305] = IF helpvar[101] THEN W_[77]*W_[42] ELSE W_[40]*W_[42];
    W_[301] = W_[305]+W_[306];
    W_[298] = W_[300]*W_[289]+W_[299]*W_[290];
  SetVector(residue__, 1, W_[145]*W_[141]-W_[142]);
  SetVector(residue__, 2, W_[76]-W_[43]+W_[206]);
  SetVector(residue__, 3, W_[298]-W_[301]+W_[0]);
  SetVector(residue__, 4, W_[102]-W_[337]+W_[344]+W_[345]);

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  helpvar[102] = (PushModelContext(1,"IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency:derf(\nfan.per.hydraulicEfficiency, \nfan.VMachine_flow, \nfan.hydDer, \n1, \n0.0001, \nIDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters(\nV_flow = {0.0}, \neta = {0.0}\n), \n1.0, \n{0.0}, \n0, \n0.0)")
    IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency__derf(
    DymStruc0_construct(RealTemporaryDense( &DP_[26], 1, 1), RealTemporaryDense( 
    &DP_[27], 1, 1)), W_[147], RealTemporaryDense( &W_[158], 1, 1), 1, 0.0001, 
    DymStruc0_construct(RealTemporaryDense( DymArrays0, 1, 1), RealTemporaryDense( 
    DymArrays0, 1, 1)), 1.0, RealTemporaryDense( DymArrays0, 1, 1), 0, 0.0));
  PopAllMarks();
  helpvar[103] = IF helpvar[66] THEN -0.042860825 ELSE IF X_[4] < 373.15 THEN 
    6.5619527954075+4.5027E-005*sqr(X_[4])-0.0362697701*X_[4] ELSE -0.7025109;
  helpvar[104] = homotopy(0.0, 0.0);
  helpvar[105] = 1.0+helpvar[104];
  helpvar[106] = helpvar[104]*helpvar[105];
  helpvar[107] = helpvar[106]+helpvar[104];
  helpvar[108] = 300000.0*helpvar[107];
  helpvar[109] = IF helpvar[68] > 0.0 THEN -1.0 ELSE 0.0;
  helpvar[110] = IF helpvar[70] THEN 0.0 ELSE IF Aux_[16] > 0.0 THEN 2E+020*(3.0
    -20000000000.0*Aux_[16])*Aux_[16]-20000000000.0*sqr(10000000000.0*Aux_[16])
     ELSE 0.0;
  helpvar[111] = helpvar[69]-1E-010;
  helpvar[112] = 83680.0*helpvar[111];
  helpvar[113] = W_[77]*(helpvar[67]-1E-010)+helpvar[112];
  helpvar[114] = helpvar[75]*(helpvar[67]+helpvar[111]-1E-010);
  helpvar[115] = sqr(helpvar[76]);
  helpvar[116] = divmacro(1.0,"1.0",helpvar[115],"(stream_alpha1*max( -fan.port_b.m_flow, 0.0)+1E-010*(1.0-stream_alpha1)+stream_alpha1*max( -boundary.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha1))^2");
  helpvar[117] = helpvar[77]*helpvar[113]-helpvar[116]*helpvar[114];
  helpvar[118] = IF helpvar[78] THEN W_[38] ELSE 0.0;
  helpvar[119] = helpvar[118]*helpvar[107];
  helpvar[120] = helpvar[119]+helpvar[106]+helpvar[104];
  helpvar[121] = helpvar[110]*(helpvar[117]*helpvar[120]+helpvar[106]+helpvar[104]);
  helpvar[122] = Aux_[17]*helpvar[109];
  helpvar[123] = 83680.0*helpvar[122];
  helpvar[124] = helpvar[75]*helpvar[122];
  helpvar[125] = helpvar[77]*helpvar[123]-helpvar[116]*helpvar[124];
  helpvar[126] = IF helpvar[83] THEN 0.0 ELSE IF Aux_[18] > 0.0 THEN 2E+020*(3.0
    -20000000000.0*Aux_[18])*Aux_[18]-20000000000.0*sqr(10000000000.0*Aux_[18])
     ELSE 0.0;
  helpvar[127] = W_[40]*(helpvar[82]-1E-010);
  helpvar[128] = helpvar[82]+helpvar[111]-1E-010;
  helpvar[129] = sqr(helpvar[89]);
  helpvar[130] = divmacro(1.0,"1.0",helpvar[129],"(stream_alpha3*max( -pipe.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha3)+stream_alpha3*max( -boundary.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha3))^2");
  helpvar[131] = helpvar[90]*(helpvar[127]+helpvar[112])-helpvar[130]*helpvar[88]
    *helpvar[128];
  helpvar[132] = IF helpvar[91] THEN W_[79] ELSE 0.0;
  helpvar[133] = helpvar[132]*helpvar[107]+helpvar[106]+helpvar[104];
  helpvar[134] = helpvar[131]*helpvar[133]+helpvar[106]+helpvar[104];
  helpvar[135] = helpvar[126]*helpvar[134]+helpvar[106]+helpvar[104];
  helpvar[136] = Aux_[19]*helpvar[109];
  helpvar[137] = helpvar[90]*83680.0*helpvar[136]-helpvar[130]*helpvar[88]*
    helpvar[136];
  helpvar[138] = helpvar[109]*(helpvar[121]+helpvar[106]+helpvar[104])+helpvar[125]
    *helpvar[120]+helpvar[109]*helpvar[135]+helpvar[137]*helpvar[133];
  helpvar[139] = IF helpvar[78] THEN W_[49] ELSE W_[40];
  helpvar[140] = IF helpvar[81] > 0.0 THEN -1.0 ELSE 0.0;
  helpvar[141] = Aux_[19]*helpvar[140];
  helpvar[142] = helpvar[90]*W_[40]*helpvar[141]-helpvar[130]*helpvar[88]*
    helpvar[141];
  helpvar[143] = helpvar[138]+helpvar[106]+helpvar[104]-helpvar[139]*helpvar[107]
    -helpvar[140]*helpvar[135]-helpvar[142]*helpvar[133]-helpvar[106];
  helpvar[144] = helpvar[143]-homotopy((PushModelContext(1,"IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(pipe.port_a.m_flow, 0.5059644256269408, 0.0048, 1.0)")
    IF W_[38] > 0.0048 THEN 7.812499999999998*W_[38] ELSE IF W_[38] < -0.0048
     THEN (-7.812499999999998)*W_[38] ELSE 0.009374999999999996+1220.7031249999998
    *sqr(W_[38])), 0.0625);
  PopModelContext();
  helpvar[145] = helpvar[65]*helpvar[108]-0.001*(helpvar[144]-helpvar[106]-
    helpvar[104])+helpvar[106];
  helpvar[146] = IF helpvar[63] THEN -0.042860825 ELSE IF X_[3] < 373.15 THEN 
    6.5619527954075+4.5027E-005*sqr(X_[3])-0.0362697701*X_[3] ELSE -0.7025109;
  helpvar[147] = helpvar[107]+helpvar[106];
  helpvar[148] = 4184.0*(helpvar[147]+helpvar[104]);
  helpvar[149] = IF helpvar[93] THEN  -W_[186] ELSE  -W_[77];
  helpvar[150] = (PushModelContext(1,"IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency:derf(\nfan.per.motorEfficiency, \nfan.VMachine_flow, \nfan.motDer, \n1, \n0.0001, \nIDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters(\nV_flow = {0.0}, \neta = {0.0}\n), \n1.0, \n{0.0}, \n0, \n0.0)")
    IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency__derf(
    DymStruc0_construct(RealTemporaryDense( &DP_[28], 1, 1), RealTemporaryDense( 
    &DP_[29], 1, 1)), W_[147], RealTemporaryDense( &W_[157], 1, 1), 1, 0.0001, 
    DymStruc0_construct(RealTemporaryDense( DymArrays0, 1, 1), RealTemporaryDense( 
    DymArrays0, 1, 1)), 1.0, RealTemporaryDense( DymArrays0, 1, 1), 0, 0.0));
  PopAllMarks();
  helpvar[151] = helpvar[150]*(W_[145]*helpvar[107]+helpvar[106]+helpvar[104]);
  helpvar[152] = helpvar[102]*(W_[146]*helpvar[107]+helpvar[106]+helpvar[104]);
  helpvar[153] = homotopy((PushModelContext(1,"IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der( -pipe.port_b.m_flow, 0.5059644256269408, 0.0016, -1.0)")
    (-1.0)*(IF helpvar[92] > 0.0016 THEN (-7.812499999999998)*W_[42] ELSE IF 
    helpvar[92] < -0.0016 THEN 7.812499999999998*W_[42] ELSE 0.0031249999999999993
    +3662.109374999999*sqr(W_[42]))), -0.0625);
  PopModelContext();
  helpvar[154] = helpvar[144]+helpvar[149]*helpvar[107]-helpvar[94]*(helpvar[151]
    +helpvar[152]+helpvar[106]+helpvar[104])+helpvar[153]*helpvar[105];
  helpvar[155] = helpvar[80]*helpvar[108]-1.6028961287543954E-005*(helpvar[154]+
    helpvar[104]-helpvar[106]-helpvar[104])+helpvar[106];
  helpvar[156] = helpvar[117]*helpvar[118];
  helpvar[157] = (-1.0)*((-1.0)*helpvar[109]*helpvar[110]*helpvar[156]-helpvar[125]
    *helpvar[118])-helpvar[139];
  helpvar[158] = helpvar[104]*helpvar[100];
  helpvar[159] = helpvar[104]*helpvar[158];
  helpvar[160] = helpvar[159]+helpvar[158];
  helpvar[161] = helpvar[118]*helpvar[160];
  helpvar[162] = helpvar[161]+helpvar[159]+helpvar[158];
  helpvar[163] = helpvar[110]*(helpvar[117]*helpvar[162]+helpvar[159]+helpvar[158]);
  helpvar[164] = 1.0+helpvar[160];
  helpvar[165] = helpvar[132]*helpvar[164]+helpvar[159]+helpvar[158];
  helpvar[166] = helpvar[131]*helpvar[165]+helpvar[159]+helpvar[158];
  helpvar[167] = helpvar[126]*helpvar[166]+helpvar[159]+helpvar[158];
  helpvar[168] = helpvar[109]*(helpvar[163]+helpvar[159]+helpvar[158])+helpvar[125]
    *helpvar[162]+helpvar[109]*helpvar[167]+helpvar[137]*helpvar[165];
  helpvar[169] = helpvar[168]+helpvar[159]+helpvar[158]-helpvar[139]*helpvar[160]
    -helpvar[140]*helpvar[167]-helpvar[142]*helpvar[165]-helpvar[159];
  helpvar[170] = helpvar[169]-helpvar[158];
  helpvar[171] = helpvar[65]*300000.0*helpvar[160]-0.001*(helpvar[170]-helpvar[159]
    -helpvar[158])+helpvar[159];
  helpvar[172] = helpvar[160]+helpvar[159];
  helpvar[173] = homotopy((PushModelContext(1,"IDEAS.Utilities.Math.Functions.BaseClasses.der_spliceFunction(fan.QThe_flow, 0, noEvent(abs(fan.VMachine_flow))-2*fan.delta_V_flow, fan.delta_V_flow, 1.0, 0, 0.0, 0.0)")
    IDEAS_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(W_[159], 0, 
    helpvar[98], W_[156], 1.0, 0, 0.0, 0.0)), 0.0)*helpvar[100];
  PopModelContext();
  helpvar[174] = (IF W_[154] THEN 1.0 ELSE 0.0)*helpvar[173];
  helpvar[175] = helpvar[174]+helpvar[158];
  helpvar[176] = sqr(helpvar[96]);
  helpvar[177] = divmacro(1.0,"1.0",helpvar[176],"IDEAS.Utilities.Math.Functions.spliceFunction(fan.eta, 1E-005, fan.eta-1E-005, 1E-006)^2");
  helpvar[178] = helpvar[159]-helpvar[177]*W_[142]*(PushModelContext(1,
    "IDEAS.Utilities.Math.Functions.BaseClasses.der_spliceFunction(fan.eta, 1E-005, fan.eta-1E-005, 1E-006, 1.0, 0.0, 1.0, 0.0)")
    IDEAS_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(W_[144], 
    1E-005, helpvar[95], 1E-006, 1.0, 0.0, 1.0, 0.0))*helpvar[175]+helpvar[158];
  PopModelContext();
  helpvar[179] = W_[145]*helpvar[178];
  helpvar[180] = W_[146]*helpvar[178];
  helpvar[181] = helpvar[97]*helpvar[175];
  helpvar[182] = 1.0+helpvar[181]-helpvar[173]+helpvar[158]+helpvar[99];
  helpvar[183] = helpvar[150]*(helpvar[179]+helpvar[159]+helpvar[158])+helpvar[102]
    *(helpvar[180]+helpvar[159]+helpvar[158])+helpvar[159]-W_[85]*helpvar[182];
  helpvar[184] = homotopy((PushModelContext(1,"IDEAS.Utilities.Math.Functions.BaseClasses.der_spliceFunction(fan.QThe_flow, 0, noEvent(abs(fan.VMachine_flow))-2*fan.delta_V_flow, fan.delta_V_flow, 0.0, 0, noEvent((if fan.VMachine_flow > 0 then 1 else -1)), 0.0)")
    IDEAS_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(W_[159], 0, 
    helpvar[98], W_[156], 0.0, 0, IF W_[147] > 0 THEN 1 ELSE -1, 0.0)), 0.0)*
    helpvar[100];
  PopModelContext();
  helpvar[185] = helpvar[170]+helpvar[149]*helpvar[164]-helpvar[94]*(helpvar[183]
    +helpvar[184])+helpvar[153]*helpvar[158]+helpvar[158]-helpvar[159];
  helpvar[186] = helpvar[160]-W_[338];
  helpvar[187] = 1.6028961287543954E-005*((-1.0)*(helpvar[185]-helpvar[158])-
    W_[328])+helpvar[80]*300000.0*helpvar[186]+helpvar[159];
  helpvar[188] = helpvar[186]+helpvar[159];
  SetMatrixLeading(Jacobian__, 1, 2, 4,  -helpvar[94]*(-1.6028961287543954E-005)
    *(helpvar[102]*W_[141]+W_[85])*helpvar[103]);
  SetMatrixLeading(Jacobian__, 1, 3, 4, W_[145]);
  SetMatrixLeading(Jacobian__, 1, 4, 4, W_[147]);
  SetMatrixLeading(Jacobian__, 2, 1, 4, (helpvar[145]+helpvar[104])*helpvar[146]
    +helpvar[148]+helpvar[106]+helpvar[104]);
  SetMatrixLeading(Jacobian__, 2, 2, 4, (helpvar[155]+helpvar[104])*helpvar[103]
    +helpvar[148]+helpvar[106]+helpvar[104]);
  SetMatrixLeading(Jacobian__, 2, 3, 4, helpvar[107]);
  SetMatrixLeading(Jacobian__, 2, 4, 4, 1.0+helpvar[107]);
  SetMatrixLeading(Jacobian__, 3, 1, 4, (helpvar[65]*300000.0*W_[299]+0.001*(
    helpvar[157]+W_[289]))*helpvar[146]+4184.0*W_[299]);
  SetMatrixLeading(Jacobian__, 3, 2, 4, (-1.6028961287543954E-005)*((-1.0)*
    helpvar[157]-(IF helpvar[101] THEN W_[77] ELSE W_[40]))*helpvar[103]);
  SetMatrixLeading(Jacobian__, 4, 1, 4, (helpvar[171]+helpvar[158])*helpvar[146]
    +4184.0*(helpvar[172]+helpvar[158])+helpvar[159]+helpvar[158]);
  SetMatrixLeading(Jacobian__, 4, 2, 4, (helpvar[187]+helpvar[158])*helpvar[103]
    +4184.0*(helpvar[188]+helpvar[158])+helpvar[159]+helpvar[158]);
  SetMatrixLeading(Jacobian__, 4, 3, 4, helpvar[159]+helpvar[173]*(IF W_[154]
     THEN 0.0 ELSE 1.0)+helpvar[158]);
  SetMatrixLeading(Jacobian__, 4, 4, 4, helpvar[160]-helpvar[182]*W_[147]+
    helpvar[158]);

  SolveNonLinearSystemOfEquationsInit(Jacobian__, residue__, x__);
  F_[3] = GetVector(x__, 1);
  F_[4] = GetVector(x__, 2);
  W_[141] = GetVector(x__, 3);
  W_[85] = GetVector(x__, 4);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 2);
   /* End of Non-Linear Equation Block */ }



}
AssertModelica(GreaterEqual(W_[43],"pipe.port_b.p", 0.0,"0.0", 2),
  "pipe.port_b.p >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("Pressure (= ",Real2String2(W_[43], true, 0))," Pa) of medium \""),
  "WaterDetailed"),"\" is negative\n(Temperature = "),Real2String2(X_[3], true, 0)),
  " K)"));
PopAllMarks();
AssertModelica(GreaterEqual(W_[76],"fan.port_a.p", 0.0,"0.0", 3),
  "fan.port_a.p >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("Pressure (= ",Real2String2(W_[76], true, 0))," Pa) of medium \""),
  "WaterDetailed"),"\" is negative\n(Temperature = "),Real2String2(X_[4], true, 0)),
  " K)"));
PopAllMarks();
BreakSectionFunctionEnd()
BreakSectionFunctionStart(4);
InitialSection
InitialSection
Init=false;InitializeData(2);Init=true;
EndInitialSection

OutputSection
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"WaterDetailed\", {\"WaterDetailed\"}, true, true, boundary.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("WaterDetailed", StringTemporaryDense( 
  DymArrays1, 1, 1), true, true, RealTemporaryDense( &W_[274], 1, 1), 
  "Boundary_pT"));
PopAllMarks();

DynamicsSection
F_[1] = W_[182]*(X_[1]-1.0);
F_[2] = W_[183]*(X_[2]-X_[1]);
W_[79] = (-0.016)*DP_[38]*X_[2];
W_[77] = 4184*(X_[4]-273.15);
W_[325] = IF X_[4] < 278.15 THEN 1011.9695761-0.042860825*X_[4] ELSE IF X_[4] < 
  373.15 THEN 254.900074971947+1.5009E-005*powmacro(X_[4],"fan.vol.dynBal.medium.T",3,
  "3")-0.01813488505*sqr(X_[4])+6.5619527954075*X_[4] ELSE 1220.35045233-
  0.7025109*X_[4];
W_[328] = W_[77]-divmacro(300000,"300000",W_[325],"fan.vol.dynBal.medium.d");
W_[338] = 1.6028961287543954E-005*W_[325];
W_[200] = DP_[60]+(IF LessTime(DP_[61], 0) THEN 0 ELSE DP_[59]);
W_[186] = 4184*(W_[200]-273.15);
W_[40] = 4184*(X_[3]-273.15);
W_[117] = 273.15+0.0002390057361376673*W_[77];
W_[119] = IF 273.15+0.0002390057361376673*W_[186] < 278.15 THEN 1000.26214175125
  -1.0243983030592733E-005*W_[186] ELSE IF 273.15+0.0002390057361376673*W_[186]
   < 373.15 THEN 2047.2974810375053+1.5009E-005*powmacro(273.15+0.0002390057361376673
  *W_[186],"273.15+0.0002390057361376673*hea.port_b.h_outflow",3,"3")-
  0.01813488505*sqr(273.15+0.0002390057361376673*W_[186])+0.0015683443583669931*
  W_[186] ELSE 1028.459599995-0.0001679041347992352*W_[186];
W_[286] = IF X_[3] < 278.15 THEN 1011.9695761-0.042860825*X_[3] ELSE IF X_[3] < 
  373.15 THEN 254.900074971947+1.5009E-005*powmacro(X_[3],"pipe.vol.dynBal.medium.T",3,
  "3")-0.01813488505*sqr(X_[3])+6.5619527954075*X_[3] ELSE 1220.35045233-
  0.7025109*X_[3];
W_[289] = W_[40]-divmacro(300000,"300000",W_[286],"pipe.vol.dynBal.medium.d");
W_[299] = 0.001*W_[286];
W_[2] = 273.15+0.0002390057361376673*W_[40];
W_[1] = W_[2]-X_[0];
 /* Linear system of equations to solve. */
W_[0] = RememberSimple_(W_[0], 0);
SolveScalarLinearParametric( -DP_[0]," -pipe.Rfg.R",  -W_[1]," -pipe.Rfg.dT", 
  W_[0],"pipe.Rfg.Q_flow");
 /* End of Equation Block */ 

BreakSectionFunctionEnd()
BreakSectionFunctionStart(5);
{ /* Non-linear system of equations to solve. */
  /* Nonlinear system of equations number = 3. */
/* Introducing 186 common subexpressions and reusing 4 variables totally
   used in 112 expressions */
/* Of the common subexpressions 178 are reals, 1 are integers, and 11
   are booleans. */
const char*const varnames_[]={"fan.vol.dynBal.medium.der(T)", "fan.WHyd", 
  "fan.port_a.p", "pipe.vol.dynBal.medium.der(T)"};
const double nominal_[]={1, 1, 100000.0, 1};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 4, 0, 3, 11, 15);
NonLinearSystemSave(W_[117], 0);
NonLinearSystemSave(W_[77], 1);
NonLinearSystemSave(W_[79], 2);
NonLinearSystemSave(W_[119], 3);
NonLinearSystemSave(W_[338], 4);
NonLinearSystemSave(X_[4], 5);
NonLinearSystemSave(W_[325], 6);
NonLinearSystemSave(W_[328], 7);
NonLinearSystemSave(W_[186], 8);
NonLinearSystemSave(W_[0], 9);
NonLinearSystemSave(W_[40], 10);
NonLinearSystemSave(W_[299], 11);
NonLinearSystemSave(X_[3], 12);
NonLinearSystemSave(W_[286], 13);
NonLinearSystemSave(W_[289], 14);
SetInitVectorNH(x__, 1, F_[4], Remember_(F_[4], 1));
SetInitVectorNH(x__, 2, W_[141], Remember_(W_[141], 2));
SetInitVectorNH(x__, 3, W_[76], Remember_(W_[76], 3));
SetInitVectorNH(x__, 4, F_[3], Remember_(F_[3], 4));
Residues;
  helpvar[189] = X_[3] < 278.15;
  W_[287] = IF helpvar[189] THEN (-0.042860825)*F_[3] ELSE IF X_[3] < 373.15
     THEN 4.5027E-005*sqr(X_[3])*F_[3]-0.0362697701*X_[3]*F_[3]+6.5619527954075*
    F_[3] ELSE (-0.7025109)*F_[3];
  W_[300] = 0.001*W_[287];
  helpvar[190] = X_[4] < 278.15;
  W_[326] = IF helpvar[190] THEN (-0.042860825)*F_[4] ELSE IF X_[4] < 373.15
     THEN 4.5027E-005*sqr(X_[4])*F_[4]-0.0362697701*X_[4]*F_[4]+6.5619527954075*
    F_[4] ELSE (-0.7025109)*F_[4];
  W_[339] = 1.6028961287543954E-005*W_[326];
  W_[42] = W_[79]-W_[339];
  W_[38] = W_[300]-W_[42];
  W_[261] =  -(W_[79]+W_[38]);
  helpvar[191] = RealBmax( -W_[79], 0.0);
  helpvar[192] =  -W_[261];
  helpvar[193] = RealBmax(helpvar[192], 0.0);
  Aux_[16] = helpvar[191]+helpvar[193];
  helpvar[194] = Aux_[16] > 1E-010;
  Aux_[17] = IF helpvar[194] THEN 1.0 ELSE IF Aux_[16] > 0.0 THEN sqr(
    10000000000.0*Aux_[16])*(3.0-20000000000.0*Aux_[16]) ELSE 0.0;
  helpvar[195] = 1.0-Aux_[17];
  helpvar[196] = 1E-010*helpvar[195];
  helpvar[197] = Aux_[17]*helpvar[191]+helpvar[196];
  helpvar[198] = Aux_[17]*helpvar[193]+helpvar[196];
  helpvar[199] = helpvar[197]*W_[77]+83680.0*helpvar[198];
  helpvar[200] = helpvar[197]+helpvar[198];
  helpvar[201] = divmacro(1.0,"1.0",helpvar[200],"stream_alpha1*max( -fan.port_b.m_flow, 0.0)+1E-010*(1.0-stream_alpha1)+stream_alpha1*max( -boundary.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha1)");
  W_[49] = helpvar[201]*helpvar[199];
  helpvar[202] =  -W_[38];
  helpvar[203] = RealBmax(helpvar[202], 0.0);
  Aux_[18] = helpvar[203]+helpvar[193];
  helpvar[204] = Aux_[18] > 1E-010;
  Aux_[19] = IF helpvar[204] THEN 1.0 ELSE IF Aux_[18] > 0.0 THEN sqr(
    10000000000.0*Aux_[18])*(3.0-20000000000.0*Aux_[18]) ELSE 0.0;
  helpvar[205] =  -W_[42];
  helpvar[206] = helpvar[205] >= 0;
  W_[344] = IF helpvar[206] THEN  -W_[186]*W_[42] ELSE  -W_[77]*W_[42];
  W_[78] = 4184*F_[4];
  helpvar[207] = sqr(W_[325]);
  helpvar[208] = divmacro(1.0,"1.0",helpvar[207],"fan.vol.dynBal.medium.d^2");
  W_[329] = W_[78]+helpvar[208]*300000*W_[326];
  W_[337] = W_[339]*W_[328]+W_[338]*W_[329];
  helpvar[209] = divmacro(1.0,"1.0",W_[119],"fan.rho_in");
  W_[147] =  -helpvar[209]*W_[42];
  W_[146] = (PushModelContext(1,"IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency(\nfan.per.motorEfficiency, \nfan.VMachine_flow, \nfan.motDer, \n1, \n0.0001)")
    IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc0_construct(
    RealTemporaryDense( &DP_[28], 1, 1), RealTemporaryDense( &DP_[29], 1, 1)), 
    W_[147], RealTemporaryDense( &W_[157], 1, 1), 1, 0.0001));
  PopAllMarks();
  W_[145] = (PushModelContext(1,"IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency(\nfan.per.hydraulicEfficiency, \nfan.VMachine_flow, \nfan.hydDer, \n1, \n0.0001)")
    IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc0_construct(
    RealTemporaryDense( &DP_[26], 1, 1), RealTemporaryDense( &DP_[27], 1, 1)), 
    W_[147], RealTemporaryDense( &W_[158], 1, 1), 1, 0.0001));
  PopAllMarks();
  W_[144] = W_[145]*W_[146];
  W_[85] = W_[76]-300000.0;
  W_[142] =  -W_[85]*W_[147];
  helpvar[210] = W_[144]-1E-005;
  helpvar[211] = (PushModelContext(1,"IDEAS.Utilities.Math.Functions.spliceFunction(fan.eta, 1E-005, fan.eta-1E-005, 1E-006)")
    IDEAS_Utilities_Math_Functions_spliceFunction(W_[144], 1E-005, helpvar[210],
     1E-006));
  PopModelContext();
  helpvar[212] = divmacro(1.0,"1.0",helpvar[211],"IDEAS.Utilities.Math.Functions.spliceFunction(fan.eta, 1E-005, fan.eta-1E-005, 1E-006)");
  W_[140] = helpvar[212]*W_[142];
  W_[206] = (PushModelContext(1,"IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow( -pipe.port_b.m_flow, 0.5059644256269408, 0.0016)")
    IF helpvar[205] > 0.0016 THEN sqr((-1.9764235376052368)*W_[42]) ELSE IF 
    helpvar[205] < -0.0016 THEN  -sqr((-1.9764235376052368)*W_[42]) ELSE 
    1.9531249999999996*(625.0*powmacro(helpvar[205]," -pipe.port_b.m_flow",3,"3")
    -0.0016*W_[42]));
  PopModelContext();
  W_[43] = W_[206]+W_[76];
  W_[53] = 300000.0-W_[43];
  W_[159] = (IF W_[154] THEN W_[140] ELSE W_[141])-W_[142];
  helpvar[213] = fabs(W_[147]);
  helpvar[214] = helpvar[213]-2*W_[156];
  W_[143] = (PushModelContext(1,"IDEAS.Utilities.Math.Functions.spliceFunction(fan.QThe_flow, 0, noEvent(abs(fan.VMachine_flow))-2*fan.delta_V_flow, fan.delta_V_flow)")
    IDEAS_Utilities_Math_Functions_spliceFunction(W_[159], 0, helpvar[214], 
    W_[156]));
  PopModelContext();
  W_[133] = W_[143]+W_[142];
  helpvar[215] = DP_[24]*(W_[117]-DP_[23]);
  helpvar[216] = 1+helpvar[215];
  W_[102] = W_[133]*helpvar[216];
  helpvar[217] = 1.0-Aux_[19];
  helpvar[218] = 1E-010*helpvar[217];
  helpvar[219] = Aux_[19]*helpvar[203]+helpvar[218];
  helpvar[220] = Aux_[19]*helpvar[193]+helpvar[218];
  helpvar[221] = helpvar[219]*W_[40]+83680.0*helpvar[220];
  helpvar[222] = helpvar[219]+helpvar[220];
  helpvar[223] = divmacro(1.0,"1.0",helpvar[222],"stream_alpha3*max( -pipe.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha3)+stream_alpha3*max( -boundary.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha3)");
  W_[121] = helpvar[223]*helpvar[221];
  helpvar[224] = W_[79] >= 0;
  W_[345] = IF helpvar[224] THEN W_[121]*W_[79] ELSE W_[77]*W_[79];
  helpvar[225] = W_[38] >= 0;
  W_[306] = IF helpvar[225] THEN W_[49]*W_[38] ELSE W_[40]*W_[38];
  W_[41] = 4184*F_[3];
  helpvar[226] = sqr(W_[286]);
  helpvar[227] = divmacro(1.0,"1.0",helpvar[226],"pipe.vol.dynBal.medium.d^2");
  W_[290] = W_[41]+helpvar[227]*300000*W_[287];
  W_[298] = W_[300]*W_[289]+W_[299]*W_[290];
  helpvar[228] = W_[42] >= 0;
  W_[305] = IF helpvar[228] THEN W_[77]*W_[42] ELSE W_[40]*W_[42];
  W_[301] = W_[305]+W_[306];
helpvar[229] = (PushModelContext(1,"IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(pipe.port_a.m_flow, 0.5059644256269408, 0.0048)")
  IF W_[38] > 0.0048 THEN sqr(1.9764235376052368*W_[38]) ELSE IF W_[38] < 
  -0.0048 THEN  -sqr(1.9764235376052368*W_[38]) ELSE 1.9531249999999996*(0.0048*
  W_[38]+208.33333333333334*powmacro(W_[38],"pipe.port_a.m_flow",3,"3")));
PopModelContext();
SetVector(residue__, 1, W_[53]-helpvar[229]);
SetVector(residue__, 2, W_[145]*W_[141]-W_[142]);
SetVector(residue__, 3, W_[298]-W_[301]+W_[0]);
SetVector(residue__, 4, W_[102]-W_[337]+W_[344]+W_[345]);

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
helpvar[230] = (PushModelContext(1,"IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(pipe.port_a.m_flow, 0.5059644256269408, 0.0048, 1.0)")
  IF W_[38] > 0.0048 THEN 7.812499999999998*W_[38] ELSE IF W_[38] < -0.0048
   THEN (-7.812499999999998)*W_[38] ELSE 0.009374999999999996+1220.7031249999998
  *sqr(W_[38]));
PopModelContext();
helpvar[231] = IF helpvar[190] THEN -0.042860825 ELSE IF X_[4] < 373.15 THEN 
  6.5619527954075+4.5027E-005*sqr(X_[4])-0.0362697701*X_[4] ELSE -0.7025109;
helpvar[232] = IF helpvar[189] THEN -0.042860825 ELSE IF X_[3] < 373.15 THEN 
  6.5619527954075+4.5027E-005*sqr(X_[3])-0.0362697701*X_[3] ELSE -0.7025109;
helpvar[233] = (PushModelContext(1,"IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency:derf(\nfan.per.hydraulicEfficiency, \nfan.VMachine_flow, \nfan.hydDer, \n1, \n0.0001, \nIDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters(\nV_flow = {0.0}, \neta = {0.0}\n), \n1.0, \n{0.0}, \n0, \n0.0)")
  IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency__derf(
  DymStruc0_construct(RealTemporaryDense( &DP_[26], 1, 1), RealTemporaryDense( 
  &DP_[27], 1, 1)), W_[147], RealTemporaryDense( &W_[158], 1, 1), 1, 0.0001, 
  DymStruc0_construct(RealTemporaryDense( DymArrays0, 1, 1), RealTemporaryDense( 
  DymArrays0, 1, 1)), 1.0, RealTemporaryDense( DymArrays0, 1, 1), 0, 0.0));
PopAllMarks();
helpvar[234] = IF helpvar[192] > 0.0 THEN -1.0 ELSE 0.0;
helpvar[235] = helpvar[193]-1E-010;
helpvar[236] = 83680.0*helpvar[235];
helpvar[237] = sqr(helpvar[200]);
helpvar[238] = divmacro(1.0,"1.0",helpvar[237],"(stream_alpha1*max( -fan.port_b.m_flow, 0.0)+1E-010*(1.0-stream_alpha1)+stream_alpha1*max( -boundary.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha1))^2");
helpvar[239] = helpvar[201]*(W_[77]*(helpvar[191]-1E-010)+helpvar[236])-helpvar[238]
  *helpvar[199]*(helpvar[191]+helpvar[235]-1E-010);
helpvar[240] = IF helpvar[225] THEN W_[38] ELSE 0.0;
helpvar[241] = Aux_[17]*helpvar[234];
helpvar[242] = (-1.0)*((-1.0)*helpvar[234]*(IF helpvar[194] THEN 0.0 ELSE IF 
  Aux_[16] > 0.0 THEN 2E+020*(3.0-20000000000.0*Aux_[16])*Aux_[16]-20000000000.0
  *sqr(10000000000.0*Aux_[16]) ELSE 0.0)*helpvar[239]*helpvar[240]-(helpvar[201]
  *83680.0*helpvar[241]-helpvar[238]*helpvar[199]*helpvar[241])*helpvar[240]);
helpvar[243] = helpvar[242]-(IF helpvar[225] THEN W_[49] ELSE W_[40]);
helpvar[244] = W_[40]*(helpvar[203]-1E-010);
helpvar[245] = helpvar[203]+helpvar[235]-1E-010;
helpvar[246] = sqr(helpvar[222]);
helpvar[247] = divmacro(1.0,"1.0",helpvar[246],"(stream_alpha3*max( -pipe.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha3)+stream_alpha3*max( -boundary.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha3))^2");
helpvar[248] = IF helpvar[224] THEN W_[79] ELSE 0.0;
helpvar[249] = (IF helpvar[204] THEN 0.0 ELSE IF Aux_[18] > 0.0 THEN 2E+020*(3.0
  -20000000000.0*Aux_[18])*Aux_[18]-20000000000.0*sqr(10000000000.0*Aux_[18])
   ELSE 0.0)*(helpvar[223]*(helpvar[244]+helpvar[236])-helpvar[247]*helpvar[221]
  *helpvar[245])*helpvar[248];
helpvar[250] = helpvar[234]*helpvar[249];
helpvar[251] = Aux_[19]*helpvar[234];
helpvar[252] = (helpvar[223]*83680.0*helpvar[251]-helpvar[247]*helpvar[221]*
  helpvar[251])*helpvar[248];
helpvar[253] = helpvar[202] > 0.0;
helpvar[254] = IF helpvar[253] THEN -1.0 ELSE 0.0;
helpvar[255] = Aux_[19]*helpvar[254];
helpvar[256] = helpvar[223]*W_[40]*helpvar[255];
helpvar[257] = helpvar[247]*helpvar[221]*helpvar[255];
helpvar[258] = helpvar[250]+helpvar[252]-helpvar[254]*helpvar[249]-(helpvar[256]
  -helpvar[257])*helpvar[248];
helpvar[259] = (PushModelContext(1,"IDEAS.Utilities.Math.Functions.BaseClasses.der_spliceFunction(fan.QThe_flow, 0, noEvent(abs(fan.VMachine_flow))-2*fan.delta_V_flow, fan.delta_V_flow, 1.0, 0, 0.0, 0.0)")
  IDEAS_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(W_[159], 0, 
  helpvar[214], W_[156], 1.0, 0, 0.0, 0.0))*helpvar[216];
PopModelContext();
helpvar[260] = (IF W_[154] THEN 1.0 ELSE 0.0)*helpvar[259];
helpvar[261] = W_[142]*(PushModelContext(1,"IDEAS.Utilities.Math.Functions.BaseClasses.der_spliceFunction(fan.eta, 1E-005, fan.eta-1E-005, 1E-006, 1.0, 0.0, 1.0, 0.0)")
  IDEAS_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(W_[144], 
  1E-005, helpvar[210], 1E-006, 1.0, 0.0, 1.0, 0.0))*helpvar[260];
PopModelContext();
helpvar[262] = (PushModelContext(1,"IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency:derf(\nfan.per.motorEfficiency, \nfan.VMachine_flow, \nfan.motDer, \n1, \n0.0001, \nIDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters(\nV_flow = {0.0}, \neta = {0.0}\n), \n1.0, \n{0.0}, \n0, \n0.0)")
  IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency__derf(
  DymStruc0_construct(RealTemporaryDense( &DP_[28], 1, 1), RealTemporaryDense( 
  &DP_[29], 1, 1)), W_[147], RealTemporaryDense( &W_[157], 1, 1), 1, 0.0001, 
  DymStruc0_construct(RealTemporaryDense( DymArrays0, 1, 1), RealTemporaryDense( 
  DymArrays0, 1, 1)), 1.0, RealTemporaryDense( DymArrays0, 1, 1), 0, 0.0))*
  W_[145]*helpvar[261]+helpvar[233]*W_[146]*helpvar[261];
PopAllMarks();
helpvar[263] = sqr(helpvar[211]);
helpvar[264] = divmacro(1.0,"1.0",helpvar[263],"IDEAS.Utilities.Math.Functions.spliceFunction(fan.eta, 1E-005, fan.eta-1E-005, 1E-006)^2");
helpvar[265] = 1.0+helpvar[212]*helpvar[260]-helpvar[259]+helpvar[215];
helpvar[266] = (-1.0)*(helpvar[258]+(IF helpvar[206] THEN  -W_[186] ELSE  -
  W_[77])-helpvar[209]*((PushModelContext(1,"IDEAS.Utilities.Math.Functions.BaseClasses.der_spliceFunction(fan.QThe_flow, 0, noEvent(abs(fan.VMachine_flow))-2*fan.delta_V_flow, fan.delta_V_flow, 0.0, 0, noEvent((if fan.VMachine_flow > 0 then 1 else -1)), 0.0)")
  IDEAS_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(W_[159], 0, 
  helpvar[214], W_[156], 0.0, 0, IF W_[147] > 0 THEN 1 ELSE -1, 0.0))*helpvar[216]
  -(helpvar[264]*helpvar[262]+W_[85]*helpvar[265])));
PopModelContext();
SetMatrixLeading(Jacobian__, 1, 1, 4, (-1.6028961287543954E-005)*(helpvar[230]-
  (PushModelContext(1,"IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der( -pipe.port_b.m_flow, 0.5059644256269408, 0.0016, -1.0)")
  (-1.0)*(IF helpvar[205] > 0.0016 THEN (-7.812499999999998)*W_[42] ELSE IF 
  helpvar[205] < -0.0016 THEN 7.812499999999998*W_[42] ELSE 0.0031249999999999993
  +3662.109374999999*sqr(W_[42]))))*helpvar[231]);
PopModelContext();
SetMatrixLeading(Jacobian__, 1, 3, 4, -1.0);
SetMatrixLeading(Jacobian__, 1, 4, 4, (-0.001)*helpvar[230]*helpvar[232]);
SetMatrixLeading(Jacobian__, 2, 1, 4,  -helpvar[209]*(-1.6028961287543954E-005)*
  (helpvar[233]*W_[141]+W_[85])*helpvar[231]);
SetMatrixLeading(Jacobian__, 2, 2, 4, W_[145]);
SetMatrixLeading(Jacobian__, 2, 3, 4, W_[147]);
SetMatrixLeading(Jacobian__, 3, 1, 4, (-1.6028961287543954E-005)*((-1.0)*
  helpvar[243]-(IF helpvar[228] THEN W_[77] ELSE W_[40]))*helpvar[231]);
SetMatrixLeading(Jacobian__, 3, 4, 4, (0.001*(helpvar[243]+W_[289])+helpvar[227]
  *300000.0*W_[299])*helpvar[232]+4184.0*W_[299]);
SetMatrixLeading(Jacobian__, 4, 1, 4, (1.6028961287543954E-005*(helpvar[266]-
  W_[328])+helpvar[208]*(-300000.0)*W_[338])*helpvar[231]-4184.0*W_[338]);
SetMatrixLeading(Jacobian__, 4, 2, 4, helpvar[259]*(IF W_[154] THEN 0.0 ELSE 1.0));
SetMatrixLeading(Jacobian__, 4, 3, 4,  -W_[147]*helpvar[265]);
SetMatrixLeading(Jacobian__, 4, 4, 4, (-0.001)*helpvar[258]*helpvar[232]);

SolveNonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 3);
F_[4] = GetVector(x__, 1);
W_[141] = GetVector(x__, 2);
W_[76] = GetVector(x__, 3);
F_[3] = GetVector(x__, 4);
EndNonLinearSystemOfEquationsNH(residue__, x__, 3);
 /* End of Non-Linear Equation Block */ }



AssertModelica(GreaterEqual(W_[43],"pipe.port_b.p", 0.0,"0.0", 2),
  "pipe.port_b.p >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("Pressure (= ",Real2String2(W_[43], true, 0))," Pa) of medium \""),
  "WaterDetailed"),"\" is negative\n(Temperature = "),Real2String2(X_[3], true, 0)),
  " K)"));
PopAllMarks();
AssertModelica(GreaterEqual(W_[76],"fan.port_a.p", 0.0,"0.0", 3),
  "fan.port_a.p >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("Pressure (= ",Real2String2(W_[76], true, 0))," Pa) of medium \""),
  "WaterDetailed"),"\" is negative\n(Temperature = "),Real2String2(X_[4], true, 0)),
  " K)"));
PopAllMarks();
BreakSectionFunctionEnd()
BreakSectionFunctionStart(6);
W_[340] = W_[344]+W_[345];
W_[4] = X_[0]-DP_[63];
 /* Linear system of equations to solve. */
W_[3] = RememberSimple_(W_[3], 5);
SolveScalarLinearParametric( -DP_[1]," -pipe.Rgb.R",  -W_[4]," -pipe.Rgb.dT", 
  W_[3],"pipe.Rgb.Q_flow");
 /* End of Equation Block */ 

W_[5] = W_[0]-W_[3];
 /* Linear system of equations to solve. */
F_[0] = RememberSimple_(F_[0], 6);
SolveScalarLinearParametric(DP_[2],"pipe.Cg.C", W_[5],"pipe.Cg.port.Q_flow", 
  F_[0],"der(pipe.Cg.T)");
 /* End of Equation Block */ 


AcceptedSection1

AcceptedSection2
Aux_[12] = W_[77];
Aux_[2] = W_[49];
Aux_[13] = W_[49];
Aux_[6] = W_[121];
Aux_[15] = W_[121];
Aux_[0] = W_[77];
Aux_[1] = W_[49];
Aux_[3] = W_[49];
Aux_[4] = W_[40];
helpvar[267] = RealBmax(W_[38], 0.0);
Aux_[20] = helpvar[267]+helpvar[203];
Aux_[21] = IF Aux_[20] > 1E-010 THEN 1.0 ELSE IF Aux_[20] > 0.0 THEN sqr(
  10000000000.0*Aux_[20])*(3.0-20000000000.0*Aux_[20]) ELSE 0.0;
helpvar[268] = 1.0-Aux_[21];
helpvar[269] = 1E-010*helpvar[268];
helpvar[270] = Aux_[21]*helpvar[267]+helpvar[269];
helpvar[271] = Aux_[21]*helpvar[203]+helpvar[269];
helpvar[272] = helpvar[270]+helpvar[271];
helpvar[273] = divmacro(1.0,"1.0",helpvar[272],"stream_alpha5*max(pipe.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha5)+stream_alpha5*max( -pipe.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha5)");
Aux_[5] = helpvar[273]*(helpvar[270]*W_[49]+helpvar[271]*W_[40]);
Aux_[8] = W_[121];
Aux_[9] = W_[40];
Aux_[10] = W_[77];
Aux_[22] = helpvar[191]+helpvar[203];
Aux_[23] = IF Aux_[22] > 1E-010 THEN 1.0 ELSE IF Aux_[22] > 0.0 THEN sqr(
  10000000000.0*Aux_[22])*(3.0-20000000000.0*Aux_[22]) ELSE 0.0;
helpvar[274] = 1.0-Aux_[23];
helpvar[275] = 1E-010*helpvar[274];
helpvar[276] = Aux_[23]*helpvar[191]+helpvar[275];
helpvar[277] = Aux_[23]*helpvar[203]+helpvar[275];
helpvar[278] = helpvar[276]+helpvar[277];
helpvar[279] = divmacro(1.0,"1.0",helpvar[278],"stream_alpha7*max( -fan.port_b.m_flow, 0.0)+1E-010*(1.0-stream_alpha7)+stream_alpha7*max( -pipe.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha7)");
Aux_[11] = helpvar[279]*(helpvar[276]*W_[77]+helpvar[277]*W_[40]);
Aux_[14] = W_[186];
Aux_[7] = W_[186];
W_[297] = W_[299]*W_[289];
W_[336] = W_[338]*W_[328];
W_[6] = DP_[2]*(X_[0]-W_[9])+4184.0*(X_[0]-W_[9]);
W_[8] = divmacro(W_[6],"pipe.SoC_teller",W_[7],"pipe.SoC_noemer");
W_[11] = 273.15+0.0002390057361376673*Aux_[5];
W_[14] = IF W_[11] < 278.15 THEN 1011.9695761-0.042860825*W_[11] ELSE IF W_[11]
   < 373.15 THEN 254.900074971947+1.5009E-005*powmacro(W_[11],"pipe.sta_default.T",3,
  "3")-0.01813488505*sqr(W_[11])+6.5619527954075*W_[11] ELSE 1220.35045233-
  0.7025109*W_[11];
W_[129] = W_[76]-300000.0;
W_[130] =  -divmacro(W_[79],"fan.port_b.m_flow",IF  -W_[79] > 1.6000000000000001E-006
   THEN (IF 273.15+0.0002390057361376673*W_[77] < 278.15 THEN 1000.26214175125-
  1.0243983030592733E-005*W_[77] ELSE IF 273.15+0.0002390057361376673*W_[77] < 
  373.15 THEN 2047.2974810375053+1.5009E-005*powmacro(273.15+0.0002390057361376673
  *W_[77],"273.15+0.0002390057361376673*fan.port_a.h_outflow",3,"3")-
  0.01813488505*sqr(273.15+0.0002390057361376673*W_[77])+0.0015683443583669931*
  W_[77] ELSE 1028.459599995-0.0001679041347992352*W_[77]) ELSE IF  -W_[79] < 
  -1.6000000000000001E-006 THEN (IF 273.15+0.0002390057361376673*W_[121] < 
  278.15 THEN 1000.26214175125-1.0243983030592733E-005*W_[121] ELSE IF 273.15+
  0.0002390057361376673*W_[121] < 373.15 THEN 2047.2974810375053+1.5009E-005*
  powmacro(273.15+0.0002390057361376673*W_[121],"273.15+0.0002390057361376673*fan.preSou.port_a.h_outflow",3,
  "3")-0.01813488505*sqr(273.15+0.0002390057361376673*W_[121])+0.0015683443583669931
  *W_[121] ELSE 1028.459599995-0.0001679041347992352*W_[121]) ELSE 0.5*((IF 
  273.15+0.0002390057361376673*W_[77] < 278.15 THEN 1000.26214175125-
  1.0243983030592733E-005*W_[77] ELSE IF 273.15+0.0002390057361376673*W_[77] < 
  373.15 THEN 2047.2974810375053+1.5009E-005*powmacro(273.15+0.0002390057361376673
  *W_[77],"273.15+0.0002390057361376673*fan.port_a.h_outflow",3,"3")-
  0.01813488505*sqr(273.15+0.0002390057361376673*W_[77])+0.0015683443583669931*
  W_[77] ELSE 1028.459599995-0.0001679041347992352*W_[77])+(IF 273.15+
  0.0002390057361376673*W_[121] < 278.15 THEN 1000.26214175125-1.0243983030592733E-005
  *W_[121] ELSE IF 273.15+0.0002390057361376673*W_[121] < 373.15 THEN 
  2047.2974810375053+1.5009E-005*powmacro(273.15+0.0002390057361376673*W_[121],
  "273.15+0.0002390057361376673*fan.preSou.port_a.h_outflow",3,"3")-
  0.01813488505*sqr(273.15+0.0002390057361376673*W_[121])+0.0015683443583669931*
  W_[121] ELSE 1028.459599995-0.0001679041347992352*W_[121]))-156250.0*W_[79]*(
  sqr((-625000.0)*W_[79])-3)*((IF 273.15+0.0002390057361376673*W_[121] < 278.15
   THEN 1000.26214175125-1.0243983030592733E-005*W_[121] ELSE IF 273.15+
  0.0002390057361376673*W_[121] < 373.15 THEN 2047.2974810375053+1.5009E-005*
  powmacro(273.15+0.0002390057361376673*W_[121],"273.15+0.0002390057361376673*fan.preSou.port_a.h_outflow",3,
  "3")-0.01813488505*sqr(273.15+0.0002390057361376673*W_[121])+0.0015683443583669931
  *W_[121] ELSE 1028.459599995-0.0001679041347992352*W_[121])-(IF 273.15+
  0.0002390057361376673*W_[77] < 278.15 THEN 1000.26214175125-1.0243983030592733E-005
  *W_[77] ELSE IF 273.15+0.0002390057361376673*W_[77] < 373.15 THEN 
  2047.2974810375053+1.5009E-005*powmacro(273.15+0.0002390057361376673*W_[77],
  "273.15+0.0002390057361376673*fan.port_a.h_outflow",3,"3")-0.01813488505*sqr(
  273.15+0.0002390057361376673*W_[77])+0.0015683443583669931*W_[77] ELSE 
  1028.459599995-0.0001679041347992352*W_[77])),"smooth(1, (if noEvent( -fan.port_b.m_flow > 1.6000000000000001E-006) then smooth(1, (if noEvent(273.15+0.0002390057361376673*fan.port_a.h_outflow < 278.15) then 1000.26214175125-1.0243983030592733E-005*fan.port_a.h_outflow else (if noEvent(273.15+0.0002390057361376673*fan.port_a.h_outflow < 373.15) then 2047.2974810375053+1.5009E-005*(273.15+0.0002390057361376673*fan.port_a.h_outflow)^3-0.01813...");
W_[161] = divmacro(W_[147],"fan.VMachine_flow",W_[163],"fan.V_flow_max");
W_[190] = W_[43]-W_[76];
helpvar[280] =  -W_[42];
W_[237] = (PushModelContext(1,"IDEAS.Utilities.Math.Functions.spliceFunction( -pipe.port_b.m_flow, 0,  -pipe.port_b.m_flow, 1.6000000000000001E-006)")
  IDEAS_Utilities_Math_Functions_spliceFunction(helpvar[280], 0, helpvar[280], 
  1.6000000000000001E-006));
PopModelContext();
W_[201] = W_[237]*(W_[186]-W_[40]);
W_[295] = X_[3]-273.15;
W_[296] = 1E-005*W_[43];
W_[334] = X_[4]-273.15;
W_[335] = 1E-005*W_[76];

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("pipe.Rfg.Q_flow", "Heat flow rate from port_a -> port_b [W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe.Rfg.dT", "port_a.T - port_b.T [K,]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe.Rfg.port_a.T", "Port temperature [K|degC]", 300.0, 1.0,\
10000.0,300.0,0,520)
DeclareAlias2("pipe.Rfg.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "pipe.Rfg.Q_flow", 1, 5, 0, 132)
DeclareAlias2("pipe.Rfg.port_b.T", "Port temperature [K|degC]", "pipe.Cg.T", 1, 1,\
 0, 4)
DeclareAlias2("pipe.Rfg.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "pipe.Rfg.Q_flow", -1, 5, 0, 132)
DeclareParameter("pipe.Rfg.R", "Constant thermal resistance of material [K/W]", 0,\
 0.02, 0.0,0.0,0.0,0,560)
DeclareVariable("pipe.Rgb.Q_flow", "Heat flow rate from port_a -> port_b [W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe.Rgb.dT", "port_a.T - port_b.T [K,]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("pipe.Rgb.port_a.T", "Port temperature [K|degC]", "pipe.Cg.T", 1, 1,\
 0, 4)
DeclareAlias2("pipe.Rgb.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "pipe.Rgb.Q_flow", 1, 5, 3, 132)
DeclareAlias2("pipe.Rgb.port_b.T", "Port temperature [K|degC]", "pipeData.TempWall", 1,\
 7, 63, 4)
DeclareAlias2("pipe.Rgb.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "pipe.Rgb.Q_flow", -1, 5, 3, 132)
DeclareParameter("pipe.Rgb.R", "Constant thermal resistance of material [K/W]", 1,\
 0.02, 0.0,0.0,0.0,0,560)
DeclareParameter("pipe.Cg.C", "Heat capacity of element (= cp*m) [J/K]", 2, \
200000000.0, 0.0,0.0,0.0,0,560)
DeclareState("pipe.Cg.T", "Temperature of element [K|degC]", 0, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareDerivative("pipe.Cg.der(T)", "der(Temperature of element) [K/s]", 0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("pipe.Cg.der_T", "Time derivative of temperature (= der(T)) [K/s]",\
 "pipe.Cg.der(T)", 1, 6, 0, 0)
DeclareAlias2("pipe.Cg.port.T", "Port temperature [K|degC]", "pipe.Cg.T", 1, 1, 0,\
 4)
DeclareVariable("pipe.Cg.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("pipe.TempBoundary.port.T", "Port temperature [K|degC]", \
"pipeData.TempWall", 1, 7, 63, 4)
DeclareAlias2("pipe.TempBoundary.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "pipe.Rgb.Q_flow", 1, 5, 3, 132)
DeclareAlias2("pipe.TempBoundary.T", "[K]", "pipeData.TempWall", 1, 7, 63, 0)
DeclareVariable("pipe.SoC_teller", "[J]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe.SoC_noemer", "[J]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.SoC", "[1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe.Tref", "[K|degC]", 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("pipe.Tmax", "[K|degC]", 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("pipe.sta_default.T", "Temperature of medium [K|degC]", 293.15, \
1.0,10000.0,300.0,0,512)
DeclareVariable("pipe.sta_default.p", "Pressure of medium [Pa|bar]", 300000, 0.0,\
100000000.0,100000.0,0,513)
DeclareVariable("pipe.Cp_fluid", "Specific heat capacity of medium [J/K]", 4184,\
 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.rho", "Density of medium [kg/m3|g/cm3]", 0.0, 0.0,1E+100,\
0.0,0,512)
DeclareVariable("pipe.vol.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pipe.vol.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pipe.vol.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pipe.vol.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("pipe.vol.p_start", "Start value of pressure [Pa|bar]", 3, 300000,\
 0.0,100000000.0,100000.0,0,560)
DeclareParameter("pipe.vol.T_start", "Start value of temperature [K|degC]", 4, \
293.15, 1.0,10000.0,300.0,0,560)
DeclareParameter("pipe.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 5, 1, 0.0,1.0,0.1,0,560)
DeclareVariable("pipe.vol.mSenFac", "Factor for scaling the sensible thermal mass of the volume [1]",\
 1, 1.0,1E+100,0.0,0,513)
DeclareVariable("pipe.vol.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("pipe.vol.prescribedHeatFlowRate", "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.vol.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
0.016, 0.0,1E+100,0.0,0,513)
DeclareVariable("pipe.vol.nPorts", "Number of ports [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,517)
DeclareVariable("pipe.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.6000000000000001E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("pipe.vol.allowFlowReversal", "= true to allow flow reversal in medium, false restricts to design direction (ports[1] -> ports[2]). Used only if model has two ports. [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.vol.V", "Volume [m3]", 0.001, 0.0,0.0,0.0,0,513)
DeclareAlias2("pipe.vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_b.m_flow", 1, 5, 42, 132)
DeclareAlias2("pipe.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pipe.port_b.p", 1, 5, 43, 4)
DeclareAlias2("pipe.vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pipe.port_a.h_outflow", 1, 5, 40, 4)
DeclareAlias2("pipe.vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_a.m_flow", 1, 5, 38, 132)
DeclareAlias2("pipe.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pipe.port_b.p", 1, 5, 43, 4)
DeclareAlias2("pipe.vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pipe.port_a.h_outflow", 1, 5, 40, 4)
DeclareAlias2("pipe.vol.heatPort.T", "Port temperature [K|degC]", \
"pipe.Rfg.port_a.T", 1, 5, 2, 4)
DeclareAlias2("pipe.vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "pipe.Rfg.Q_flow", -1, 5, 0, 132)
DeclareAlias2("pipe.vol.T", "Temperature of the fluid [K|degC]", \
"pipe.Rfg.port_a.T", 1, 5, 2, 0)
DeclareAlias2("pipe.vol.p", "Pressure of the fluid [Pa|bar]", "pipe.port_b.p", 1,\
 5, 43, 0)
DeclareVariable("pipe.vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialPureSubstance.X_default[1]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 1, \
0.0,1.0,0.1,0,2561)
DeclareVariable("pipe.vol.state_default.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("pipe.vol.state_default.p", "Pressure of medium [Pa|bar]", \
300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pipe.vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 998.1931899999996, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pipe.vol.state_start.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("pipe.vol.state_start.p", "Pressure of medium [Pa|bar]", 300000,\
 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pipe.vol.useSteadyStateTwoPort", "Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pipe.vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 "pipe.port_a.h_outflow", 1, 5, 40, 1024)
DeclareAlias2("pipe.vol.QSen_flow.y", "Value of Real output [W]", \
"pipe.Rfg.Q_flow", -1, 5, 0, 1024)
DeclareVariable("pipe.vol.masExc.k", "Constant output value [kg/s]", 0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("pipe.vol.masExc.y", "Connector of Real output signal [kg/s]", 0,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("pipe.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,100000.0,0.016,0,776)
DeclareVariable("pipe.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("pipe.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("pipe.port_a.der(h_outflow)", "der(Specific thermodynamic enthalpy close to the connection point if m_flow < 0) [m2/s3]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("pipe.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,100000.0,0.016,0,776)
DeclareVariable("pipe.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,520)
DeclareAlias2("pipe.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pipe.port_a.h_outflow", 1, 5, 40, 4)
DeclareAlias2("pipe.T1", "[K]", "pipeData.TempWall", 1, 7, 63, 0)
DeclareVariable("pipe.pipeData.m_flow_nominal", "nominal mass flow rate [kg/s]",\
 0.016, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.pipeData.V", "volume [m3]", 0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.pipeData.dp_nominal", "nominal pressure difference [Pa|bar]",\
 0.001, 0.0,0.0,0.0,0,513)
DeclareParameter("pipe.pipeData.TempWall", "Wall Temperature [K|degC]", 6, 283, \
0.0,1E+100,300.0,0,560)
DeclareParameter("pipe.pipeData.Tref", "Reference Temperature [K|degC]", 7, 283,\
 0.0,1E+100,300.0,0,560)
DeclareParameter("pipe.pipeData.Tmax", "Maximum Temperature [K|degC]", 8, 288, \
0.0,1E+100,300.0,0,560)
DeclareVariable("pipe.res.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pipe.res.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_a.m_flow", 1, 5, 38, 132)
DeclareVariable("pipe.res.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("pipe.res.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pipe.port_a.h_outflow", 1, 5, 40, 4)
DeclareAlias2("pipe.res.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_a.m_flow", -1, 5, 38, 132)
DeclareAlias2("pipe.res.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pipe.port_b.p", 1, 5, 43, 4)
DeclareVariable("pipe.res.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareParameter("pipe.res.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 9, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pipe.res.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 10, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pipe.res.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 11, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("pipe.res.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
0.016, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.res.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.6000000000000001E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("pipe.res.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("pipe.res.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "pipe.port_a.m_flow", 1, 5, 38, 0)
DeclareVariable("pipe.res.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.001,0,512)
DeclareVariable("pipe.res.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.res.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.res.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.res.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.res.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.0048, 0.0,1E+100,0.0,0,513)
DeclareParameter("pipe.res.sta_default.T", "Temperature of medium [K|degC]", 12,\
 293.15, 1.0,10000.0,300.0,0,2608)
DeclareParameter("pipe.res.sta_default.p", "Pressure of medium [Pa|bar]", 13, \
300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareVariable("pipe.res.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pipe.res.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 0.016, 0.0,0.0,0.0,0,2561)
DeclareVariable("pipe.res.dp_nominal_pos", "Absolute value of nominal pressure [Pa|bar]",\
 0.001, 0.0,0.0,0.0,0,2561)
DeclareVariable("pipe.res.use_dh", "Set to true to specify hydraulic diameter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("pipe.res.dh", "Hydraulic diameter [m]", 14, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("pipe.res.ReC", "Reynolds number where transition to turbulent starts",\
 15, 4000, 0.0,1E+100,0.0,0,560)
DeclareVariable("pipe.res.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.3, 0.01,1E+100,0.0,0,513)
DeclareVariable("pipe.res.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.5059644256269408, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.res.computeFlowResistance", "Flag to enable/disable computation of flow resistance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pipe.V", "[m3]", 0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.tempSensor.port.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, 0.0,100000.0,0.0,0,777)
DeclareAlias2("pipe.tempSensor.port.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pipe.port_b.p", 1, 5, 43, 4)
DeclareVariable("pipe.tempSensor.port.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialPureSubstance.X_default_Unique17[1]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 1, \
0.0,1.0,0.1,0,2561)
DeclareAlias2("pipe.tempSensor.T", "Temperature in port medium [K|degC]", \
"pipe.sta_default.T", 1, 5, 11, 0)
DeclareVariable("fan.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("fan.p_start", "Start value of pressure [Pa|bar]", 16, 300000, \
0.0,100000000.0,100000.0,0,560)
DeclareParameter("fan.T_start", "Start value of temperature [K|degC]", 17, \
293.15, 1.0,10000.0,300.0,0,560)
DeclareParameter("fan.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 18, 1, 0.0,1.0,0.1,0,560)
DeclareVariable("fan.mSenFac", "Factor for scaling the sensible thermal mass of the volume",\
 1, 1.0,1E+100,0.0,0,513)
DeclareVariable("fan.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("fan.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_b.m_flow", -1, 5, 42, 132)
DeclareVariable("fan.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,520)
DeclareVariable("fan.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("fan.port_a.der(h_outflow)", "der(Specific thermodynamic enthalpy close to the connection point if m_flow < 0) [m2/s3]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("fan.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0.0, -100000.0,100000.0,0.016,0,776)
DeclareVariable("fan.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("fan.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "fan.port_a.h_outflow", 1, 5, 77, 4)
DeclareParameter("fan.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 19, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("fan.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 20, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("fan.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("fan.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.016, \
0.0,0.0,0.0,0,513)
DeclareVariable("fan.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.6000000000000001E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("fan.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("fan.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "pipe.port_b.m_flow", -1, 5, 42, 0)
DeclareVariable("fan.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,576)
DeclareVariable("fan.vol.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.vol.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.vol.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.vol.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.vol.p_start", "Start value of pressure [Pa|bar]", 300000, \
0.0,100000000.0,100000.0,0,513)
DeclareVariable("fan.vol.T_start", "Start value of temperature [K|degC]", 293.15,\
 1.0,10000.0,300.0,0,513)
DeclareVariable("fan.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("fan.vol.mSenFac", "Factor for scaling the sensible thermal mass of the volume [1]",\
 1, 1.0,1E+100,0.0,0,513)
DeclareVariable("fan.vol.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("fan.vol.prescribedHeatFlowRate", "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("fan.vol.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("fan.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.016,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("fan.vol.nPorts", "Number of ports [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,517)
DeclareVariable("fan.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.6000000000000001E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("fan.vol.allowFlowReversal", "= true to allow flow reversal in medium, false restricts to design direction (ports[1] -> ports[2]). Used only if model has two ports. [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("fan.vol.V", "Volume [m3]", 1.6028961287543954E-005, 0.0,0.0,0.0,\
0,513)
DeclareAlias2("fan.vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_b.m_flow", -1, 5, 42, 132)
DeclareAlias2("fan.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "fan.port_a.p", 1, 5, 76, 4)
DeclareAlias2("fan.vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "fan.port_a.h_outflow", 1, 5, 77, 4)
DeclareAlias2("fan.vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "fan.port_b.m_flow", 1, 5, 79, 132)
DeclareAlias2("fan.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "fan.port_a.p", 1, 5, 76, 4)
DeclareAlias2("fan.vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "fan.port_a.h_outflow", 1, 5, 77, 4)
DeclareAlias2("fan.vol.heatPort.T", "Port temperature [K|degC]", \
"fan.heatPort.T", 1, 5, 117, 4)
DeclareVariable("fan.vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("fan.vol.T", "Temperature of the fluid [K|degC]", "fan.heatPort.T", 1,\
 5, 117, 0)
DeclareAlias2("fan.vol.p", "Pressure of the fluid [Pa|bar]", "fan.port_a.p", 1, 5,\
 76, 0)
DeclareVariable("fan.vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan.vol.state_default.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("fan.vol.state_default.p", "Pressure of medium [Pa|bar]", \
300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("fan.vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 998.1931899999996, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan.vol.state_start.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("fan.vol.state_start.p", "Pressure of medium [Pa|bar]", 300000, \
0.0,100000000.0,100000.0,0,2561)
DeclareVariable("fan.vol.useSteadyStateTwoPort", "Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("fan.vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 "fan.port_a.h_outflow", 1, 5, 77, 1024)
DeclareAlias2("fan.vol.QSen_flow.y", "Value of Real output [W]", \
"fan.vol.heatPort.Q_flow", 1, 5, 102, 1024)
DeclareVariable("fan.vol.masExc.k", "Constant output value [kg/s]", 0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("fan.vol.masExc.y", "Connector of Real output signal [kg/s]", 0,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.tau", "Time constant at nominal flow [s]", 1.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("fan.vol.V_nominal", "Volume of delay element [m3]", \
1.6028961287543954E-005, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.dynamicBalance", "Set to true to use a dynamic balance, which often leads to smaller systems of equations [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("fan.addPowerToMedium", "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("fan.tau", "Time constant of fluid volume for nominal flow, used if dynamicBalance=true [s]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("fan.heatPort.T", "Port temperature [K|degC]", 300.0, 1.0,\
10000.0,300.0,0,520)
DeclareVariable("fan.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("fan.rho_in", "Density of inflowing fluid [kg/m3|g/cm3]", 0.0, \
0.0,1E+100,0.0,0,2688)
DeclareVariable("fan.preSou.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("fan.preSou.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "fan.port_b.m_flow", -1, 5, 79, 1156)
DeclareAlias2("fan.preSou.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "fan.port_a.p", 1, 5, 76, 1028)
DeclareVariable("fan.preSou.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,2568)
DeclareAlias2("fan.preSou.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "fan.port_b.m_flow", 1, 5, 79, 1156)
DeclareVariable("fan.preSou.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2569)
DeclareAlias2("fan.preSou.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "fan.port_a.h_outflow", 1, 5, 77, 1028)
DeclareVariable("fan.preSou.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("fan.preSou.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("fan.preSou.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 21, true, 0.0,0.0,0.0,0,2610)
DeclareParameter("fan.preSou.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 22, 0, 0.0,100000000.0,100000.0,0,2608)
DeclareVariable("fan.preSou.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,2561)
DeclareVariable("fan.preSou.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.6000000000000001E-006, -100000.0,100000.0,0.0,0,2561)
DeclareVariable("fan.preSou.show_T", "= true, if temperatures at port_a and port_b are computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("fan.preSou.show_V_flow", "= true, if volume flow rate at inflowing port is computed [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("fan.preSou.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "fan.port_b.m_flow", -1, 5, 79, 1024)
DeclareVariable("fan.preSou.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|bar]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("fan.preSou.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("fan.preSou.control_m_flow", "= false to control dp instead of m_flow [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("fan.preSou.m_flow_internal", "Needed to connect to conditional connector [kg/s]",\
 "fan.port_b.m_flow", -1, 5, 79, 1024)
DeclareVariable("fan.preSou.dp_internal", "Needed to connect to conditional connector [Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareParameter("fan.prePow.T_ref", "Reference temperature [K|degC]", 23, \
293.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("fan.prePow.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 24, 0, 0.0,0.0,0.0,0,2608)
DeclareVariable("fan.prePow.Q_flow", "[W]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("fan.prePow.port.T", "Port temperature [K|degC]", "fan.heatPort.T", 1,\
 5, 117, 1028)
DeclareAlias2("fan.prePow.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "fan.vol.heatPort.Q_flow", -1, 5, 102, 1156)
DeclareVariable("fan.sta_start.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,2561)
DeclareVariable("fan.sta_start.p", "Pressure of medium [Pa|bar]", 300000, 0.0,\
100000000.0,100000.0,0,2561)
DeclareVariable("fan.h_outflow_start", "Start value for outflowing enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.use_powerCharacteristic", "Use powerCharacteristic (vs. efficiencyCharacteristic) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("fan.motorCooledByFluid", "If true (and if addPowerToMedium = true), then motor heat is added to fluid stream [:#(type=Boolean)]",\
 25, false, 0.0,0.0,0.0,0,562)
DeclareVariable("fan.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("fan.rho_default", "Fluid density at medium default state [kg/m3|g/cm3]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("fan.P", "Electrical power consumed [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("fan.WHyd", "Hydraulic power input (converted to flow work and heat) [W]",\
 0.0, 0.0,0.0,0.0,0,576)
DeclareVariable("fan.WFlo", "Flow work [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("fan.Q_flow", "Heat input from fan or pump to medium [W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("fan.eta", "Global efficiency [1]", 0.0, 0.0,1.0,0.0,0,512)
DeclareVariable("fan.etaHyd", "Hydraulic efficiency [1]", 0.0, 0.0,1.0,0.0,0,512)
DeclareVariable("fan.etaMot", "Motor efficiency [1]", 0.0, 0.0,1.0,0.0,0,512)
DeclareAlias2("fan.dpMachine", "Pressure increase [Pa|Pa]", "fan.dp", -1, 5, 85,\
 0)
DeclareVariable("fan.VMachine_flow", "Volume flow rate [m3/s]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("fan._perPow.hydraulicEfficiency.V_flow[1]", "Volumetric flow rate at user-selected operating points [m3/s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan._perPow.hydraulicEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [|1]",\
 0.0, 0.0,1.0,0.0,0,2561)
DeclareVariable("fan._perPow.motorEfficiency.V_flow[1]", "Volumetric flow rate at user-selected operating points [m3/s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan._perPow.motorEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [|1]",\
 0.0, 0.0,1.0,0.0,0,2561)
DeclareVariable("fan._perPow.power.V_flow[1]", "Volume flow rate at user-selected operating points [m3/s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan._perPow.power.P[1]", "Fan or pump electrical power at these flow rates [W]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan._perPow.motorCooledByFluid", "If true, then motor heat is added to fluid stream [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("fan._perPow.use_powerCharacteristic", "Use powerCharacteristic instead of efficiencyCharacteristic [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("fan.delta_V_flow", "Factor used for setting heat input into medium to zero at very small flows [m3/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.motDer[1]", "Coefficients for polynomial of pressure vs. flow rate",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.hydDer[1]", "Coefficients for polynomial of pressure vs. flow rate",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.QThe_flow", "Heat input from fan or pump to medium [W]", \
0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("fan.control_m_flow", "= false to control head instead of m_flow [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("fan.per.hydraulicEfficiency.V_flow[1]", "Volumetric flow rate at user-selected operating points [m3/s]",\
 26, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("fan.per.hydraulicEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [|1]",\
 27, 0.7, 0.0,1.0,0.0,0,560)
DeclareParameter("fan.per.motorEfficiency.V_flow[1]", "Volumetric flow rate at user-selected operating points [m3/s]",\
 28, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("fan.per.motorEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [|1]",\
 29, 0.7, 0.0,1.0,0.0,0,560)
DeclareParameter("fan.per.power.V_flow[1]", "Volume flow rate at user-selected operating points [m3/s]",\
 30, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("fan.per.power.P[1]", "Fan or pump electrical power at these flow rates [W]",\
 31, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("fan.per.motorCooledByFluid", "If true, then motor heat is added to fluid stream [:#(type=Boolean)]",\
 32, true, 0.0,0.0,0.0,0,562)
DeclareParameter("fan.per.use_powerCharacteristic", "Use powerCharacteristic instead of efficiencyCharacteristic [:#(type=Boolean)]",\
 33, false, 0.0,0.0,0.0,0,562)
DeclareVariable("fan.r_V", "Ratio V_flow/V_flow_max = V_flow/V_flow(dp=0, N=N_nominal) [1]",\
 1, 0.0,0.0,0.0,0,512)
DeclareVariable("fan.p_a_default", "Nominal inlet pressure for predefined fan or pump characteristics [Pa|Pa]",\
 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("fan.V_flow_max", "Maximum volume flow rate [m3/s]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareParameter("fan.sta_default.T", "Temperature of medium [K|degC]", 34, \
293.15, 1.0,10000.0,300.0,0,2608)
DeclareParameter("fan.sta_default.p", "Pressure of medium [Pa|bar]", 35, \
300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareAlias2("fan.PToMedium_flow.y", "Value of Real output [W]", \
"fan.prePow.Q_flow", 1, 5, 133, 1024)
DeclareVariable("fan.filteredSpeed", "= true, if speed is filtered with a 2nd order CriticalDamping filter [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("fan.riseTime", "Rise time of the filter (time to reach 99.6 % of the speed) [s]",\
 36, 30, 0.0,0.0,0.0,0,560)
DeclareVariable("fan.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("fan.m_flow_start", "Initial value of mass flow rate [kg/s]", 37,\
 0, 0.0,1E+100,0.0,0,560)
DeclareVariable("fan.m_flow_in", "Prescribed mass flow rate [kg/s]", 0.016, \
0.0,0.0,0.016,0,513)
DeclareAlias2("fan.m_flow_actual", "Actual mass flow rate [kg/s]", \
"fan.port_b.m_flow", -1, 5, 79, 0)
DeclareVariable("fan.filter.u", "Connector of Real input signal [kg/s]", 0.016, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("fan.filter.y", "Connector of Real output signal [kg/s]", \
"fan.port_b.m_flow", -1, 5, 79, 1024)
DeclareVariable("fan.filter.analogFilter", "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI) [:#(type=Modelica.Blocks.Types.AnalogFilter)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("fan.filter.filterType", "Type of filter (LowPass/HighPass/BandPass/BandStop) [:#(type=Modelica.Blocks.Types.FilterType)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("fan.filter.order", "Order of filter [:#(type=Integer)]", 2, 1.0,\
1E+100,0.0,0,2565)
DeclareVariable("fan.filter.f_cut", "Cut-off frequency [Hz]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("fan.filter.gain", "Gain (= amplitude of frequency response at zero frequency)",\
 38, 1.0, 0.0,0.0,0.0,0,2608)
DeclareParameter("fan.filter.A_ripple", "Pass band ripple for Chebyshev filter (otherwise not used); > 0 required [dB]",\
 39, 0.5, 0.0,0.0,0.0,0,2608)
DeclareParameter("fan.filter.f_min", "Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain) [Hz]",\
 40, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("fan.filter.normalized", "= true, if amplitude at f_cut = -3db, otherwise unmodified filter [:#(type=Boolean)]",\
 41, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("fan.filter.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("fan.filter.nx", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareParameter("fan.filter.x_start[1]", "Initial or guess values of states", 42,\
 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("fan.filter.x_start[2]", "Initial or guess values of states", 43,\
 0, 0.0,0.0,0.0,0,2608)
DeclareVariable("fan.filter.y_start", "Initial value of output [kg/s]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("fan.filter.u_nominal", "Nominal value of input (used for scaling the states) [kg/s]",\
 0.016, 0.0,0.0,0.0,0,2561)
DeclareState("fan.filter.x[1]", "Filter states", 1, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("fan.filter.der(x[1])", "der(Filter states)", 0.0, 0.0,0.0,0.0,\
0,2560)
DeclareState("fan.filter.x[2]", "Filter states", 2, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("fan.filter.der(x[2])", "der(Filter states)", 0.0, 0.0,0.0,0.0,\
0,2560)
DeclareVariable("fan.filter.ncr", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("fan.filter.nc0", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("fan.filter.na", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("fan.filter.nr", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("fan.filter.cr[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.filter.cr[2]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.filter.r[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.filter.r[2]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.filter.uu[1]", "", 1.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("fan.filter.uu[2]", "", "fan.filter.x[1]", 1, 1, 1, 1024)
DeclareAlias2("fan.filter.uu[3]", "", "fan.filter.x[2]", 1, 1, 2, 1024)
DeclareAlias2("fan.m_flow_filtered", "Filtered mass flow rate [kg/s]", \
"fan.port_b.m_flow", -1, 5, 79, 1024)
DeclareVariable("hea.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("hea.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_b.m_flow", -1, 5, 42, 132)
DeclareAlias2("hea.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pipe.port_b.p", 1, 5, 43, 4)
DeclareAlias2("hea.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "fan.port_a.h_outflow", 1, 5, 77, 4)
DeclareAlias2("hea.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_b.m_flow", 1, 5, 42, 132)
DeclareAlias2("hea.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "fan.port_a.p", 1, 5, 76, 4)
DeclareVariable("hea.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,648)
DeclareParameter("hea.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 44, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("hea.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 45, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("hea.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 46, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("hea.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.016, \
0.0,0.0,0.0,0,513)
DeclareVariable("hea.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.6000000000000001E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("hea.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("hea.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "pipe.port_b.m_flow", -1, 5, 42, 0)
DeclareVariable("hea.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("hea.computeFlowResistance", "=true, compute flow resistance. Set to false to assume no friction [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.dp_nominal", "Pressure difference [Pa|Pa]", 0.001, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("hea.linearizeFlowResistance", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.deltaM", "Fraction of nominal flow rate where flow transitions to laminar [1]",\
 0.1, 0.0,0.0,0.0,0,513)
DeclareVariable("hea.Q_flow_maxHeat", "Maximum heat flow rate for heating (positive) [W]",\
 1E+060, 0.0,0.0,0.0,0,513)
DeclareVariable("hea.Q_flow_maxCool", "Maximum heat flow rate for cooling (negative) [W]",\
 -1E+060, 0.0,0.0,0.0,0,513)
DeclareParameter("hea.tau", "Time constant at nominal flow rate (used if energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState) [s]",\
 47, 10, 0.0,1E+100,0.0,0,560)
DeclareParameter("hea.T_start", "Initial or guess value of set point [K|degC]", 48,\
 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("hea.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("hea.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.TSet", "Set point temperature of the fluid that leaves port_b [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,640)
DeclareVariable("hea.Q_flow", "Heat added to the fluid (if flow is from port_a to port_b) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("hea.preDro.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("hea.preDro.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_b.m_flow", -1, 5, 42, 1156)
DeclareAlias2("hea.preDro.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pipe.port_b.p", 1, 5, 43, 1028)
DeclareAlias2("hea.preDro.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "fan.port_a.h_outflow", 1, 5, 77, 1028)
DeclareAlias2("hea.preDro.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_b.m_flow", 1, 5, 42, 1156)
DeclareAlias2("hea.preDro.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "fan.port_a.p", 1, 5, 76, 1028)
DeclareAlias2("hea.preDro.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pipe.port_a.h_outflow", 1, 5, 40, 1028)
DeclareParameter("hea.preDro.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 49, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("hea.preDro.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 50, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("hea.preDro.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 51, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("hea.preDro.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
0.016, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.preDro.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.6000000000000001E-006, 0.0,1E+100,0.0,0,2561)
DeclareVariable("hea.preDro.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("hea.preDro.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "pipe.port_b.m_flow", -1, 5, 42, 1024)
DeclareVariable("hea.preDro.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.001,0,2560)
DeclareVariable("hea.preDro.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.preDro.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 0.001, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.preDro.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.preDro.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.preDro.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.0016, 0.0,1E+100,0.0,0,2561)
DeclareParameter("hea.preDro.sta_default.T", "Temperature of medium [K|degC]", 52,\
 293.15, 1.0,10000.0,300.0,0,2608)
DeclareParameter("hea.preDro.sta_default.p", "Pressure of medium [Pa|bar]", 53, \
300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareVariable("hea.preDro.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("hea.preDro.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 0.016, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.preDro.dp_nominal_pos", "Absolute value of nominal pressure [Pa|bar]",\
 0.001, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.preDro.use_dh", "Set to true to specify hydraulic diameter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("hea.preDro.dh", "Hydraulic diameter [m]", 54, 1, 0.0,0.0,0.0,0,2608)
DeclareParameter("hea.preDro.ReC", "Reynolds number where transition to turbulent starts",\
 55, 4000, 0.0,1E+100,0.0,0,2608)
DeclareVariable("hea.preDro.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.1, 0.01,1E+100,0.0,0,2561)
DeclareVariable("hea.preDro.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.5059644256269408, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.preDro.computeFlowResistance", "Flag to enable/disable computation of flow resistance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.heaCoo.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("hea.heaCoo.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_b.m_flow", -1, 5, 42, 1156)
DeclareAlias2("hea.heaCoo.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "fan.port_a.p", 1, 5, 76, 1028)
DeclareAlias2("hea.heaCoo.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "fan.port_a.h_outflow", 1, 5, 77, 1028)
DeclareAlias2("hea.heaCoo.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_b.m_flow", 1, 5, 42, 1156)
DeclareAlias2("hea.heaCoo.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "fan.port_a.p", 1, 5, 76, 1028)
DeclareAlias2("hea.heaCoo.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "hea.port_b.h_outflow", 1, 5, 186, 1028)
DeclareVariable("hea.heaCoo.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.heaCoo.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("hea.heaCoo.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 56, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("hea.heaCoo.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 0, 0.0,100000000.0,100000.0,0,2561)
DeclareParameter("hea.heaCoo.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 57, 0, -100000.0,100000.0,0.0,0,2608)
DeclareVariable("hea.heaCoo.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.6000000000000001E-006, -100000.0,100000.0,0.0,0,2561)
DeclareVariable("hea.heaCoo.show_T", "= true, if temperatures at port_a and port_b are computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.heaCoo.show_V_flow", "= true, if volume flow rate at inflowing port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("hea.heaCoo.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "pipe.port_b.m_flow", -1, 5, 42, 1024)
DeclareVariable("hea.heaCoo.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|bar]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.heaCoo.Q_flow_maxHeat", "Maximum heat flow rate for heating (positive) [W]",\
 1E+060, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.heaCoo.Q_flow_maxCool", "Maximum heat flow rate for cooling (negative) [W]",\
 -1E+060, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.heaCoo.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 0.016, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.heaCoo.tau", "Time constant at nominal flow rate (used if energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState) [s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("hea.heaCoo.T_start", "Initial or guess value of set point [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("hea.heaCoo.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareAlias2("hea.heaCoo.TSet", "Set point temperature of the fluid that leaves port_b [K|degC]",\
 "hea.TSet", 1, 5, 200, 1024)
DeclareAlias2("hea.heaCoo.Q_flow", "Heat added to the fluid (if flow is from port_a to port_b) [W]",\
 "hea.Q_flow", 1, 5, 201, 1024)
DeclareParameter("hea.heaCoo.cp_default", "Specific heat capacity at default medium state [J/(kg.K)]",\
 58, 4184, 0.0,0.0,0.0,0,2608)
DeclareVariable("hea.heaCoo.restrictHeat", "Flag, true if maximum heating power is restricted [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.heaCoo.restrictCool", "Flag, true if maximum cooling power is restricted [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.heaCoo.deltah", "Small value for deltah used for regularization [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.heaCoo.dynamic", "Flag, true if the sensor is a dynamic sensor [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.heaCoo.m_flow_pos", "Mass flow rate, or zero if reverse flow [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("hea.heaCoo.m_flow_limited", "Mass flow rate bounded away from zero [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("hea.heaCoo.hSet", "Set point for enthalpy leaving port_b [J/kg]",\
 "hea.port_b.h_outflow", 1, 5, 186, 1024)
DeclareAlias2("hea.heaCoo.T", "Temperature of outlet state assuming unlimited capacity and taking dynamics into account [K|degC]",\
 "hea.TSet", 1, 5, 200, 1024)
DeclareVariable("hea.heaCoo.dhSetAct", "Actual enthalpy difference from port_a to port_b [J/kg]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.heaCoo.k", "Gain to take flow rate into account for sensor time constant [1]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.heaCoo.mNor_flow", "Normalized mass flow rate [1]", 1, \
0.0,0.0,0.0,0,2561)
DeclareParameter("step.height", "Height of step [K]", 59, 10, 0.0,0.0,0.0,0,560)
DeclareAlias2("step.y", "Connector of Real output signal [K]", "hea.TSet", 1, 5,\
 200, 0)
DeclareParameter("step.offset", "Offset of output signal y [K]", 60, 274, \
0.0,0.0,0.0,0,560)
DeclareParameter("step.startTime", "Output y = offset for time < startTime [s]",\
 61, 500, 0.0,0.0,0.0,0,560)
DeclareAlias2("TWall_val.y", "Value of Real output [K]", "pipeData.TempWall", 1,\
 7, 63, 0)
DeclareVariable("const.k", "Constant output value [kg/s]", 0.016, 0.0,0.0,0.0,0,513)
DeclareVariable("const.y", "Connector of Real output signal [kg/s]", 0.016, \
0.0,0.0,0.0,0,513)
DeclareVariable("pipeData.m_flow_nominal", "nominal mass flow rate [kg/s]", \
0.016, 0.0,0.0,0.0,0,513)
DeclareParameter("pipeData.V", "volume [m3]", 62, 0.001, 0.0,0.0,0.0,0,560)
DeclareVariable("pipeData.dp_nominal", "nominal pressure difference [Pa|bar]", \
0.001, 0.0,0.0,0.0,0,513)
DeclareParameter("pipeData.TempWall", "Wall Temperature [K|degC]", 63, 283, 0.0,\
1E+100,300.0,0,560)
DeclareParameter("pipeData.Tref", "Reference Temperature [K|degC]", 64, 283, 0.0,\
1E+100,300.0,0,560)
DeclareParameter("pipeData.Tmax", "Maximum Temperature [K|degC]", 65, 288, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("boundary.nPorts", "Number of ports [:#(type=Integer)]", 1, \
0.0,0.0,0.0,0,517)
DeclareVariable("boundary.medium.p", "Absolute pressure of medium [Pa|bar]", \
300000.0, 0.0,1E+100,100000.0,0,513)
DeclareVariable("boundary.medium.h", "Specific enthalpy of medium [J/kg]", \
83680.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boundary.medium.d", "Density of medium [kg/m3|g/cm3]", \
998.1931899999996, 0.0,100000.0,1.0,0,513)
DeclareVariable("boundary.medium.T", "Temperature of medium [K|degC]", 293.15, \
1.0,10000.0,300.0,0,513)
DeclareVariable("boundary.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("boundary.medium.u", "Specific internal energy of medium [J/kg]",\
 83379.45697585856, -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("boundary.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 8.314472, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("boundary.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareVariable("boundary.medium.state.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,513)
DeclareVariable("boundary.medium.state.p", "Pressure of medium [Pa|bar]", \
300000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("boundary.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("boundary.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("boundary.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 20.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boundary.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 3.0000000000000004, 0.0,0.0,0.0,0,513)
DeclareVariable("boundary.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0.0, -1E+060,1E+060,0.0,0,776)
DeclareVariable("boundary.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("boundary.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("boundary.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("boundary.use_p_in", "Get the pressure from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.use_X_in", "Get the composition from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.p", "Fixed value of pressure [Pa|bar]", 300000, 0.0,\
100000000.0,100000.0,0,513)
DeclareVariable("boundary.T", "Fixed value of temperature [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,513)
DeclareVariable("boundary.X[1]", "Fixed value of composition [kg/kg]", 1, 0.0,\
1.0,0.1,0,513)
DeclareVariable("boundary.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 300000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("boundary.T_in_internal", "Needed to connect to conditional connector [K]",\
 293.15, 0.0,0.0,0.0,0,2561)
DeclareVariable("boundary.X_in_internal[1]", "Needed to connect to conditional connector [1]",\
 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pipe.vol.dynBal.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pipe.vol.dynBal.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pipe.vol.dynBal.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pipe.vol.dynBal.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pipe.vol.dynBal.p_start", "Start value of pressure [Pa|bar]", 300000,\
 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe.vol.dynBal.T_start", "Start value of temperature [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,513)
DeclareVariable("pipe.vol.dynBal.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("pipe.vol.dynBal.mSenFac", "Factor for scaling the sensible thermal mass of the volume [1]",\
 1.0, 1.0,1E+100,0.0,0,513)
DeclareVariable("pipe.vol.dynBal.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("pipe.vol.dynBal.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.vol.dynBal.nPorts", "Number of ports [:#(type=Integer)]", 2,\
 0.0,0.0,0.0,0,517)
DeclareAlias2("pipe.vol.dynBal.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_b.m_flow", 1, 5, 42, 132)
DeclareAlias2("pipe.vol.dynBal.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pipe.port_b.p", 1, 5, 43, 4)
DeclareAlias2("pipe.vol.dynBal.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pipe.port_a.h_outflow", 1, 5, 40, 4)
DeclareAlias2("pipe.vol.dynBal.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_a.m_flow", 1, 5, 38, 132)
DeclareAlias2("pipe.vol.dynBal.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pipe.port_b.p", 1, 5, 43, 4)
DeclareAlias2("pipe.vol.dynBal.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pipe.port_a.h_outflow", 1, 5, 40, 4)
DeclareAlias2("pipe.vol.dynBal.medium.p", "Absolute pressure of medium [Pa|bar]",\
 "pipe.port_b.p", 1, 5, 43, 0)
DeclareAlias2("pipe.vol.dynBal.medium.h", "Specific enthalpy of medium [J/kg]", \
"pipe.port_a.h_outflow", 1, 5, 40, 0)
DeclareVariable("pipe.vol.dynBal.medium.d", "Density of medium [kg/m3|g/cm3]", \
0.0, 0.0,100000.0,1.0,0,512)
DeclareVariable("pipe.vol.dynBal.medium.der(d)", "der(Density of medium) [Pa.m-2.s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("pipe.vol.dynBal.medium.T", "Temperature of medium [K|degC]", 3, \
300.0, 1.0,10000.0,300.0,0,544)
DeclareDerivative("pipe.vol.dynBal.medium.der(T)", "der(Temperature of medium) [K/s]",\
 0.0, 0.0,0.0,0.0,0,576)
DeclareVariable("pipe.vol.dynBal.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("pipe.vol.dynBal.medium.u", "Specific internal energy of medium [J/kg]",\
 0.0, -100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("pipe.vol.dynBal.medium.der(u)", "der(Specific internal energy of medium) [m2/s3]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe.vol.dynBal.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 8.314472, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("pipe.vol.dynBal.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareAlias2("pipe.vol.dynBal.medium.state.T", "Temperature of medium [K|degC]",\
 "pipe.vol.dynBal.medium.T", 1, 1, 3, 0)
DeclareAlias2("pipe.vol.dynBal.medium.state.p", "Pressure of medium [Pa|bar]", \
"pipe.port_b.p", 1, 5, 43, 0)
DeclareVariable("pipe.vol.dynBal.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.vol.dynBal.medium.standardOrderComponents", \
"If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.vol.dynBal.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe.vol.dynBal.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe.vol.dynBal.U", "Internal energy of fluid [J]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("pipe.vol.dynBal.der(U)", "der(Internal energy of fluid) [W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe.vol.dynBal.m", "Mass of fluid [kg]", 0.0, 0.0,1E+100,0.0,0,512)
DeclareVariable("pipe.vol.dynBal.der(m)", "der(Mass of fluid) [kg/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("pipe.vol.dynBal.mb_flow", "Mass flows across boundaries [kg/s]", \
"pipe.vol.dynBal.der(m)", 1, 5, 300, 0)
DeclareVariable("pipe.vol.dynBal.Hb_flow", "Enthalpy flow across boundaries or energy source/sink [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe.vol.dynBal.fluidVolume", "Volume [m3]", 0.001, 0.0,0.0,0.0,\
0,513)
DeclareVariable("pipe.vol.dynBal.CSen", "Aditional heat capacity for implementing mFactor [J/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("pipe.vol.dynBal.Q_flow", "Sensible plus latent heat flow rate transferred into the medium [W]",\
 "pipe.Rfg.Q_flow", -1, 5, 0, 0)
DeclareVariable("pipe.vol.dynBal.mWat_flow", "Moisture mass flow rate added to the medium [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("pipe.vol.dynBal.hOut", "Leaving specific enthalpy of the component [J/kg]",\
 "pipe.port_a.h_outflow", 1, 5, 40, 0)
DeclareVariable("pipe.vol.dynBal.ports_H_flow[1]", "[W]", 0.0, -100000000.0,\
100000000.0,1000.0,0,2560)
DeclareVariable("pipe.vol.dynBal.ports_H_flow[2]", "[W]", 0.0, -100000000.0,\
100000000.0,1000.0,0,2560)
DeclareVariable("pipe.vol.dynBal.cp_default", "Heat capacity, to compute additional dry mass [J/(kg.K)]",\
 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("pipe.vol.dynBal.rho_start", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pipe.vol.dynBal.computeCSen", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,2563)
DeclareVariable("pipe.vol.dynBal.state_default.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("pipe.vol.dynBal.state_default.p", "Pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pipe.vol.dynBal.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 998.1931899999996, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pipe.vol.dynBal.hStart", "Start value for specific enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.dynBal.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.vol.dynBal.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.vol.dynBal.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.vol.dynBal.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.vol.dynBal.p_start", "Start value of pressure [Pa|bar]", 300000,\
 0.0,100000000.0,100000.0,0,513)
DeclareVariable("fan.vol.dynBal.T_start", "Start value of temperature [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,513)
DeclareVariable("fan.vol.dynBal.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("fan.vol.dynBal.mSenFac", "Factor for scaling the sensible thermal mass of the volume [1]",\
 1.0, 1.0,1E+100,0.0,0,513)
DeclareVariable("fan.vol.dynBal.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("fan.vol.dynBal.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("fan.vol.dynBal.nPorts", "Number of ports [:#(type=Integer)]", 2,\
 0.0,0.0,0.0,0,517)
DeclareAlias2("fan.vol.dynBal.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe.port_b.m_flow", -1, 5, 42, 132)
DeclareAlias2("fan.vol.dynBal.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "fan.port_a.p", 1, 5, 76, 4)
DeclareAlias2("fan.vol.dynBal.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "fan.port_a.h_outflow", 1, 5, 77, 4)
DeclareAlias2("fan.vol.dynBal.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "fan.port_b.m_flow", 1, 5, 79, 132)
DeclareAlias2("fan.vol.dynBal.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "fan.port_a.p", 1, 5, 76, 4)
DeclareAlias2("fan.vol.dynBal.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "fan.port_a.h_outflow", 1, 5, 77, 4)
DeclareAlias2("fan.vol.dynBal.medium.p", "Absolute pressure of medium [Pa|bar]",\
 "fan.port_a.p", 1, 5, 76, 0)
DeclareAlias2("fan.vol.dynBal.medium.h", "Specific enthalpy of medium [J/kg]", \
"fan.port_a.h_outflow", 1, 5, 77, 0)
DeclareVariable("fan.vol.dynBal.medium.d", "Density of medium [kg/m3|g/cm3]", \
0.0, 0.0,100000.0,1.0,0,512)
DeclareVariable("fan.vol.dynBal.medium.der(d)", "der(Density of medium) [Pa.m-2.s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("fan.vol.dynBal.medium.T", "Temperature of medium [K|degC]", 4, \
300.0, 1.0,10000.0,300.0,0,544)
DeclareDerivative("fan.vol.dynBal.medium.der(T)", "der(Temperature of medium) [K/s]",\
 0.0, 0.0,0.0,0.0,0,576)
DeclareVariable("fan.vol.dynBal.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("fan.vol.dynBal.medium.u", "Specific internal energy of medium [J/kg]",\
 0.0, -100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("fan.vol.dynBal.medium.der(u)", "der(Specific internal energy of medium) [m2/s3]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("fan.vol.dynBal.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 8.314472, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("fan.vol.dynBal.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareAlias2("fan.vol.dynBal.medium.state.T", "Temperature of medium [K|degC]",\
 "fan.vol.dynBal.medium.T", 1, 1, 4, 0)
DeclareAlias2("fan.vol.dynBal.medium.state.p", "Pressure of medium [Pa|bar]", \
"fan.port_a.p", 1, 5, 76, 0)
DeclareVariable("fan.vol.dynBal.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("fan.vol.dynBal.medium.standardOrderComponents", \
"If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("fan.vol.dynBal.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("fan.vol.dynBal.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("fan.vol.dynBal.U", "Internal energy of fluid [J]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("fan.vol.dynBal.der(U)", "der(Internal energy of fluid) [W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("fan.vol.dynBal.m", "Mass of fluid [kg]", 0.0, 0.0,1E+100,0.0,0,512)
DeclareVariable("fan.vol.dynBal.der(m)", "der(Mass of fluid) [kg/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("fan.vol.dynBal.mb_flow", "Mass flows across boundaries [kg/s]", \
"fan.vol.dynBal.der(m)", 1, 5, 339, 0)
DeclareVariable("fan.vol.dynBal.Hb_flow", "Enthalpy flow across boundaries or energy source/sink [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("fan.vol.dynBal.fluidVolume", "Volume [m3]", 1.6028961287543954E-005,\
 0.0,0.0,0.0,0,513)
DeclareVariable("fan.vol.dynBal.CSen", "Aditional heat capacity for implementing mFactor [J/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("fan.vol.dynBal.Q_flow", "Sensible plus latent heat flow rate transferred into the medium [W]",\
 "fan.vol.heatPort.Q_flow", 1, 5, 102, 0)
DeclareVariable("fan.vol.dynBal.mWat_flow", "Moisture mass flow rate added to the medium [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("fan.vol.dynBal.hOut", "Leaving specific enthalpy of the component [J/kg]",\
 "fan.port_a.h_outflow", 1, 5, 77, 0)
DeclareVariable("fan.vol.dynBal.ports_H_flow[1]", "[W]", 0.0, -100000000.0,\
100000000.0,1000.0,0,2560)
DeclareVariable("fan.vol.dynBal.ports_H_flow[2]", "[W]", 0.0, -100000000.0,\
100000000.0,1000.0,0,2560)
DeclareVariable("fan.vol.dynBal.cp_default", "Heat capacity, to compute additional dry mass [J/(kg.K)]",\
 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.dynBal.rho_start", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan.vol.dynBal.computeCSen", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,2563)
DeclareVariable("fan.vol.dynBal.state_default.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("fan.vol.dynBal.state_default.p", "Pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("fan.vol.dynBal.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 998.1931899999996, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan.vol.dynBal.hStart", "Start value for specific enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("fan.preSou.m_flow_in", "Prescribed mass flow rate [kg/s]", \
"fan.port_b.m_flow", -1, 5, 79, 1024)
EndNonAlias(0)
#define NX_    5
#define NX2_   11
#define NU_    0
#define NY_    0
#define NW_    353
#define NP_    66
#define NPS_   0
#define MAXAuxStr_   1
#define MAXAuxStrLen_   500
#define NHash1_ -473023122
#define NHash2_ 1954535867
#define NHash3_ 0
#define NI_    0
#define NRelF_ 4
#define NRel_  4
#define NTim_  1
#define NSamp_ 0
#define NCons_ 0
#define NA_    115
#define SizePre_ 0
#define SizeEq_ 7
#define SizeDelay_ 0
#define QNLmax_ 3
#define MAXAux 24
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 281
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double *time, double X_[], double XD_[], double U_[], 
double DP_[], long IP_[], Dymola_bool LP_[], double F_[], double Y_[], double W_[], double QZ_[], double duser_[], long iuser_[], void*cuser_[]) {
static Real initStore[5];
if (HReject) F_[4]=initStore[0]; else initStore[0]=F_[4];
if (HReject) F_[3]=initStore[1]; else initStore[1]=F_[3];
if (HReject) W_[141]=initStore[2]; else initStore[2]=W_[141];
if (HReject) W_[85]=initStore[3]; else initStore[3]=W_[85];
}
StartDataBlock
StartEqBlock
DoRemember_(F_[4], 0.0, 1);
DoRemember_(F_[0], 0, 6);
DoRemember_(F_[3], 0.0, 4);
DoRemember_(W_[141], 0.0, 2);
DoRemember_(W_[76], 300000, 3);
DoRemember_(W_[0], 0.0, 0);
DoRemember_(W_[3], 0.0, 5);
EndEqBlock
EndDataBlock
  BreakSectionStart(3);
  W_[143] = 0;
  { /* Non-linear system of equations to solve. */
    /* Nonlinear system of equations number = 1. */
  /* Introducing 62 common subexpressions used in 90 expressions */
  /* Of the common subexpressions 53 are reals, 0 are integers, and 9
     are booleans. */
  const char*const varnames_[]={"pipe.vol.dynBal.medium.der(T)", 
    "fan.vol.dynBal.medium.der(T)", "fan.dp"};
  const double nominal_[]={1, 1, 1e5};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 3, 0, 1, 4);
  SetInitVectorSimple(x__, 1, F_[3], 0.0);
  SetInitVectorSimple(x__, 2, F_[4], 0.0);
  SetInitVectorSimple(x__, 3, W_[85], 0);
  Residues;
    W_[41] = 4184*F_[3];
    helpvar[1] = X_[3] < 278.15;
    W_[287] = IF helpvar[1] THEN (-0.042860825)*F_[3] ELSE IF X_[3] < 373.15
       THEN 4.5027E-005*sqr(X_[3])*F_[3]-0.0362697701*X_[3]*F_[3]+
      6.5619527954075*F_[3] ELSE (-0.7025109)*F_[3];
    helpvar[2] = sqr(W_[286]);
    helpvar[3] = divmacro(1.0,"1.0",helpvar[2],"pipe.vol.dynBal.medium.d^2");
    W_[290] = W_[41]+helpvar[3]*300000*W_[287];
    W_[300] = 0.001*W_[287];
    helpvar[4] = X_[4] < 278.15;
    W_[326] = IF helpvar[4] THEN (-0.042860825)*F_[4] ELSE IF X_[4] < 373.15
       THEN 4.5027E-005*sqr(X_[4])*F_[4]-0.0362697701*X_[4]*F_[4]+
      6.5619527954075*F_[4] ELSE (-0.7025109)*F_[4];
    W_[339] = 1.6028961287543954E-005*W_[326];
    W_[42] = W_[79]-W_[339];
    W_[38] = W_[300]-W_[42];
    W_[261] =  -(W_[79]+W_[38]);
    helpvar[5] = RealBmax( -W_[79], 0.0);
    helpvar[6] =  -W_[261];
    helpvar[7] = RealBmax(helpvar[6], 0.0);
    Aux_[16] = helpvar[5]+helpvar[7];
    helpvar[8] = Aux_[16] > 1E-010;
    Aux_[17] = IF helpvar[8] THEN 1.0 ELSE IF Aux_[16] > 0.0 THEN sqr(
      10000000000.0*Aux_[16])*(3.0-20000000000.0*Aux_[16]) ELSE 0.0;
    helpvar[9] = 1.0-Aux_[17];
    helpvar[10] = 1E-010*helpvar[9];
    helpvar[11] = Aux_[17]*helpvar[5]+helpvar[10];
    helpvar[12] = Aux_[17]*helpvar[7]+helpvar[10];
    helpvar[13] = helpvar[11]*W_[77]+83680.0*helpvar[12];
    helpvar[14] = helpvar[11]+helpvar[12];
    helpvar[15] = divmacro(1.0,"1.0",helpvar[14],"stream_alpha1*max( -fan.port_b.m_flow, 0.0)+1E-010*(1.0-stream_alpha1)+stream_alpha1*max( -boundary.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha1)");
    W_[49] = helpvar[15]*helpvar[13];
    helpvar[16] = W_[38] >= 0;
    W_[306] = IF helpvar[16] THEN W_[49]*W_[38] ELSE W_[40]*W_[38];
    W_[78] = 4184*F_[4];
    helpvar[17] = sqr(W_[325]);
    helpvar[18] = divmacro(1.0,"1.0",helpvar[17],"fan.vol.dynBal.medium.d^2");
    W_[329] = W_[78]+helpvar[18]*300000*W_[326];
    helpvar[19] =  -W_[38];
    helpvar[20] = RealBmax(helpvar[19], 0.0);
    Aux_[18] = helpvar[20]+helpvar[7];
    helpvar[21] = Aux_[18] > 1E-010;
    Aux_[19] = IF helpvar[21] THEN 1.0 ELSE IF Aux_[18] > 0.0 THEN sqr(
      10000000000.0*Aux_[18])*(3.0-20000000000.0*Aux_[18]) ELSE 0.0;
    helpvar[22] = 1.0-Aux_[19];
    helpvar[23] = 1E-010*helpvar[22];
    helpvar[24] = Aux_[19]*helpvar[20]+helpvar[23];
    helpvar[25] = Aux_[19]*helpvar[7]+helpvar[23];
    helpvar[26] = helpvar[24]*W_[40]+83680.0*helpvar[25];
    helpvar[27] = helpvar[24]+helpvar[25];
    helpvar[28] = divmacro(1.0,"1.0",helpvar[27],"stream_alpha3*max( -pipe.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha3)+stream_alpha3*max( -boundary.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha3)");
    W_[121] = helpvar[28]*helpvar[26];
    helpvar[29] = W_[79] >= 0;
    W_[345] = IF helpvar[29] THEN W_[121]*W_[79] ELSE W_[77]*W_[79];
    helpvar[30] =  -W_[42] >= 0;
    W_[344] = IF helpvar[30] THEN  -W_[186]*W_[42] ELSE  -W_[77]*W_[42];
    helpvar[31] = divmacro(1.0,"1.0",W_[119],"fan.rho_in");
    W_[147] =  -helpvar[31]*W_[42];
    W_[206] = (-0.0625)*W_[42];
    W_[53] = 0.0625*W_[38];
    W_[43] = 300000.0-W_[53];
    W_[76] = 300000.0+W_[85];
    W_[142] =  -W_[85]*W_[147];
    W_[133] = W_[143]+W_[142];
    helpvar[32] = 1+DP_[24]*(W_[117]-DP_[23]);
    W_[102] = W_[133]*helpvar[32];
    W_[337] = W_[339]*W_[328]+W_[338]*W_[329];
    helpvar[33] = W_[42] >= 0;
    W_[305] = IF helpvar[33] THEN W_[77]*W_[42] ELSE W_[40]*W_[42];
    W_[301] = W_[305]+W_[306];
    W_[298] = W_[300]*W_[289]+W_[299]*W_[290];
  SetVector(residue__, 1, W_[76]-W_[43]+W_[206]);
  SetVector(residue__, 2, W_[298]-W_[301]+W_[0]);
  SetVector(residue__, 3, W_[102]-W_[337]+W_[344]+W_[345]);

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  helpvar[34] = IF helpvar[1] THEN -0.042860825 ELSE IF X_[3] < 373.15 THEN 
    6.5619527954075+4.5027E-005*sqr(X_[3])-0.0362697701*X_[3] ELSE -0.7025109;
  helpvar[35] = IF helpvar[4] THEN -0.042860825 ELSE IF X_[4] < 373.15 THEN 
    6.5619527954075+4.5027E-005*sqr(X_[4])-0.0362697701*X_[4] ELSE -0.7025109;
  helpvar[36] = IF helpvar[6] > 0.0 THEN -1.0 ELSE 0.0;
  helpvar[37] = helpvar[7]-1E-010;
  helpvar[38] = 83680.0*helpvar[37];
  helpvar[39] = sqr(helpvar[14]);
  helpvar[40] = divmacro(1.0,"1.0",helpvar[39],"(stream_alpha1*max( -fan.port_b.m_flow, 0.0)+1E-010*(1.0-stream_alpha1)+stream_alpha1*max( -boundary.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha1))^2");
  helpvar[41] = IF helpvar[16] THEN W_[38] ELSE 0.0;
  helpvar[42] = (helpvar[15]*(W_[77]*(helpvar[5]-1E-010)+helpvar[38])-helpvar[40]
    *helpvar[13]*(helpvar[5]+helpvar[37]-1E-010))*helpvar[41];
  helpvar[43] = Aux_[17]*helpvar[36];
  helpvar[44] = 83680.0*helpvar[43];
  helpvar[45] = helpvar[13]*helpvar[43];
  helpvar[46] = (-1.0)*((-1.0)*helpvar[36]*(IF helpvar[8] THEN 0.0 ELSE IF 
    Aux_[16] > 0.0 THEN 2E+020*(3.0-20000000000.0*Aux_[16])*Aux_[16]-
    20000000000.0*sqr(10000000000.0*Aux_[16]) ELSE 0.0)*helpvar[42]-(helpvar[15]
    *helpvar[44]-helpvar[40]*helpvar[45])*helpvar[41])-(IF helpvar[16] THEN 
    W_[49] ELSE W_[40]);
  helpvar[47] = W_[40]*(helpvar[20]-1E-010);
  helpvar[48] = helpvar[20]+helpvar[37]-1E-010;
  helpvar[49] = sqr(helpvar[27]);
  helpvar[50] = divmacro(1.0,"1.0",helpvar[49],"(stream_alpha3*max( -pipe.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha3)+stream_alpha3*max( -boundary.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha3))^2");
  helpvar[51] = IF helpvar[29] THEN W_[79] ELSE 0.0;
  helpvar[52] = (IF helpvar[21] THEN 0.0 ELSE IF Aux_[18] > 0.0 THEN 2E+020*(3.0
    -20000000000.0*Aux_[18])*Aux_[18]-20000000000.0*sqr(10000000000.0*Aux_[18])
     ELSE 0.0)*(helpvar[28]*(helpvar[47]+helpvar[38])-helpvar[50]*helpvar[26]*
    helpvar[48])*helpvar[51];
  helpvar[53] = helpvar[36]*helpvar[52];
  helpvar[54] = Aux_[19]*helpvar[36];
  helpvar[55] = (helpvar[28]*83680.0*helpvar[54]-helpvar[50]*helpvar[26]*
    helpvar[54])*helpvar[51];
  helpvar[56] = helpvar[19] > 0.0;
  helpvar[57] = IF helpvar[56] THEN -1.0 ELSE 0.0;
  helpvar[58] = Aux_[19]*helpvar[57];
  helpvar[59] = helpvar[28]*W_[40]*helpvar[58];
  helpvar[60] = helpvar[50]*helpvar[26]*helpvar[58];
  helpvar[61] = helpvar[53]+helpvar[55]-helpvar[57]*helpvar[52]-(helpvar[59]-
    helpvar[60])*helpvar[51];
  helpvar[62] = (-1.0)*(helpvar[61]+(IF helpvar[30] THEN  -W_[186] ELSE  -W_[77])
    +helpvar[31]*W_[85]*helpvar[32]);
  SetMatrixLeading(Jacobian__, 1, 1, 3, 6.25E-005*helpvar[34]);
  SetMatrixLeading(Jacobian__, 1, 2, 3, 2.003620160942994E-006*helpvar[35]);
  SetMatrixLeading(Jacobian__, 1, 3, 3, 1.0);
  SetMatrixLeading(Jacobian__, 2, 1, 3, 4184.0*W_[299]+(helpvar[3]*300000.0*
    W_[299]+0.001*(helpvar[46]+W_[289]))*helpvar[34]);
  SetMatrixLeading(Jacobian__, 2, 2, 3, (-1.6028961287543954E-005)*((-1.0)*
    helpvar[46]-(IF helpvar[33] THEN W_[77] ELSE W_[40]))*helpvar[35]);
  SetMatrixLeading(Jacobian__, 3, 1, 3, (-0.001)*helpvar[61]*helpvar[34]);
  SetMatrixLeading(Jacobian__, 3, 2, 3, (1.6028961287543954E-005*(helpvar[62]-
    W_[328])+helpvar[18]*(-300000.0)*W_[338])*helpvar[35]-4184.0*W_[338]);
  SetMatrixLeading(Jacobian__, 3, 3, 3,  -helpvar[32]*W_[147]);

  SolveNonLinearSystemOfEquationsInit(Jacobian__, residue__, x__);
  F_[3] = GetVector(x__, 1);
  F_[4] = GetVector(x__, 2);
  W_[85] = GetVector(x__, 3);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 1);
   /* End of Non-Linear Equation Block */ }



  W_[145] = (PushModelContext(1,"IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency(\nfan.per.hydraulicEfficiency, \nfan.VMachine_flow, \nfan.hydDer, \n1, \n0.0001)")
    IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc0_construct(
    RealTemporaryDense( &DP_[26], 1, 1), RealTemporaryDense( &DP_[27], 1, 1)), 
    W_[147], RealTemporaryDense( &W_[158], 1, 1), 1, 0.0001));
  PopAllMarks();
   /* Linear system of equations to solve. */
  W_[141] = 0.0;
  SolveScalarLinear(W_[145],"fan.etaHyd", W_[142],"fan.WFlo", W_[141],"fan.WHyd");
   /* End of Equation Block */ 

  W_[146] = (PushModelContext(1,"IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency(\nfan.per.motorEfficiency, \nfan.VMachine_flow, \nfan.motDer, \n1, \n0.0001)")
    IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc0_construct(
    RealTemporaryDense( &DP_[28], 1, 1), RealTemporaryDense( &DP_[29], 1, 1)), 
    W_[147], RealTemporaryDense( &W_[157], 1, 1), 1, 0.0001));
  PopAllMarks();
  W_[144] = W_[145]*W_[146];
  W_[140] = divmacro(W_[142],"fan.WFlo",(PushModelContext(1,"IDEAS.Utilities.Math.Functions.spliceFunction(fan.eta, 1E-005, fan.eta-1E-005, 1E-006)")
    IDEAS_Utilities_Math_Functions_spliceFunction(W_[144], 1E-005, W_[144]-
    1E-005, 1E-006)),"IDEAS.Utilities.Math.Functions.spliceFunction(fan.eta, 1E-005, fan.eta-1E-005, 1E-006)");
  PopModelContext();
  W_[159] = (IF W_[154] THEN W_[140] ELSE W_[141])-W_[142];
  BreakSectionEnd()
BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionCallNew(2);
BreakSectionFunctionCallNew(4);
BreakSectionFunctionCallNew(5);
BreakSectionFunctionCallNew(6);
BreakSectionFunctionEnd()
