/* DSblock model generated by Dymola from Modelica model IDEAS.Fluid.HeatExchangers.Examples.Heater_T
 Dymola Version 2015 FD01 (64-bit), 2014-11-04 translated this at Mon Feb 29 16:19:50 2016

   */

#include <matrixop.h>
static double DymArrays0[1]={0.0};
static const char* DymArrays1[2]={"water", "air"};
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc1;
struct DymStruc0 {
  int  id_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   id_02) {
  struct DymStruc0 dummy_0;
  dummy_0.id_0member = id_02;
  return dummy_0;
}
struct DymStruc1 {
  RealArray   V_flow_0member;
  RealArray   eta_0member;
};
DYMOLA_STATIC struct DymStruc1 DymStruc1_construct(RealArray    V_flow_02, 
  RealArray    eta_02) {
  struct DymStruc1 dummy_0;
  dummy_0.V_flow_0member = V_flow_02;
  dummy_0.eta_0member = eta_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency
  (struct DymStruc1 per0_0, double  Vx_0flow, RealArray   d0_0, double  rx_0N, 
  double  delta0_0);
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_BaseClasses_smoothTransition
  (double  x0_0, double  delta0_0, double  deltaInv0_0, double  a0_0, double  
  b0_0, double  c0_0, double  d0_0, double  e0_0, double  f0_0);
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
  (double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0);
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_smoothLimit(double  x0_0, 
  double  l0_0, double  u0_0, double  deltaX0_0);
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_smoothMax(double  x10_0, 
  double  x20_0, double  deltaX0_0);
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_smoothMin(double  x10_0, 
  double  x20_0, double  deltaX0_0);
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_spliceFunction(double  
  pos0_0, double  neg0_0, double  x0_0, double  deltax0_0);
struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct {
  RealArray    cr0_0_0member;
  RealArray    c00_0_0member;
  RealArray    c10_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
   Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne(
  RealArray   den10_0, RealArray   den20_0);
DYMOLA_STATIC RealArray    Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping
  (int  order0_0, int  normalized0_0);
struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct {
  RealArray    cr0_0_0member;
  RealArray    c00_0_0member;
  RealArray    c10_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass(RealArray   
  crx_0in, RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut);
struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct {
  RealArray    r0_0_0member;
  RealArray    a0_0_0member;
  RealArray    b0_0_0member;
  RealArray    ku0_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealArray   crx_0in,
   RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut);
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0);
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_cubicHermite(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0);
/* Codes used in model */

/* Flattened Modelica model:

function IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency
parameter input IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters per;
discrete input Real V_flow(unit = "m3/s") "Volumetric flow rate";
discrete input Real d[:] "Derivatives at support points for spline interpolation";
discrete input Real r_N(unit = "1") "Relative revolution, r_N=N/N_nominal";
discrete input Real delta "Small value for switching implementation around zero rpm";
discrete output Real eta(unit = "1", min = 0.0) "Efficiency";
protected 
Integer n(start = size(per.V_flow, 1)) "Number of data points";
discrete Real rat "Ratio of V_flow/r_N";
Integer i "Integer to select data interval";
public 
algorithm 
if (n == 1) then 
eta := per.eta[1];
else
rat := V_flow/IDEAS.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta);
i := 1;
for j in (1:n-1) loop
if (rat > per.V_flow[j]) then 
i := j;
end if;
end for;
eta := IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(rat, per.V_flow[i], per.V_flow[i+1], per.eta[i], per.eta[i+1], d[i], d[i+1]);
end if;
annotation(smoothOrder=1);
end IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency;

  */
DYMOLA_STATIC double   IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency
  (struct DymStruc1 per0_0, double  Vx_0flow, RealArray   d0_0, double  rx_0N, 
  double  delta0_0) {
  PushContext("IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency")
  {
    /* Declare outputs and temporaries */
    double   eta0_0;
    int   n0_0;
    double   rat0_0;
    int   i0_0;
    MarkObject retmark_ = PushMark();
    eta0_0=0;
    n0_0 = RealSize( per0_0.V_flow_0member, 1);
    rat0_0=0;
    i0_0=0;
    /* Start of real code */
      if (n0_0 == 1) {
        eta0_0 = RealVectorElement( per0_0.eta_0member, (SizeType)(1));
      }
      else{
        rat0_0 = divmacro(Vx_0flow,"V_flow",IDEAS_Utilities_Math_Functions_smoothMax
          (rx_0N, 0.1, delta0_0),"IDEAS.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta)");
        i0_0 = 1;
        {
          int end_ = (n0_0-1);
          int j0_0_0;
          for(j0_0_0 = 1;j0_0_0 <= end_;j0_0_0 += 1) {
            if (rat0_0 > RealElement( per0_0.V_flow_0member, (SizeType)(j0_0_0)))
               {
              i0_0 = j0_0_0;
            }
          }
        }
        eta0_0 = IDEAS_Utilities_Math_Functions_cubicHermiteLinearExtrapolation(
          rat0_0, RealElement( per0_0.V_flow_0member, (SizeType)(i0_0)), 
          RealElement( per0_0.V_flow_0member, (SizeType)(i0_0+1)), RealElement( 
          per0_0.eta_0member, (SizeType)(i0_0)), RealElement( per0_0.eta_0member,
           (SizeType)(i0_0+1)), RealElement( d0_0, (SizeType)(i0_0)), 
          RealElement( d0_0, (SizeType)(i0_0+1)));
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return eta0_0;
  }}

/* Flattened Modelica model:

function IDEAS.Utilities.Math.Functions.BaseClasses.smoothTransition
discrete input Real x "Abscissa value";
discrete input Real delta(min = 1E-015) "Abscissa value below which approximation occurs";
discrete input Real deltaInv(start = 1/delta) "Inverse value of delta";
discrete input Real a(start = (-15)*deltaInv) "Polynomial coefficient";
discrete input Real b(start = 119*deltaInv^2) "Polynomial coefficient";
discrete input Real c(start = (-361)*deltaInv^3) "Polynomial coefficient";
discrete input Real d(start = 534*deltaInv^4) "Polynomial coefficient";
discrete input Real e(start = (-380)*deltaInv^5) "Polynomial coefficient";
discrete input Real f(start = 104*deltaInv^6) "Polynomial coefficient";
discrete output Real y "Function value";
protected 
discrete Real aX "Absolute value of x";
public 
algorithm 
aX := abs(x);
y := a+aX*(b+aX*(c+aX*(d+aX*(e+aX*f))));
if (x < 0) then 
y :=  -y;
end if;
annotation(derivative(zeroDerivative=a, zeroDerivative=b, zeroDerivative=c, zeroDerivative=d, zeroDerivative=delta, zeroDerivative=deltaInv, zeroDerivative=e, zeroDerivative=f)=IDEAS.Utilities.Math.Functions.BaseClasses.der_smoothTransition, smoothOrder=2);
end IDEAS.Utilities.Math.Functions.BaseClasses.smoothTransition;

  */
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_BaseClasses_smoothTransition
  (double  x0_0, double  delta0_0, double  deltaInv0_0, double  a0_0, double  
  b0_0, double  c0_0, double  d0_0, double  e0_0, double  f0_0) {
  PushContext("IDEAS.Utilities.Math.Functions.BaseClasses.smoothTransition")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   aX0_0;
    y0_0=0;
    aX0_0=0;
    /* Start of real code */
      aX0_0 = fabs(x0_0);
      y0_0 = a0_0+aX0_0*(b0_0+aX0_0*(c0_0+aX0_0*(d0_0+aX0_0*(e0_0+aX0_0*f0_0))));
      if (x0_0 < 0) {
        y0_0 =  -y0_0;
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower gradient";
discrete input Real y2d "Upper gradient";
discrete output Real y "Interpolated ordinate value";

algorithm 
if (x > x1 and x < x2) then 
y := Modelica.Fluid.Utilities.cubicHermite(x, x1, x2, y1, y2, y1d, y2d);
elseif (x <= x1) then 
y := y1+(x-x1)*y1d;
else
y := y2+(x-x2)*y2d;
end if;
annotation(smoothOrder=1);
end IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation;

  */
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
  (double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0) {
  PushContext("IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      if (x0_0 > x10_0 AND x0_0 < x20_0) {
        y0_0 = Modelica_Fluid_Utilities_cubicHermite(x0_0, x10_0, x20_0, y10_0, 
          y20_0, y1d0_0, y2d0_0);
      }
      else if (x0_0 <= x10_0) {
        y0_0 = y10_0+(x0_0-x10_0)*y1d0_0;
      }
      else{
        y0_0 = y20_0+(x0_0-x20_0)*y2d0_0;
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function IDEAS.Utilities.Math.Functions.smoothLimit
discrete input Real x "Variable";
discrete input Real l "Low limit";
discrete input Real u "Upper limit";
discrete input Real deltaX "Width of transition interval";
discrete output Real y "Result";
protected 
discrete Real cor;
public 
algorithm 
cor := deltaX/10;
y := IDEAS.Utilities.Math.Functions.smoothMax(x, l+deltaX, cor);
y := IDEAS.Utilities.Math.Functions.smoothMin(y, u-deltaX, cor);
annotation(smoothOrder=1);
end IDEAS.Utilities.Math.Functions.smoothLimit;

  */
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_smoothLimit(double  x0_0, 
  double  l0_0, double  u0_0, double  deltaX0_0) {
  PushContext("IDEAS.Utilities.Math.Functions.smoothLimit")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   cor0_0;
    y0_0=0;
    cor0_0=0;
    /* Start of real code */
      cor0_0 = deltaX0_0/(double)(10);
      y0_0 = IDEAS_Utilities_Math_Functions_smoothMax(x0_0, l0_0+deltaX0_0, 
        cor0_0);
      y0_0 = IDEAS_Utilities_Math_Functions_smoothMin(y0_0, u0_0-deltaX0_0, 
        cor0_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function IDEAS.Utilities.Math.Functions.smoothMax
discrete input Real x1 "First argument";
discrete input Real x2 "Second argument";
discrete input Real deltaX "Width of transition interval";
discrete output Real y "Result";

algorithm 
y := IDEAS.Utilities.Math.Functions.spliceFunction(x1, x2, x1-x2, deltaX);
annotation(smoothOrder=1);
end IDEAS.Utilities.Math.Functions.smoothMax;

  */
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_smoothMax(double  x10_0, 
  double  x20_0, double  deltaX0_0) {
  PushContext("IDEAS.Utilities.Math.Functions.smoothMax")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = IDEAS_Utilities_Math_Functions_spliceFunction(x10_0, x20_0, x10_0-
        x20_0, deltaX0_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function IDEAS.Utilities.Math.Functions.smoothMin
discrete input Real x1 "First argument";
discrete input Real x2 "Second argument";
discrete input Real deltaX "Width of transition interval";
discrete output Real y "Result";

algorithm 
y := IDEAS.Utilities.Math.Functions.spliceFunction(x1, x2, x2-x1, deltaX);
end IDEAS.Utilities.Math.Functions.smoothMin;

  */
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_smoothMin(double  x10_0, 
  double  x20_0, double  deltaX0_0) {
  PushContext("IDEAS.Utilities.Math.Functions.smoothMin")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = IDEAS_Utilities_Math_Functions_spliceFunction(x10_0, x20_0, x20_0-
        x10_0, deltaX0_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function IDEAS.Utilities.Math.Functions.spliceFunction
discrete input Real pos "Argument of x > 0";
discrete input Real neg "Argument of x < 0";
discrete input Real x "Independent value";
discrete input Real deltax "Half width of transition interval";
discrete output Real out "Smoothed value";
protected 
discrete Real scaledX1;
discrete Real y;
constant Real asin1 = 1.5707963267948966;
public 
algorithm 
scaledX1 := x/deltax;
if (scaledX1 <= -0.999999999) then 
out := neg;
elseif (scaledX1 >= 0.999999999) then 
out := pos;
else
y := (tanh(tan(scaledX1*asin1))+1)/2;
out := pos*y+(1-y)*neg;
end if;
annotation(derivative=IDEAS.Utilities.Math.Functions.BaseClasses.der_spliceFunction, smoothOrder=1);
end IDEAS.Utilities.Math.Functions.spliceFunction;

  */
DYMOLA_STATIC double   IDEAS_Utilities_Math_Functions_spliceFunction(double  
  pos0_0, double  neg0_0, double  x0_0, double  deltax0_0) {
  PushContext("IDEAS.Utilities.Math.Functions.spliceFunction")
  {
    /* Declare outputs and temporaries */
    double   out0_0;
    double   scaledX10_0;
    double   y0_0;
    double   asin10_0;
    out0_0=0;
    scaledX10_0=0;
    y0_0=0;
    asin10_0 = 1.5707963267948966;
    /* Start of real code */
      scaledX10_0 = divmacro(x0_0,"x",deltax0_0,"deltax");
      if (scaledX10_0 <= -0.999999999) {
        out0_0 = neg0_0;
      }
      else if (scaledX10_0 >= 0.999999999) {
        out0_0 = pos0_0;
      }
      else{
        y0_0 = (tanh(tan(scaledX10_0*asin10_0))+1)/(double)(2);
        out0_0 = pos0_0*y0_0+(1-y0_0)*neg0_0;
      }
    /* Output section */
    PopContext()
    return out0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping
input Integer order(min = 1.0) "Order of filter";
input Boolean normalized(start = true) "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";
discrete output Real cr[order] "Coefficients of real poles";
protected 
discrete Real alpha(start = 1.0) "Frequency correction factor";
discrete Real alpha2 "= alpha*alpha";
discrete Real den1[order] "[p] coefficients of denominator first order polynomials (a*p + 1)";
discrete Real den2[0, 2] "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
discrete Real c0[0] "Coefficients of s^0 term if conjugate complex pole";
discrete Real c1[0] "Coefficients of s^1 term if conjugate complex pole";
public 
algorithm 
if (normalized) then 
alpha := sqrt(10^(0.3/order)-1);
else
alpha := 1.0;
end if;
for i in (1:order) loop
den1[i] := alpha;
end for;
(cr, c0, c1)  := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1, den2);
end Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping;

  */
DYMOLA_STATIC RealArray    Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping
  (int  order0_0, int  normalized0_0) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping")
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    double   alpha0_0;
    double   alpha20_0;
    RealArray    den10_0;
    RealArray    den20_0;
    RealArray    c00_0;
    RealArray    c10_0;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, order0_0);
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    alpha0_0 = 1.0;
    alpha20_0=0;
    den10_0=RealTemporary( 1, order0_0);
    PushMark();
    RealFillAssign( den10_0, 0);
    den20_0=RealTemporary( 2, 0, 2);
    PushMark();
    RealFillAssign( den20_0, 0);
    c00_0=RealTemporary( 1, 0);
    PushMark();
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, 0);
    PushMark();
    RealFillAssign( c10_0, 0);
    /* Start of real code */
      if (normalized0_0) {
        alpha0_0 = sqrtGuarded(powmacro(10,"10",divmacro(0.3,"0.3",order0_0,
          "order"),"0.3/order")-1,"10^(0.3/order)-1");
      }
      else{
        alpha0_0 = 1.0;
      }
      {
        int end_ = order0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(alpha0_0, den10_0, (SizeType)(i0_0_0));
        }
      }
      {
        struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
           dummy_mult_=Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne
          (den10_0, den20_0);
        RealAssign (cr0_0, dummy_mult_.cr0_0_0member);
        RealAssign (c00_0, dummy_mult_.c00_0_0member);
        RealAssign (c10_0, dummy_mult_.c10_0_0member);
      }
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return cr0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass
discrete input Real cr_in[:] "Coefficients of real poles of base filter";
discrete input Real c0_in[:] "Coefficients of s^0 term of base filter if conjugate complex pole";
discrete input Real c1_in[size(c0_in, 1)] "Coefficients of s^1 term of base filter if conjugate complex pole";
discrete input Real f_cut(unit = "Hz") "Cut-off frequency";
discrete output Real r[size(cr_in, 1)] "Real eigenvalues";
discrete output Real a[size(c0_in, 1)] "Real parts of complex conjugate eigenvalues";
discrete output Real b[size(c0_in, 1)] "Imaginary parts of complex conjugate eigenvalues";
discrete output Real ku[size(c0_in, 1)] "Input gain";
protected 
discrete Real c0[size(c0_in, 1)];
discrete Real c1[size(c0_in, 1)];
discrete Real cr[size(cr_in, 1)];
public 
algorithm 
(cr, c0, c1)  := Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass(cr_in, c0_in, c1_in, f_cut);
for i in (1:size(cr_in, 1)) loop
r[i] :=  -cr[i];
end for;
for i in (1:size(c0_in, 1)) loop
a[i] :=  -c1[i]/2;
b[i] := sqrt(c0[i]-a[i]*a[i]);
ku[i] := c0[i]/b[i];
end for;
end Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealArray   crx_0in,
   RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass")
  AssertModelica(RealSize( c1x_0in,1)==RealSize( c0x_0in, 1),"size(c1_in, 1) == size(c0_in, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    r0_0;
    RealArray    a0_0;
    RealArray    b0_0;
    RealArray    ku0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    RealArray    cr0_0;
    MarkObject retmark_ = PushMark();
    r0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( r0_0, 0);
    a0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( a0_0, 0);
    b0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( b0_0, 0);
    ku0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( ku0_0, 0);
    c00_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    PushMark();
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    PushMark();
    RealFillAssign( c10_0, 0);
    cr0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    PushMark();
    RealFillAssign( cr0_0, 0);
    /* Start of real code */
      {
        struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
           dummy_mult_=Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass
          (crx_0in, c0x_0in, c1x_0in, fx_0cut);
        RealAssign (cr0_0, dummy_mult_.cr0_0_0member);
        RealAssign (c00_0, dummy_mult_.c00_0_0member);
        RealAssign (c10_0, dummy_mult_.c10_0_0member);
      }
      Release();
      {
        int end_ = RealSize( crx_0in, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement( -RealElement( cr0_0, (SizeType)(i0_0_0)), r0_0, 
            (SizeType)(i0_0_0));
        }
      }
      {
        int end_ = RealSize( c0x_0in, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement( -RealElement( c10_0, (SizeType)(i0_0_0))/(double)(2), 
            a0_0, (SizeType)(i0_0_0));
          SetRealElement(sqrtGuarded(RealElement( c00_0, (SizeType)(i0_0_0))-
            RealElement( a0_0, (SizeType)(i0_0_0))*RealElement( a0_0, (SizeType)
            (i0_0_0)),"c0[i]-a[i]*a[i]"), b0_0, (SizeType)(i0_0_0));
          SetRealElement(divmacro(RealElement( c00_0, (SizeType)(i0_0_0)),
            "c0[i]",RealElement( b0_0, (SizeType)(i0_0_0)),"b[i]"), ku0_0, 
            (SizeType)(i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct out_;
      out_.r0_0_0member = r0_0;
      out_.a0_0_0member = a0_0;
      out_.b0_0_0member = b0_0;
      out_.ku0_0_0member = ku0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1D.getTableValue
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol;
discrete input Real u;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real y;

external "C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u);
annotation(derivative(noDerivative=tableAvailable)=Modelica.Blocks.Tables.CombiTable1D.getDerTableValue, Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2015 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1D.getTableValue;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1D.getTableValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      extern double (ModelicaStandardTables_CombiTable1D_getValue)(void*, int , 
        double );
      y0_0 = (ModelicaStandardTables_CombiTable1D_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, u0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Types.ExternalCombiTable1D
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
output Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init(tableName, fileName, table, size(table, 1), size(table, 2), columns, size(columns, 1), smoothness);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2015 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Types.ExternalCombiTable1D;

  */
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTable1D0_0;
    externalCombiTable1D0_0.id_0member=0;
    /* Start of real code */
    {
      extern void* (ModelicaStandardTables_CombiTable1D_init)(const char* , 
        const char* , double  const *, size_t, size_t, int  const *, size_t, int );
      externalCombiTable1D0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTable1D_init)(tableName0_0, fileName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], columns0_0.data, 
        columns0_0.dims[1-1], smoothness0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTable1D0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Types.ExternalCombiTable1D.destructor
input Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2015 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Types.ExternalCombiTable1D.destructor;

  */
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      extern void (ModelicaStandardTables_CombiTable1D_close)(void*);
      (ModelicaStandardTables_CombiTable1D_close)(externalCombiTable1D0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.checkBoundary
input String mediumName;
input String substanceNames[:] "Names of substances";
input Boolean singleState;
input Boolean define_p;
discrete input Real X_boundary[:];
input String modelName(start = "??? boundary ???");
protected 
Integer nX(start = size(X_boundary, 1));
String X_str;
public 
algorithm 
assert( not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""+modelName+"\":
The selected medium \""+mediumName+"\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");
for i in (1:nX) loop
assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\":
The boundary value X_boundary("+       String(i, true, 0)+") = "+       String(X_boundary[i], true, 0)+"
is negative. It must be positive.
");
end for;
if (nX > 0 and abs(sum(X_boundary)-1.0) > 1E-010) then 
X_str := "";
for i in (1:nX) loop
X_str := X_str+"   X_boundary["+       String(i, true, 0)+"] = "+       String(X_boundary[i], true, 0)+" \""+substanceNames[i]+"\"\n";
end for;
ModelicaError("The boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\"\n"+"do not sum up to 1. Instead, sum(X_boundary) = "+       String(sum(X_boundary), true, 0)+":\n"+X_str);
end if;
end Modelica.Fluid.Utilities.checkBoundary;

  */
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Fluid.Utilities.checkBoundary")
  {
    /* Declare outputs and temporaries */
    int   nX0_0;
    const char*   Xx_0str;
    MarkObject retmark_ = PushMark();
    nX0_0 = RealSize( Xx_0boundary, 1);
    Xx_0str="";
    /* Start of real code */
      AssertModelica( NOT singleState0_0 OR singleState0_0 AND definex_0p,
        " not singleState or singleState and define_p", StringAdd(StringAdd(
        StringAdd(StringAdd("\nWrong value of parameter define_p (= false) in model \"",
        modelName0_0),"\":\nThe selected medium \""),mediumName0_0),
        "\" has Medium.singleState=true.\nTherefore, an boundary density cannot be defined and\ndefine_p = true is required.\n"));
      {
        int end_ = nX0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          AssertModelica(RealElement( Xx_0boundary, (SizeType)(i0_0_0)) >= 0.0,
            "X_boundary[i] >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
            StringAdd(StringAdd(StringAdd(StringAdd("\nWrong boundary mass fractions in medium \"",
            mediumName0_0),"\" in model \""),modelName0_0),"\":\nThe boundary value X_boundary("),
            Integer2String2(i0_0_0, true, 0)),") = "),Real2String2(RealElement( 
            Xx_0boundary, (SizeType)(i0_0_0)), true, 0)),"\nis negative. It must be positive.\n"));
        }
      }
      if (nX0_0 > 0 AND fabs(Realsum( Xx_0boundary)-1.0) > 1E-010) {
        Xx_0str = "";
        Release();
        {
          int end_ = nX0_0;
          int i0_0_0;
          for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
            Xx_0str = StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
              StringAdd(StringAdd(Xx_0str,"   X_boundary["),Integer2String2(
              i0_0_0, true, 0)),"] = "),Real2String2(RealElement( Xx_0boundary, 
              (SizeType)(i0_0_0)), true, 0))," \""),StringElement( 
              substanceNames0_0, (SizeType)(i0_0_0))),"\"\n");
          }
        }
        ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd(StringAdd("The boundary mass fractions in medium \"",
          mediumName0_0),"\" in model \""),modelName0_0),"\"\n"),
          "do not sum up to 1. Instead, sum(X_boundary) = "),Real2String2(
          Realsum( Xx_0boundary), true, 0)),":\n"),Xx_0str));
        Release();
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.cubicHermite
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower gradient";
discrete input Real y2d "Upper gradient";
discrete output Real y "Interpolated ordinate value";
protected 
discrete Real h "Distance between x1 and x2";
discrete Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
discrete Real h00 "Basis function 00 of cubic Hermite spline";
discrete Real h10 "Basis function 10 of cubic Hermite spline";
discrete Real h01 "Basis function 01 of cubic Hermite spline";
discrete Real h11 "Basis function 11 of cubic Hermite spline";
discrete Real aux3 "t cube";
discrete Real aux2 "t square";
public 
algorithm 
h := x2-x1;
if (abs(h) > 0) then 
t := (x-x1)/h;
aux3 := t^3;
aux2 := t^2;
h00 := 2*aux3-3*aux2+1;
h10 := aux3-2*aux2+t;
h01 := ( -2*aux3)+3*aux2;
h11 := aux3-aux2;
y := y1*h00+h*y1d*h10+y2*h01+h*y2d*h11;
else
y := (y1+y2)/2;
end if;
annotation(smoothOrder=3);
end Modelica.Fluid.Utilities.cubicHermite;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_cubicHermite(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0) {
  PushContext("Modelica.Fluid.Utilities.cubicHermite")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   h0_0;
    double   t0_0;
    double   h000_0;
    double   h100_0;
    double   h010_0;
    double   h110_0;
    double   aux30_0;
    double   aux20_0;
    y0_0=0;
    h0_0=0;
    t0_0=0;
    h000_0=0;
    h100_0=0;
    h010_0=0;
    h110_0=0;
    aux30_0=0;
    aux20_0=0;
    /* Start of real code */
      h0_0 = x20_0-x10_0;
      if (fabs(h0_0) > 0) {
        t0_0 = divmacro(x0_0-x10_0,"x-x1",h0_0,"h");
        aux30_0 = powmacro(t0_0,"t",3,"3");
        aux20_0 = sqr(t0_0);
        h000_0 = 2*aux30_0-3*aux20_0+1;
        h100_0 = aux30_0-2*aux20_0+t0_0;
        h010_0 = ( -2*aux30_0)+3*aux20_0;
        h110_0 = aux30_0-aux20_0;
        y0_0 = y10_0*h000_0+h0_0*y1d0_0*h100_0+y20_0*h010_0+h0_0*y2d0_0*h110_0;
      }
      else{
        y0_0 = (y10_0+y20_0)/(double)(2);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne
discrete input Real den1[:] "[s] coefficients of polynomials (den1[i]*s + 1)";
discrete input Real den2[:, 2] "[s^2, s] coefficients of polynomials (den2[i,1]*s^2 + den2[i,2]*s + 1)";
discrete output Real cr[size(den1, 1)] "[s^0] coefficients of polynomials cr[i]*(s+1/cr[i])";
discrete output Real c0[size(den2, 1)] "[s^0] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";
discrete output Real c1[size(den2, 1)] "[s^1] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";

algorithm 
for i in (1:size(den1, 1)) loop
cr[i] := 1/den1[i];
end for;
for i in (1:size(den2, 1)) loop
c1[i] := den2[i, 2]/den2[i, 1];
c0[i] := 1/den2[i, 1];
end for;
end Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
   Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne(
  RealArray   den10_0, RealArray   den20_0) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne")
  AssertModelica(RealSize( den20_0,2)==2,"size(den2, 2) == 2","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, RealSize( den10_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    c00_0=RealTemporary( 1, RealSize( den20_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( den20_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( c10_0, 0);
    /* Start of real code */
      {
        int end_ = RealSize( den10_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(divmacro(1,"1",RealElement( den10_0, (SizeType)(i0_0_0)),
            "den1[i]"), cr0_0, (SizeType)(i0_0_0));
        }
      }
      {
        int end_ = RealSize( den20_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(divmacro(RealElement( den20_0, (SizeType)(i0_0_0), 
            (SizeType)(2)),"den2[i, 2]",RealElement( den20_0, (SizeType)(i0_0_0),
             (SizeType)(1)),"den2[i, 1]"), c10_0, (SizeType)(i0_0_0));
          SetRealElement(divmacro(1,"1",RealElement( den20_0, (SizeType)(i0_0_0),
             (SizeType)(1)),"den2[i, 1]"), c00_0, (SizeType)(i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct out_;
      out_.cr0_0_0member = cr0_0;
      out_.c00_0_0member = c00_0;
      out_.c10_0_0member = c10_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass
discrete input Real cr_in[:] "Coefficients of real poles";
discrete input Real c0_in[:] "Coefficients of s^0 term if conjugate complex pole";
discrete input Real c1_in[size(c0_in, 1)] "Coefficients of s^1 term if conjugate complex pole";
discrete input Real f_cut(unit = "Hz") "Cut-off frequency";
discrete output Real cr[size(cr_in, 1)] "Coefficient of real pole";
discrete output Real c0[size(c0_in, 1)] "Coefficients of s^0 term if conjugate complex pole";
discrete output Real c1[size(c0_in, 1)] "Coefficients of s^1 term if conjugate complex pole";
protected 
constant Real pi = 3.141592653589793;
discrete Real w_cut(start = 2.0*(pi*f_cut), unit = "rad/s") "Cut-off angular frequency";
discrete Real w_cut2(start = w_cut*w_cut);
public 
algorithm 
assert(f_cut > 0, "Cut-off frequency f_cut must be positive");
cr := w_cut*cr_in;
c1 := w_cut*c1_in;
c0 := w_cut2*c0_in;
end Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass(RealArray   
  crx_0in, RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass")
  AssertModelica(RealSize( c1x_0in,1)==RealSize( c0x_0in, 1),"size(c1_in, 1) == size(c0_in, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    double   pi0_0;
    double   wx_0cut;
    double   wx_0cut2;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    c00_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( c10_0, 0);
    pi0_0 = 3.141592653589793;
    wx_0cut = 2.0*pi0_0*fx_0cut;
    wx_0cut2 = wx_0cut*wx_0cut;
    /* Start of real code */
      AssertModelica(fx_0cut > 0,"f_cut > 0", "Cut-off frequency f_cut must be positive");
      RealAssign (cr0_0, RealScale (crx_0in,wx_0cut));
      Release();
      RealAssign (c10_0, RealScale (c1x_0in,wx_0cut));
      Release();
      RealAssign (c00_0, RealScale (c0x_0in,wx_0cut2));
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct out_;
      out_.cr0_0_0member = cr0_0;
      out_.c00_0_0member = c00_0;
      out_.c10_0_0member = c10_0;
      return out_;
    }
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
BreakSectionFunctionDef(2)
BreakSectionFunctionDef(3)
BreakSectionFunctionDef(4)
#include <moutil.c>
PreNonAliasDef(0)
PreNonAliasDef(1)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="IDEAS.Fluid.HeatExchangers.Examples.Heater_T";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/ottelien/appdata/roaming/dynasim/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC long QJacobianCG_[13]={5 , 3 , 1 , 3 , 7 , 1 , 2 , 1 , 4 , 1 , 5
   , 1 , 6};
DYMOLA_STATIC long QJacobianGC_[36]={
1 , 1 , 3 , 7 , 0 , 0 , 7 , 0 , 2 , 2 , 2 , 2 , 2 , 0 , 0 , 0 , 4 , 4 , 4 , 0 , 0
   , 0 , 0 , 5 , 5 , 5 , 0 , 5 , 0 , 0 , 6 , 6 , 6 , 6 , 6 , 0};
DYMOLA_STATIC double QJacobianCD_[8]={0  , 44 , 50 , 66 , 63 , 64 , 63 , 110};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
W_[0] = 97.2;
W_[1] = 0.1944;
W_[9] = true;
W_[10] = false;
W_[11] = true;
W_[13] = 3;
W_[28] = 0.01;
W_[29] = 0.99;
W_[39] = false;
W_[46] = 4;
W_[47] = 4;
W_[51] = true;
W_[55] = 0.1944;
W_[57] = false;
W_[59] = 4;
W_[60] = 4;
W_[61] = 4;
W_[62] = 4;
W_[68] = true;
W_[69] = true;
W_[70] = true;
W_[72] = 2;
W_[74] = true;
W_[91] = true;
W_[98] = true;
W_[99] = false;
W_[103] = true;
W_[109] = false;
W_[110] = true;
W_[113] = true;
W_[143] = true;
W_[151] = true;
W_[155] = 1;
W_[156] = 1;
W_[157] = 2;
W_[160] = 2;
W_[163] = 2;
W_[164] = 0;
W_[165] = 0;
W_[166] = 2;
W_[178] = 2;
W_[182] = 1;
W_[194] = true;
W_[195] = false;
W_[199] = 1;
W_[207] = false;
W_[211] = 0.01801528;
W_[212] = 0.0289651159;
W_[218] = 3;
W_[222] = true;
W_[239] = true;
W_[241] = 0.1944;
W_[243] = false;
W_[247] = 1000;
W_[256] = true;
W_[258] = 0.1944;
W_[260] = false;
W_[263] = 1000;
W_[268] = 0.1944;
W_[269] = 1000;
W_[274] = true;
W_[281] = false;
W_[282] = false;
W_[300] = true;
W_[301] = 4;
W_[310] = 1;
W_[333] = true;
W_[334] = true;
W_[335] = 3;
W_[348] = false;
W_[352] = 0.01801528;
W_[353] = 0.0289651159;
DYNSetAuxString("water", 2);
DYNSetAuxString("air", 3);
W_[379] = true;
W_[384] = false;
W_[386] = true;
W_[387] = true;
W_[388] = true;
W_[8] = 2;
W_[152] = 4;
W_[248] = false;
W_[249] = 0.1;
W_[3] = 2;
W_[4] = 2;
W_[5] = 2;
W_[6] = 2;
W_[12] = 0.1944;
W_[14] = 1.944E-005;
W_[15] = true;
W_[16] = 97.2;
W_[30] = 101325.0;
W_[31] = 293.15;
W_[32] = 0.01;
W_[33] = 0.99;
W_[34] = 1.2;
W_[40] = 0;
W_[48] = 4;
W_[49] = 4;
W_[50] = 1;
W_[54] = false;
W_[56] = 1.944E-005;
W_[67] = 1;
W_[71] = 0.1944;
W_[73] = 1.944E-005;
W_[82] = 101325.0;
W_[86] = 1.2;
W_[83] = 293.15;
W_[84] = 0.01;
W_[85] = 0.99;
W_[94] = 0;
W_[105] = false;
W_[106] = false;
W_[108] = 1.944E-005;
W_[120] = false;
W_[121] = true;
W_[147] = 101325.0;
W_[122] = 1.2;
W_[146] = 0.162;
W_[139] = 0.000162;
W_[145] = 101325;
W_[148] = 293.15;
W_[149] = 0.01;
W_[150] = 0.99;
W_[159] = 4;
W_[162] = 0.1944;
W_[179] = 5;
W_[180] = true;
W_[181] = false;
W_[192] = false;
W_[193] = true;
W_[197] = 0.1944;
W_[208] = true;
W_[219] = true;
W_[221] = true;
W_[226] = 0.1944;
W_[227] = 1.944E-005;
W_[229] = 3;
W_[233] = false;
W_[242] = 1.944E-005;
W_[245] = true;
W_[246] = false;
W_[252] = 2;
W_[253] = true;
W_[259] = 1.944E-005;
W_[262] = false;
W_[264] = true;
W_[265] = false;
W_[273] = true;
W_[270] = false;
W_[271] = 0.1;
W_[266] = 0.01944;
W_[272] = 0.00614746777136733;
W_[277] = false;
W_[278] = false;
W_[279] = 0;
W_[280] = 1.944E-005;
W_[286] = 0.1944;
W_[289] = 2;
W_[302] = 0.0;
W_[304] = 0.0;
W_[306] = 0.0;
W_[308] = 0.0;
DYNSetAuxString("NoName", 0);
DYNSetAuxString("NoName", 1);
W_[320] = 2;
W_[324] = 2;
W_[325] = 2;
W_[326] = 2;
W_[327] = 2;
W_[332] = 2.0;
W_[349] = true;
W_[360] = 97.2;
W_[372] = 101325.0;
W_[376] = 1.2;
W_[374] = 0.01;
W_[369] = 1014.54;
W_[361] = 118335.94559999999;
W_[371] = true;
W_[373] = 293.15;
W_[375] = 0.99;
W_[377] = 1;
W_[382] = 0.1944;
W_[383] = 1.944E-005;
W_[391] = 1;
W_[394] = 1.944E-008;
W_[395] = 51440329.21810699;
W_[396] = -771604938.2716049;
W_[397] = 3.1488678893800064E+017;
W_[398] = -4.913810682583697E+025;
W_[399] = 3.7390064528397536E+033;
W_[400] = -1.368681174071672E+041;
W_[401] = 1.9268849104322865E+048;
W_[403] = 3;
W_[2] = 1080;
W_[228] = 1;
W_[251] = 0;
W_[311] = false;
W_[321] = 1;
W_[171] = 1.0;
W_[45] = 0;
W_[357] = 0.0;
W_[22] = 0.0;
W_[41] = 0;
W_[283] = 0;
W_[95] = 0;
W_[114] = 0;
W_[385] = 0.0;
W_[357] = 0.0;
W_[357] = 0.0;
W_[7] = 101325;
W_[220] = 101325;
W_[223] = 101325.0;
W_[224] = 101325.0;
W_[200] = 101325.0;
W_[206] = 101325.0;
W_[215] = 0.0;
W_[216] = 101325.0;
W_[154] = 0.1944;
W_[101] = 0.0;
W_[153] = 0.1944;
W_[52] = 101325.0;
W_[104] = 101325.0;
W_[93] = 0.0;
W_[78] = 0.0;
W_[79] = 101325.0;
W_[76] = 101325.0;
W_[77] = 101325.0;
W_[389] = 0.0;
W_[390] = 0.0;
W_[393] = 0.0;
W_[380] = 101325.0;
W_[381] = 101325.0;
W_[275] = 101325.0;
W_[276] = 101325.0;
W_[240] = 101325.0;
W_[257] = 101325.0;
W_[198] = 0.1944;
W_[362] = 0.0;
W_[358] = 0.0;
W_[340] = 101325.0;
W_[347] = 101325.0;
W_[336] = 101325.0;
W_[337] = 101325.0;
W_[338] = 0.0;
W_[339] = 101325.0;
W_[26] = 101325.0;
W_[18] = 101325.0;
W_[21] = 101325.0;
W_[23] = 101325.0;
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
BoundParameterSection
AssertModelica(DP_[24] > 0,"fan.filter.A_ripple > 0", "A_ripple > 0 required");
AssertModelica(DP_[38] >= DP_[39],"conPI.yMax >= conPI.yMin", StringAdd(
  StringAdd(StringAdd(StringAdd("LimPID: Limits must be consistent. However, yMax (=",
  Real2String2(DP_[38], true, 0)),") < yMin (="),Real2String2(DP_[39], true, 0)),
  ")"));
PopAllMarks();
AssertModelica(DP_[54] >= 200.0 AND DP_[54] <= 423.15,"bou.T >= 200.0 and bou.T <= 423.15",
   StringAdd(StringAdd(StringAdd(StringAdd("\nTemperature T is not in the allowed range\n200.0 K <= (T =",
  Real2String2(DP_[54], true, 0))," K) <= 423.15 K\nrequired from medium model \""),
  "Air"),"\"."));
PopAllMarks();
W_[35] = W_[7];
W_[27] = 1.1843079200592153E-005*W_[35];
W_[36] = DP_[0];
W_[37] = DP_[1];
W_[38] = 1-DP_[1];
W_[44] = W_[2]/(double)(20);
W_[63] = DP_[3];
W_[64] = DP_[4];
W_[65] = DP_[5];
W_[66] = DP_[6];
W_[96] = DP_[9];
W_[97] = divmacro(W_[71]*W_[96],"fan.vol.m_flow_nominal*fan.vol.tau",W_[86],
  "fan.vol.rho_default");
W_[75] = W_[97];
W_[87] = W_[63];
W_[81] = 1.1843079200592153E-005*W_[87];
W_[88] = W_[64];
W_[89] = W_[65];
W_[90] = 1-W_[65];
W_[107] = DP_[22];
W_[115] = DP_[3];
W_[116] = DP_[4];
W_[117] = DP_[5];
W_[118] = DP_[6];
W_[119] = 1006.0*(W_[116]-273.15)*(1-W_[117])+(2501014.5+1860*(W_[116]-273.15))*
  W_[117];
W_[131] = DP_[13];
W_[132] = DP_[14];
W_[133] = DP_[15];
W_[134] = DP_[16];
W_[135] = DP_[17];
W_[136] = DP_[18];
W_[137] = DP_[19];
W_[138] = DP_[20];
W_[158] = divmacro(5,"5",6.283185307179586*DP_[21],"6.283185307179586*fan.riseTime");
W_[161] = DP_[22];
W_[196] = IF DP_[52] THEN -1 ELSE 1;
W_[184] = W_[196]*DP_[40];
W_[185] =  -W_[196];
W_[187] = DP_[35];
W_[190] = DP_[38];
W_[191] = DP_[39];
W_[231] = W_[228] > 1E-010 OR W_[228] < -1E-010;
W_[234] = IF DP_[63] < 1E-010 THEN 0 ELSE divmacro(1,"1",DP_[63],
  "THeaOut.tauHeaTra");
W_[235] = IF W_[228] < 1E-010 THEN 0 ELSE divmacro(1,"1",W_[228],"THeaOut.tau");
W_[250] = W_[2];
W_[267] = 3.88335940547E-006+4.89493640395E-008*DP_[73];
W_[284] = W_[250];
W_[285] = W_[251];
W_[287] = DP_[67];
W_[288] = DP_[68];
W_[290] = NotEqual(W_[284], 1E+060, 0);
W_[291] = NotEqual(W_[285], -1E+060, 1);
W_[292] = 0.01*DP_[80]*W_[280];
W_[293] = W_[287] > 1E-010 OR W_[287] < -1E-010;
W_[303] = DP_[85];
W_[305] = DP_[85];
W_[307] = DP_[85];
W_[309] = DP_[85];
W_[312] = DP_[81]+W_[302]-1;
W_[313] = DP_[82]+W_[303];
W_[314] = DP_[81]+W_[304];
W_[315] = DP_[82]+W_[305];
W_[316] = DP_[83]+W_[306];
W_[317] = DP_[84]+W_[307];
W_[318] = 1.0+DP_[83]+W_[308];
W_[319] = DP_[84]+W_[309];
W_[328] = W_[7];
W_[329] = DP_[0];
W_[330] = DP_[1];
W_[331] = DP_[2];
W_[370] = 1.1843079200592153E-005*W_[328];
W_[378] = 1006.0*(W_[329]-273.15)*(1-W_[330])+(2501014.5+1860*(W_[329]-273.15))*
  W_[330];
W_[402] = divmacro(1,"1",DP_[36],"conPI.Ti");
W_[404] = DP_[44];
W_[406] = W_[196];
W_[407] =  -W_[196];
W_[410] = divmacro(1,"1",DP_[35]*DP_[42],"conPI.k*conPI.Ni");
Aux_[13] = DP_[56];
W_[341] = 1.1843079200592153E-005*W_[220];
W_[356] = 97.2*W_[341];
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", tab.tab.table, tab.tab.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &W_[312], 2, 4, 2), IntegerTemporaryDense( &W_[320], 1, 1),
     1, 0, 1));
  W_[322] = dummy_DymStruc0.id_0member;
PopAllMarks();
}
W_[173] = 0.01*DP_[31]*DP_[30];
W_[214] = DP_[54]-273.15;
W_[213] = 1-DP_[56];
W_[217] = W_[214]*1006*W_[213]+(2501014.5+W_[214]*1860)*DP_[56];
Aux_[12] = W_[217];
W_[102] = 1.1843079200592153E-005*W_[220];
W_[201] = 1.1843079200592153E-005*W_[220];
W_[202] = 1-DP_[56];
W_[203] = W_[217]-84437.5;
W_[204] = 287.0512249529787*W_[213]+461.5233290850878*DP_[56];
W_[205] = divmacro(1,"1",55.508435061791985*DP_[56]+34.52428788658843*(1.0-
  DP_[56]),"55.508435061791985*bou.X[1]+34.52428788658843*(1.0-bou.X[1])");
W_[209] = DP_[54]-273.15;
W_[210] = 1E-005*W_[220];
W_[351] = 1E-005*W_[220];
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
W_[17] = 0;
W_[43] = 288.15;
W_[58] = 0;
W_[92] = 45300.945;
W_[144] = 1;
W_[230] = 1;
W_[237] = 293.15;
W_[238] = 293.15;
W_[244] = 0;
W_[261] = 0;
W_[298] = 1;
W_[345] = 1000.0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
W_[19] = W_[119];
W_[20] = W_[330];
W_[24] = DP_[0];
W_[53] = DP_[3];
W_[100] = W_[64];
W_[111] = DP_[11];
W_[236] = DP_[61];
W_[342] = W_[329];
W_[343] = W_[331];
X_[2] = DP_[61];
X_[4] = 97.2*W_[370]*(1006.0*(W_[329]-273.15)*(1-W_[330])+(2501014.5+1860*(
  W_[329]-273.15))*W_[330]-84437.5)+118335.94559999999*(W_[329]-273.15);
X_[6] = W_[404];
InitialSection
DefaultSection
InitializeData(0)
InitialSection
Aux_[18] = W_[174];
Aux_[19] = W_[175];
InitialSection
InitialSection2
F_[0] = 0.0;
W_[35] = W_[7];
W_[27] = 1.1843079200592153E-005*W_[35];
W_[36] = DP_[0];
W_[37] = DP_[1];
W_[38] = 1-DP_[1];
W_[44] = W_[2]/(double)(20);
W_[63] = DP_[3];
W_[64] = DP_[4];
W_[65] = DP_[5];
W_[66] = DP_[6];
W_[96] = DP_[9];
W_[97] = divmacro(W_[71]*W_[96],"fan.vol.m_flow_nominal*fan.vol.tau",W_[86],
  "fan.vol.rho_default");
W_[75] = W_[97];
W_[87] = W_[63];
W_[81] = 1.1843079200592153E-005*W_[87];
W_[88] = W_[64];
W_[89] = W_[65];
W_[90] = 1-W_[65];
W_[107] = DP_[22];
W_[115] = DP_[3];
W_[116] = DP_[4];
W_[117] = DP_[5];
W_[118] = DP_[6];
W_[119] = 1006.0*(W_[116]-273.15)*(1-W_[117])+(2501014.5+1860*(W_[116]-273.15))*
  W_[117];
W_[131] = DP_[13];
W_[132] = DP_[14];
W_[133] = DP_[15];
W_[134] = DP_[16];
W_[135] = DP_[17];
W_[136] = DP_[18];
W_[158] = divmacro(5,"5",6.283185307179586*DP_[21],"6.283185307179586*fan.riseTime");
AssertModelica(W_[158] > 0,"fan.filter.f_cut > 0", "f_cut > 0 required");
W_[161] = DP_[22];
W_[196] = IF DP_[52] THEN -1 ELSE 1;
W_[184] = W_[196]*DP_[40];
W_[185] =  -W_[196];
W_[187] = DP_[35];
W_[190] = DP_[38];
W_[191] = DP_[39];
AssertModelica(W_[190] >= W_[191],"conPI.limiter.uMax >= conPI.limiter.uMin", 
  StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(W_[190], true, 0)),") < uMin (="),Real2String2(W_[191], true, 0)),
  ")"));
PopAllMarks();
W_[234] = IF DP_[63] < 1E-010 THEN 0 ELSE divmacro(1,"1",DP_[63],
  "THeaOut.tauHeaTra");
W_[235] = IF W_[228] < 1E-010 THEN 0 ELSE divmacro(1,"1",W_[228],"THeaOut.tau");
W_[250] = W_[2];
W_[267] = 3.88335940547E-006+4.89493640395E-008*DP_[73];
W_[284] = W_[250];
W_[285] = W_[251];
W_[287] = DP_[67];
AssertModelica(W_[287] > 1E-005,"hea.heaCoo.tau > 1E-005", "Time constant tau is unreasonably small for dynamic balance. Check model parameters.");
W_[288] = DP_[68];
W_[292] = 0.01*DP_[80]*W_[280];
W_[303] = DP_[85];
W_[305] = DP_[85];
W_[307] = DP_[85];
W_[309] = DP_[85];
W_[312] = DP_[81]+W_[302]-1;
W_[313] = DP_[82]+W_[303];
W_[314] = DP_[81]+W_[304];
W_[315] = DP_[82]+W_[305];
W_[316] = DP_[83]+W_[306];
W_[317] = DP_[84]+W_[307];
W_[318] = 1.0+DP_[83]+W_[308];
W_[319] = DP_[84]+W_[309];
W_[328] = W_[220];
W_[329] = DP_[0];
W_[330] = DP_[1];
W_[331] = DP_[2];
W_[370] = 1.1843079200592153E-005*W_[328];
W_[378] = 1006.0*(W_[329]-273.15)*(1-W_[330])+(2501014.5+1860*(W_[329]-273.15))*
  W_[330];
W_[402] = divmacro(1,"1",DP_[36],"conPI.Ti");
W_[404] = DP_[44];
W_[406] = W_[196];
W_[407] =  -W_[196];
W_[410] = divmacro(1,"1",DP_[35]*DP_[42],"conPI.k*conPI.Ni");
W_[137] = DP_[19];
W_[138] = DP_[20];
W_[231] = W_[228] > 1E-010 OR W_[228] < -1E-010;
W_[290] = NotEqual(W_[284], 1E+060, 0);
W_[291] = NotEqual(W_[285], -1E+060, 1);
W_[293] = W_[287] > 1E-010 OR W_[287] < -1E-010;
  RealAssign (RealTemporaryDense( &W_[140], 1, 1), RealConvertInteger (IF 
    W_[138] THEN IntegerFill( 0, 1, (SizeType)(1)) ELSE IntegerTemporaryDense( 
    DymArrays0, 1, 1)));
  PopAllMarks();
  RealAssign (RealTemporaryDense( &W_[141], 1, 1), RealConvertInteger (IF 
    W_[138] THEN IntegerFill( 0, 1, (SizeType)(1)) ELSE IntegerTemporaryDense( 
    DymArrays0, 1, 1)));
  PopAllMarks();
RealAssign (RealTemporaryDense( &W_[167], 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping(2, fan.filter.normalized)")
  Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping(2, DP_[26])));
PopAllMarks();
{
  struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
     dummy_mult_=(PushModelContext(1,"Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass(fan.filter.cr, fan.filter.c0, fan.filter.c1, fan.filter.f_cut)")
    Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealTemporaryDense( 
    &W_[167], 1, 2), RealTemporaryDense( (Real*)(0), 1, 0), RealTemporaryDense( 
    (Real*)(0), 1, 0), W_[158]));
  RealAssign (RealTemporaryDense( &W_[169], 1, 2), dummy_mult_.r0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.a0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.b0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.ku0_0_0member);
}
PopAllMarks();
W_[323] = 0.0;
  {
    W_[323] = 1.0;
  }
  W_[175] = real2integerEvent(divmacro(Time-DP_[34],"time-TSet.startTime",
    DP_[31],"TSet.period"),"(time-TSet.startTime)/TSet.period", 2);
  W_[174] = DP_[34]+W_[175]*DP_[31];
InitialSection
Aux_[13] = DP_[56];
InitialSection2
W_[341] = 1.1843079200592153E-005*W_[220];
W_[356] = 97.2*W_[341];
W_[173] = 0.01*DP_[31]*DP_[30];
W_[214] = DP_[54]-273.15;
W_[213] = 1-DP_[56];
W_[217] = W_[214]*1006*W_[213]+(2501014.5+W_[214]*1860)*DP_[56];
InitialSection
Aux_[12] = W_[217];
InitialSection2
W_[102] = 1.1843079200592153E-005*W_[220];
W_[201] = 1.1843079200592153E-005*W_[220];
W_[202] = 1-DP_[56];
AssertModelica(W_[202] >= -1E-005 AND W_[202] <= 1.00001,"bou.medium.X[2] >= -1E-005 and bou.medium.X[2] <= 1.00001",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Mass fraction X[2] = ",
  Real2String2(W_[202], true, 0)),"of substance "),"air"),"\nof medium "),"Air"),
  " is not in the range 0..1"));
PopAllMarks();
W_[203] = W_[217]-84437.5;
W_[204] = 287.0512249529787*W_[213]+461.5233290850878*DP_[56];
W_[205] = divmacro(1,"1",55.508435061791985*DP_[56]+34.52428788658843*(1.0-
  DP_[56]),"55.508435061791985*bou.X[1]+34.52428788658843*(1.0-bou.X[1])");
W_[209] = DP_[54]-273.15;
W_[210] = 1E-005*W_[220];
W_[351] = 1E-005*W_[220];
InitialSection
Aux_[18] = W_[174];
InitialSection2
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
helpvar[0] =  -W_[169];
X_[0] = 0.0;
SolveScalarLinearParametric(helpvar[0]," -fan.filter.r[1]", helpvar[0],
  " -fan.filter.r[1]", X_[0],"fan.filter.x[1]");
 /* End of Equation Block */ 

W_[17] = W_[161];
 /* Linear system of equations to solve. */
X_[1] = 0.0;
SolveScalarLinearParametric((-0.1944)*DP_[23],"(-0.1944)*fan.filter.gain",  -
  W_[17]," -vol.ports[1].m_flow", X_[1],"fan.filter.x[2]");
 /* End of Equation Block */ 

W_[20] = W_[330];
AssertModelica(GreaterEqual(W_[20],"vol.ports[1].Xi_outflow[1]", -1E-005,
  "-1E-005", 3) AND LessEqual(W_[20],"vol.ports[1].Xi_outflow[1]", 1.00001,
  "1.00001", 4),"vol.ports[1].Xi_outflow[1] >= -1E-005 and vol.ports[1].Xi_outflow[1] <= 1.00001",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Mass fraction X[1] = ",
  Real2String2(W_[20], true, 0)),"of substance "),"water"),"\nof medium "),"Air"),
  " is not in the range 0..1"));
PopAllMarks();
X_[5] = W_[356]*W_[20];
X_[3] = W_[288];
W_[342] = W_[329];
AssertModelica(GreaterEqual(W_[342],"vol.dynBal.medium.T", 200.0,"200.0", 5)
   AND LessEqual(W_[342],"vol.dynBal.medium.T", 423.15,"423.15", 6),
  "vol.dynBal.medium.T >= 200.0 and vol.dynBal.medium.T <= 423.15", StringAdd(
  StringAdd(StringAdd(StringAdd("\nTemperature T is not in the allowed range\n200.0 K <= (T =",
  Real2String2(W_[342], true, 0))," K) <= 423.15 K\nrequired from medium model \""),
  "Air"),"\"."));
PopAllMarks();
W_[355] = W_[342]-273.15;
W_[354] = 1-W_[20];
W_[19] = W_[355]*1006*W_[354]+(2501014.5+W_[355]*1860)*W_[20];
W_[344] = W_[19]-84437.5;
X_[4] = 118335.94559999999*(W_[342]+8.450517676008667E-006*(W_[356]*W_[344]-
  32323463.540639997));
X_[6] = W_[404];
X_[2] = DP_[61];
InitialSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", tab.tab.table, tab.tab.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &W_[312], 2, 4, 2), IntegerTemporaryDense( &W_[320], 1, 1),
     1, 0, 1));
  W_[322] = dummy_DymStruc0.id_0member;
PopAllMarks();
}
Aux_[19] = W_[175];
InitialSection2
W_[261] = homotopy((PushModelContext(1,"IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(vol.ports[1].m_flow, 0.00614746777136733, 0.01944)")
  IF W_[17] > 0.01944 THEN sqr(162.6686039181265*W_[17]) ELSE IF W_[17] < 
  -0.01944 THEN  -sqr(162.6686039181265*W_[17]) ELSE 13230.53735033616*(0.01944*
  W_[17]+51.440329218106996*powmacro(W_[17],"vol.ports[1].m_flow",3,"3"))), 
  5144.0329218107*W_[17]);
PopModelContext();
W_[53] = W_[261]+W_[220];
W_[58] = W_[220]-W_[53];
W_[130] = divmacro(W_[17],"vol.ports[1].m_flow",W_[102],"fan.rho_in");
W_[125] =  -W_[58]*W_[130];
W_[128] = (PushModelContext(1,"IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency(\nfan.per.hydraulicEfficiency, \nfan.VMachine_flow, \nfan.hydDer, \n1, \n0.0001)")
  IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc1_construct(
  RealTemporaryDense( &DP_[13], 1, 1), RealTemporaryDense( &DP_[14], 1, 1)), 
  W_[130], RealTemporaryDense( &W_[141], 1, 1), 1, 0.0001));
PopAllMarks();
W_[129] = (PushModelContext(1,"IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency(\nfan.per.motorEfficiency, \nfan.VMachine_flow, \nfan.motDer, \n1, \n0.0001)")
  IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc1_construct(
  RealTemporaryDense( &DP_[15], 1, 1), RealTemporaryDense( &DP_[16], 1, 1)), 
  W_[130], RealTemporaryDense( &W_[140], 1, 1), 1, 0.0001));
PopAllMarks();
W_[127] = W_[128]*W_[129];
W_[123] = divmacro(W_[125],"fan.WFlo",(PushModelContext(1,"IDEAS.Utilities.Math.Functions.spliceFunction(fan.eta, 1E-005, fan.eta-1E-005, 1E-006)")
  IDEAS_Utilities_Math_Functions_spliceFunction(W_[127], 1E-005, W_[127]-1E-005,
   1E-006)),"IDEAS.Utilities.Math.Functions.spliceFunction(fan.eta, 1E-005, fan.eta-1E-005, 1E-006)");
PopModelContext();
 /* Linear system of equations to solve. */
W_[124] = 0.0;
SolveScalarLinear(W_[128],"fan.etaHyd", W_[125],"fan.WFlo", W_[124],"fan.WHyd");
 /* End of Equation Block */ 

W_[142] = (IF W_[137] THEN W_[123] ELSE W_[124])-W_[125];
W_[126] = homotopy((PushModelContext(1,"IDEAS.Utilities.Math.Functions.spliceFunction(fan.QThe_flow, 0, noEvent(abs(fan.VMachine_flow))-0.000324, 0.000162)")
  IDEAS_Utilities_Math_Functions_spliceFunction(W_[142], 0, fabs(W_[130])-
  0.000324, 0.000162)), 0);
PopModelContext();
InitialSection
Init=false;InitializeData(2);Init=true;
InitialSection2
AssertModelica(fabs(Realsum( RealTemporaryDense( &W_[377], 1, 1))-1) < 1E-005,
  "abs(sum(vol.dynBal.s)-1) < 1E-005", "If Medium.nXi > 1, then substance 'water' must be present for one component.'Air'.\nCheck medium model.");
PopAllMarks();
AssertModelica(fabs(Realsum( RealTemporaryDense( &W_[391], 1, 1))-1) < 1E-005,
  "abs(sum(fan.vol.steBal.s)-1) < 1E-005", "If Medium.nXi > 1, then substance 'water' must be present for one component.'Air'.\nCheck medium model.");
PopAllMarks();
AssertModelica(DP_[56] >= -1E-005 AND DP_[56] <= 1.00001,"bou.X[1] >= -1E-005 and bou.X[1] <= 1.00001",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Mass fraction X[1] = ",
  Real2String2(DP_[56], true, 0)),"of substance "),"water"),"\nof medium "),
  "Air")," is not in the range 0..1"));
PopAllMarks();
EndInitialSection

OutputSection
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"Air\", {\"water\", \"air\"}, false, bou.use_p, bou.X, \"FixedBoundary\")")
  Modelica_Fluid_Utilities_checkBoundary("Air", StringTemporaryDense( DymArrays1,
   1, 2), false, W_[219], RealTemporaryDense( &DP_[56], 1, 2), "FixedBoundary"));
PopAllMarks();

DynamicsSection
F_[0] = W_[169]*(X_[0]-1.0);
F_[1] = W_[170]*(X_[1]-X_[0]);
W_[17] = 0.1944*DP_[23]*X_[1];
 /* Linear system of equations to solve. */
W_[20] = RememberSimple_(W_[20], 0);
SolveScalarLinearParametric( -W_[356]," -vol.dynBal.m",  -X_[5]," -vol.dynBal.mXi[1]",
   W_[20],"vol.ports[1].Xi_outflow[1]");
 /* End of Equation Block */ 

AssertModelica(GreaterEqual(W_[20],"vol.ports[1].Xi_outflow[1]", -1E-005,
  "-1E-005", 3) AND LessEqual(W_[20],"vol.ports[1].Xi_outflow[1]", 1.00001,
  "1.00001", 4),"vol.ports[1].Xi_outflow[1] >= -1E-005 and vol.ports[1].Xi_outflow[1] <= 1.00001",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Mass fraction X[1] = ",
  Real2String2(W_[20], true, 0)),"of substance "),"water"),"\nof medium "),"Air"),
  " is not in the range 0..1"));
PopAllMarks();
W_[366] = W_[20]*W_[17];
W_[367] =  -W_[20]*W_[17];
F_[5] = W_[366]+W_[367];
BreakSectionFunctionEnd()
BreakSectionFunctionStart(2);
beginwhenBlock
helpvar[1] = divmacro(1.0,"1.0",DP_[31],"TSet.period");
helpvar[2] = real2integer(helpvar[1]*(Time-DP_[34]));
whenModelica(real2integerEvent(divmacro(Time-DP_[34],"time-TSet.startTime",
  DP_[31],"TSet.period"),"(time-TSet.startTime)/TSet.period", 2) > PRE(W_[175], 0),
   0) 
  W_[175] = PRE(W_[175], 0)+1;
  W_[174] = Time;
endwhenModelica()
endwhenBlock

W_[172] = DP_[33]+(IF LessTime(DP_[34], 0) OR DP_[32] == 0 OR DP_[32] > 0 AND 
  W_[175] >= DP_[32] THEN 0 ELSE IF LessTime(W_[174]+W_[173], 1) THEN DP_[29]
   ELSE 0);
W_[354] = 1-W_[20];
BreakSectionFunctionEnd()
BreakSectionFunctionStart(3);
 /* Linear system of equations to solve. */
/* Introducing 2 common subexpressions used in 1 expressions */
/* Of the common subexpressions 2 are reals, 0 are integers, and 0
   are booleans. */
helpvar[3] = (1006.0*W_[354]+1860.0*W_[20])*W_[356];
helpvar[4] = W_[356]*W_[20];
W_[342] = RememberSimple_(W_[342], 1);
SolveScalarLinear((-118335.94559999999)-helpvar[3],"(-118335.94559999999)-(1006.0*vol.dynBal.medium.X_air+1860.0*vol.ports[1].Xi_outflow[1])*vol.dynBal.m",
   (-32323463.540639997)-(X_[4]+273.15*helpvar[3]-2501014.5*helpvar[4]+84437.5*
  W_[356]),"(-32323463.540639997)-(vol.dynBal.U+273.15*((1006.0*vol.dynBal.medium.X_air+1860.0*vol.ports[1].Xi_outflow[1])*vol.dynBal.m)-2501014.5*(vol.dynBal.m*vol.ports[1].Xi_outflow[1])+84437.5*vol.dynBal.m)",
   W_[342],"vol.dynBal.medium.T");
W_[355] = W_[342]-273.15;
W_[19] = W_[355]*1006*W_[354]+(2501014.5+W_[355]*1860)*W_[20];
W_[344] = W_[19]-84437.5;
 /* End of Equation Block */ 

AssertModelica(GreaterEqual(W_[342],"vol.dynBal.medium.T", 200.0,"200.0", 5)
   AND LessEqual(W_[342],"vol.dynBal.medium.T", 423.15,"423.15", 6),
  "vol.dynBal.medium.T >= 200.0 and vol.dynBal.medium.T <= 423.15", StringAdd(
  StringAdd(StringAdd(StringAdd("\nTemperature T is not in the allowed range\n200.0 K <= (T =",
  Real2String2(W_[342], true, 0))," K) <= 423.15 K\nrequired from medium model \""),
  "Air"),"\"."));
PopAllMarks();
BreakSectionFunctionEnd()
BreakSectionFunctionStart(4);
W_[24] = 273.15+divmacro(W_[19]-2501014.5*W_[20],"vol.ports[1].h_outflow-2501014.5*vol.ports[1].Xi_outflow[1]",1006
  *(1-W_[20])+1860*W_[20],"1006*(1-vol.ports[1].Xi_outflow[1])+1860*vol.ports[1].Xi_outflow[1]");
W_[183] = W_[184]*W_[172]+W_[185]*W_[24];
W_[186] = DP_[47]*W_[183];
W_[188] = DP_[48]*W_[186]+DP_[49]*DP_[51]+DP_[50]*X_[6];
W_[189] = W_[187]*W_[188];
W_[176] = IF GreaterS(W_[189],"conPI.gainPID.y", W_[190],"conPI.limiter.uMax", 7)
   THEN W_[190] ELSE IF LessS(W_[189],"conPI.gainPID.y", W_[191],
  "conPI.limiter.uMin", 8) THEN W_[191] ELSE W_[189];
W_[254] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getTableValue(\ntab.tab.tableID, \n1, \nconPI.y, \ntab.tab.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(DymStruc0_construct(
  (Integer)(W_[322])), 1, W_[176], W_[323]));
PopModelContext();
W_[299] = 5.1440329218107*W_[17];
W_[298] = IF W_[17] > 1.944E-005 THEN W_[299] ELSE IF W_[17] < -1.944E-005 THEN 
   -W_[299] ELSE (-25720.164609053496)*W_[17]*(sqr(51440.32921810699*W_[17])-3)*
  W_[299];
F_[3] = divmacro((W_[254]-X_[3])*W_[298],"(hea.TSet-hea.heaCoo.T)*hea.heaCoo.k",
  W_[287],"hea.heaCoo.tau");
W_[296] = 1006.0*(X_[3]-273.15)*(1-W_[20])+(2501014.5+1860*(X_[3]-273.15))*
  W_[20];
W_[295] = (PushModelContext(1,"IDEAS.Utilities.Math.Functions.spliceFunction(vol.ports[1].m_flow, 1.944E-005, vol.ports[1].m_flow-1.944E-005, 9.72E-006)")
  IDEAS_Utilities_Math_Functions_spliceFunction(W_[17], 1.944E-005, W_[17]-
  1.944E-005, 9.72E-006));
PopModelContext();
helpvar[5] = divmacro(1.0,"1.0",W_[295],"hea.heaCoo.m_flow_limited");
W_[297] = (PushModelContext(1,"IDEAS.Utilities.Math.Functions.smoothLimit(hea.heaCoo.hSet-vol.ports[1].h_outflow, 0.0, 1080/hea.heaCoo.m_flow_limited, hea.heaCoo.deltah)")
  IDEAS_Utilities_Math_Functions_smoothLimit(W_[296]-W_[19], 0.0, helpvar[5]*1080,
   W_[292]));
PopModelContext();
W_[225] = W_[19]+W_[297];
helpvar[6] = W_[17] >= 0;
W_[363] = IF helpvar[6] THEN W_[225]*W_[17] ELSE W_[19]*W_[17];
W_[364] =  -W_[19]*W_[17];
W_[359] = W_[363]+W_[364];
helpvar[7] = cos(7.27220521664304E-005*Time);
W_[43] = 289.15-5*helpvar[7];
W_[42] = W_[43]-W_[24];
W_[25] = W_[44]*W_[42];
F_[4] = W_[359]+W_[25];
W_[409] = DP_[91]*W_[176]+DP_[92]*W_[189];
W_[408] = W_[410]*W_[409];
W_[405] = W_[406]*W_[172]+W_[407]*W_[24]+DP_[90]*W_[408];
F_[6] = W_[402]*W_[405];
W_[237] = 273.15+divmacro(W_[225]-2501014.5*W_[20],"THeaOut.port_b.h_outflow-2501014.5*vol.ports[1].Xi_outflow[1]",1006
  *(1-W_[20])+1860*W_[20],"1006*(1-vol.ports[1].Xi_outflow[1])+1860*vol.ports[1].Xi_outflow[1]");
W_[238] = 273.15+divmacro(W_[19]-2501014.5*W_[20],"vol.ports[1].h_outflow-2501014.5*vol.ports[1].Xi_outflow[1]",1006
  *(1-W_[20])+1860*W_[20],"1006*(1-vol.ports[1].Xi_outflow[1])+1860*vol.ports[1].Xi_outflow[1]");
W_[236] = IF W_[17] > 1.944E-005 THEN W_[237] ELSE IF W_[17] < -1.944E-005 THEN 
  W_[238] ELSE 12860.082304526748*W_[17]*(sqr(51440.32921810699*W_[17])-3)*(
  W_[238]-W_[237])+0.5*(W_[237]+W_[238]);
W_[232] = 5.1440329218107*W_[17];
W_[230] = IF W_[17] > 1.944E-005 THEN W_[232] ELSE IF W_[17] < -1.944E-005 THEN 
   -W_[232] ELSE (-25720.164609053496)*W_[17]*(sqr(51440.32921810699*W_[17])-3)*
  W_[232];
F_[2] = (W_[236]-X_[2])*W_[230]*W_[235];

AcceptedSection1
W_[343] = 1-W_[20];
AssertModelica(GreaterEqual(W_[343],"vol.dynBal.medium.X[2]", -1E-005,"-1E-005",
   9) AND LessEqual(W_[343],"vol.dynBal.medium.X[2]", 1.00001,"1.00001", 10),
  "vol.dynBal.medium.X[2] >= -1E-005 and vol.dynBal.medium.X[2] <= 1.00001", 
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Mass fraction X[2] = ",
  Real2String2(W_[343], true, 0)),"of substance "),"air"),"\nof medium "),"Air"),
  " is not in the range 0..1"));
PopAllMarks();

AcceptedSection2
Aux_[11] = W_[20];
Aux_[9] = W_[20];
Aux_[10] = W_[19];
Aux_[8] = W_[225];
Aux_[16] = W_[19];
Aux_[14] = W_[19];
Aux_[0] = W_[19];
Aux_[1] = W_[20];
Aux_[2] = W_[19];
Aux_[3] = W_[20];
Aux_[4] = W_[19];
Aux_[5] = W_[20];
Aux_[6] = W_[19];
Aux_[7] = W_[20];
Aux_[15] = W_[20];
Aux_[17] = W_[20];
W_[368] = 0.0;
W_[365] = 0.0;
W_[261] = (PushModelContext(1,"IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(vol.ports[1].m_flow, 0.00614746777136733, 0.01944)")
  IF W_[17] > 0.01944 THEN sqr(162.6686039181265*W_[17]) ELSE IF W_[17] < 
  -0.01944 THEN  -sqr(162.6686039181265*W_[17]) ELSE 13230.53735033616*(0.01944*
  W_[17]+51.440329218106996*powmacro(W_[17],"vol.ports[1].m_flow",3,"3")));
PopModelContext();
W_[53] = W_[261]+W_[220];
W_[58] = W_[220]-W_[53];
W_[80] = (PushModelContext(1,"IDEAS.Utilities.Math.Functions.spliceFunction(vol.ports[1].Xi_outflow[1], vol.ports[1].Xi_outflow[1], vol.ports[1].m_flow, 1.944E-008)")
  IDEAS_Utilities_Math_Functions_spliceFunction(W_[20], W_[20], W_[17], 
  1.944E-008));
PopModelContext();
W_[92] = (PushModelContext(1,"IDEAS.Utilities.Math.Functions.spliceFunction(vol.ports[1].h_outflow, vol.ports[1].h_outflow, vol.ports[1].m_flow, 1.944E-008)")
  IDEAS_Utilities_Math_Functions_spliceFunction(W_[19], W_[19], W_[17], 
  1.944E-008));
PopModelContext();
W_[100] = 273.15+divmacro(W_[92]-2501014.5*W_[80],"fan.vol.hOut_internal-2501014.5*fan.vol.Xi[1]",1006
  *(1-W_[80])+1860*W_[80],"1006*(1-fan.vol.Xi[1])+1860*fan.vol.Xi[1]");
W_[111] = W_[220]-W_[53];
W_[112] = divmacro(W_[17],"vol.ports[1].m_flow",IF W_[17] > 1.944E-005 THEN 
  1.1843079200592153E-005*W_[220] ELSE IF W_[17] < -1.944E-005 THEN 
  1.1843079200592153E-005*W_[53] ELSE 0.15230297325864392*W_[17]*(sqr(
  51440.32921810699*W_[17])-3)*(W_[53]-W_[220])+5.921539600296077E-006*(W_[220]+
  W_[53]),"smooth(1, (if noEvent(vol.ports[1].m_flow > 1.944E-005) then 1.1843079200592153E-005*bou.p else (if noEvent(vol.ports[1].m_flow < -1.944E-005) then 1.1843079200592153E-005*fan.port_b.p else 0.15230297325864392*(vol.ports[1].m_flow*((51440.32921810699*vol.ports[1].m_flow)^2-3)*(fan.port_b.p-bou.p))+5.921539600296077E-006*(bou.p+fan.port_b.p))))");
W_[130] = divmacro(W_[17],"vol.ports[1].m_flow",W_[102],"fan.rho_in");
W_[125] =  -W_[58]*W_[130];
W_[128] = (PushModelContext(1,"IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency(\nfan.per.hydraulicEfficiency, \nfan.VMachine_flow, \nfan.hydDer, \n1, \n0.0001)")
  IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc1_construct(
  RealTemporaryDense( &DP_[13], 1, 1), RealTemporaryDense( &DP_[14], 1, 1)), 
  W_[130], RealTemporaryDense( &W_[141], 1, 1), 1, 0.0001));
PopAllMarks();
W_[129] = (PushModelContext(1,"IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiency(\nfan.per.motorEfficiency, \nfan.VMachine_flow, \nfan.motDer, \n1, \n0.0001)")
  IDEAS_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc1_construct(
  RealTemporaryDense( &DP_[15], 1, 1), RealTemporaryDense( &DP_[16], 1, 1)), 
  W_[130], RealTemporaryDense( &W_[140], 1, 1), 1, 0.0001));
PopAllMarks();
W_[127] = W_[128]*W_[129];
helpvar[8] = (PushModelContext(1,"IDEAS.Utilities.Math.Functions.spliceFunction(fan.eta, 1E-005, fan.eta-1E-005, 1E-006)")
  IDEAS_Utilities_Math_Functions_spliceFunction(W_[127], 1E-005, W_[127]-1E-005,
   1E-006));
PopModelContext();
helpvar[9] = divmacro(1.0,"1.0",helpvar[8],"IDEAS.Utilities.Math.Functions.spliceFunction(fan.eta, 1E-005, fan.eta-1E-005, 1E-006)");
W_[123] = helpvar[9]*W_[125];
 /* Linear system of equations to solve. */
W_[124] = RememberSimple_(W_[124], 2);
SolveScalarLinear(W_[128],"fan.etaHyd", W_[125],"fan.WFlo", W_[124],"fan.WHyd");
 /* End of Equation Block */ 

W_[142] = (IF W_[137] THEN W_[123] ELSE W_[124])-W_[125];
helpvar[10] = fabs(W_[130]);
W_[126] = (PushModelContext(1,"IDEAS.Utilities.Math.Functions.spliceFunction(fan.QThe_flow, 0, noEvent(abs(fan.VMachine_flow))-0.000324, 0.000162)")
  IDEAS_Utilities_Math_Functions_spliceFunction(W_[142], 0, helpvar[10]-0.000324,
   0.000162));
PopModelContext();
W_[144] = 6.172839506172839*W_[130];
W_[177] = W_[172]-W_[24];
W_[244] = W_[53]-W_[220];
W_[294] = (PushModelContext(1,"IDEAS.Utilities.Math.Functions.spliceFunction(vol.ports[1].m_flow, 0, vol.ports[1].m_flow, 1.944E-005)")
  IDEAS_Utilities_Math_Functions_spliceFunction(W_[17], 0, W_[17], 1.944E-005));
PopModelContext();
W_[255] = W_[294]*W_[297];
W_[345] = 287.0512249529787*W_[354]+461.5233290850878*W_[20];
W_[346] = divmacro(1,"1",55.508435061791985*W_[20]+34.52428788658843*(1.0-W_[20]),
  "55.508435061791985*vol.ports[1].Xi_outflow[1]+34.52428788658843*(1.0-vol.ports[1].Xi_outflow[1])");
W_[350] = W_[342]-273.15;
W_[392] = IF W_[17] > 1.944E-008 OR W_[17] < -1.944E-008 THEN divmacro(1,"1",
  W_[17],"vol.ports[1].m_flow") ELSE IF W_[17] < 9.72E-009 AND W_[17] > 
  -9.72E-009 THEN 2646107470067232.5*W_[17] ELSE (PushModelContext(1,
  "IDEAS.Utilities.Math.Functions.BaseClasses.smoothTransition(vol.ports[1].m_flow, 1.944E-008, 51440329.21810699, -771604938.2716049, 3.1488678893800064E+017, -4.913810682583697E+025, 3.7390064528397536E+033, -1.368681174071672E+041, 1.9268849104322865E+048)")
  IDEAS_Utilities_Math_Functions_BaseClasses_smoothTransition(W_[17], 1.944E-008,
   51440329.21810699, -771604938.2716049, 3.1488678893800064E+017, 
  -4.913810682583697E+025, 3.7390064528397536E+033, -1.368681174071672E+041, 
  1.9268849104322865E+048));
PopModelContext();

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("VRoo", "Room volume [m3]", 97.2, 0.0,0.0,0.0,0,513)
DeclareVariable("m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.1944, \
0.0,0.0,0.0,0,513)
DeclareVariable("Q_flow_nominal", "Nominal heat loss of the room [W]", 1080, \
0.0,0.0,0.0,0,513)
DeclareVariable("vol.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("vol.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("vol.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("vol.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("vol.p_start", "Start value of pressure [Pa|bar]", 101325, 0.0,\
100000000.0,100000.0,0,513)
DeclareParameter("vol.T_start", "Start value of temperature [K|degC]", 0, 293.15,\
 1.0,10000.0,300.0,0,560)
DeclareParameter("vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 1, 0.01, 0.0,1.0,0.1,0,560)
DeclareParameter("vol.X_start[2]", "Start value of mass fractions m_i/m [kg/kg]",\
 2, 0.99, 0.0,1.0,0.1,0,560)
DeclareVariable("vol.mSenFac", "Factor for scaling the sensible thermal mass of the volume [1]",\
 2, 1.0,1E+100,0.0,0,513)
DeclareVariable("vol.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("vol.prescribedHeatFlowRate", "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("vol.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("vol.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.1944, \
0.0,1E+100,0.0,0,513)
DeclareVariable("vol.nPorts", "Number of ports [:#(type=Integer)]", 3, 0.0,0.0,\
0.0,0,517)
DeclareVariable("vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.944E-005, 0.0,1E+100,0.0,0,513)
DeclareVariable("vol.allowFlowReversal", "= true to allow flow reversal in medium, false restricts to design direction (ports[1] -> ports[2]). Used only if model has two ports. [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("vol.V", "Volume [m3]", 97.2, 0.0,0.0,0.0,0,513)
DeclareVariable("vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,100000.0,0.1944,0,776)
DeclareVariable("vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("vol.ports[1].Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,520)
DeclareAlias2("vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", -1, 5, 17, 132)
DeclareVariable("vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 4)
DeclareAlias2("vol.ports[2].Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 4)
DeclareVariable("vol.ports[3].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,777)
DeclareVariable("vol.ports[3].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("vol.ports[3].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 4)
DeclareAlias2("vol.ports[3].Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 4)
DeclareVariable("vol.heatPort.T", "Port temperature [K|degC]", 300.0, 1.0,\
10000.0,300.0,0,520)
DeclareVariable("vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("vol.T", "Temperature of the fluid [K|degC]", "vol.heatPort.T", 1,\
 5, 24, 0)
DeclareVariable("vol.p", "Pressure of the fluid [Pa|bar]", 101325.0, 0.0,0.0,0.0,\
0,513)
DeclareAlias2("vol.Xi[1]", "Species concentration of the fluid [1]", \
"vol.ports[1].Xi_outflow[1]", 1, 5, 20, 0)
DeclareVariable("vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialMixtureMedium.X_default[1]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 0.01,\
 0.0,1.0,0.1,0,2561)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialMixtureMedium.X_default[2]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 0.99,\
 0.0,1.0,0.1,0,2561)
DeclareVariable("vol.state_default.p", "Absolute pressure of medium [Pa|bar]", \
101325.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("vol.state_default.T", "Temperature of medium [K|degC]", 293.15,\
 1.0,10000.0,300.0,0,2561)
DeclareVariable("vol.state_default.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.01, 0.0,1.0,0.1,0,2561)
DeclareVariable("vol.state_default.X[2]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.99, 0.0,1.0,0.1,0,2561)
DeclareVariable("vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 1.2, 0.0,1E+100,0.0,0,2561)
DeclareVariable("vol.state_start.p", "Absolute pressure of medium [Pa|bar]", 101325,\
 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("vol.state_start.T", "Temperature of medium [K|degC]", 293.15, \
1.0,10000.0,300.0,0,2561)
DeclareVariable("vol.state_start.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("vol.state_start.X[2]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("vol.useSteadyStateTwoPort", "Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 1024)
DeclareAlias2("vol.XiOut_internal[1]", "Internal connector for leaving species concentration of the component [1]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 1024)
DeclareAlias2("vol.QSen_flow.y", "Value of Real output [W]", "vol.heatPort.Q_flow", 1,\
 5, 25, 1024)
DeclareVariable("vol.masExc.k", "Constant output value [kg/s]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("vol.masExc.y", "Connector of Real output signal [kg/s]", 0, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("theCon.Q_flow", "Heat flow rate from port_a -> port_b [W]", \
"vol.heatPort.Q_flow", 1, 5, 25, 0)
DeclareVariable("theCon.dT", "port_a.T - port_b.T [K,]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("theCon.port_a.T", "Port temperature [K|degC]", 288.15, 0.0,\
1E+100,300.0,0,520)
DeclareAlias2("theCon.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "vol.heatPort.Q_flow", 1, 5, 25, 132)
DeclareAlias2("theCon.port_b.T", "Port temperature [K|degC]", "vol.heatPort.T", 1,\
 5, 24, 4)
DeclareAlias2("theCon.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "vol.heatPort.Q_flow", -1, 5, 25, 132)
DeclareVariable("theCon.G", "Constant thermal conductance of material [W/K]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("TBou.port.T", "Port temperature [K|degC]", "theCon.port_a.T", 1, 5,\
 43, 4)
DeclareAlias2("TBou.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "vol.heatPort.Q_flow", -1, 5, 25, 132)
DeclareAlias2("TBou.T", "[K]", "theCon.port_a.T", 1, 5, 43, 0)
DeclareAlias2("TVol.T", "Absolute temperature as output signal [K]", \
"vol.heatPort.T", 1, 5, 24, 0)
DeclareAlias2("TVol.port.T", "Port temperature [K|degC]", "vol.heatPort.T", 1, 5,\
 24, 4)
DeclareVariable("TVol.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("fan.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("fan.p_start", "Start value of pressure [Pa|bar]", 3, 101325, \
0.0,100000000.0,100000.0,0,560)
DeclareParameter("fan.T_start", "Start value of temperature [K|degC]", 4, 293.15,\
 1.0,10000.0,300.0,0,560)
DeclareParameter("fan.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 5, 0.01, 0.0,1.0,0.1,0,560)
DeclareParameter("fan.X_start[2]", "Start value of mass fractions m_i/m [kg/kg]",\
 6, 0.99, 0.0,1.0,0.1,0,560)
DeclareVariable("fan.mSenFac", "Factor for scaling the sensible thermal mass of the volume",\
 1, 1.0,1E+100,0.0,0,513)
DeclareVariable("fan.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("fan.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 132)
DeclareVariable("fan.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("fan.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 4)
DeclareAlias2("fan.port_a.Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 4)
DeclareAlias2("fan.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", -1, 5, 17, 132)
DeclareVariable("fan.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,520)
DeclareAlias2("fan.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 4)
DeclareAlias2("fan.port_b.Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 4)
DeclareParameter("fan.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 7, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("fan.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 8, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("fan.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("fan.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.1944, \
0.0,0.0,0.0,0,513)
DeclareVariable("fan.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.944E-005, 0.0,1E+100,0.0,0,513)
DeclareVariable("fan.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("fan.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 0)
DeclareVariable("fan.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("fan.vol.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.vol.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.vol.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.vol.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("fan.vol.p_start", "Start value of pressure [Pa|bar]", 101325, \
0.0,100000000.0,100000.0,0,513)
DeclareVariable("fan.vol.T_start", "Start value of temperature [K|degC]", 293.15,\
 1.0,10000.0,300.0,0,513)
DeclareVariable("fan.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("fan.vol.X_start[2]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("fan.vol.mSenFac", "Factor for scaling the sensible thermal mass of the volume",\
 1, 1.0,1E+100,0.0,0,513)
DeclareVariable("fan.vol.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("fan.vol.prescribedHeatFlowRate", "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("fan.vol.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("fan.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
0.1944, 0.0,1E+100,0.0,0,513)
DeclareVariable("fan.vol.nPorts", "Number of ports [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,517)
DeclareVariable("fan.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.944E-005, 0.0,1E+100,0.0,0,513)
DeclareVariable("fan.vol.allowFlowReversal", "= true to allow flow reversal in medium, false restricts to design direction (ports[1] -> ports[2]). Used only if model has two ports. [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("fan.vol.V", "Volume [m3]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("fan.vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 132)
DeclareVariable("fan.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("fan.vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 4)
DeclareAlias2("fan.vol.ports[1].Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 4)
DeclareAlias2("fan.vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", -1, 5, 17, 132)
DeclareVariable("fan.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("fan.vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 4)
DeclareAlias2("fan.vol.ports[2].Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 4)
DeclareAlias2("fan.vol.heatPort.T", "Port temperature [K|degC]", \
"fan.heatPort.T", 1, 5, 100, 4)
DeclareVariable("fan.vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("fan.vol.T", "Temperature of the fluid [K|degC]", "fan.heatPort.T", 1,\
 5, 100, 0)
DeclareVariable("fan.vol.p", "Pressure of the fluid [Pa|bar]", 101325.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("fan.vol.Xi[1]", "Species concentration of the fluid [1]", 0.0, \
0.0,1.0,0.0,0,512)
DeclareVariable("fan.vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan.vol.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("fan.vol.state_default.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("fan.vol.state_default.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.01, 0.0,1.0,0.1,0,2561)
DeclareVariable("fan.vol.state_default.X[2]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.99, 0.0,1.0,0.1,0,2561)
DeclareVariable("fan.vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 1.2, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan.vol.state_start.p", "Absolute pressure of medium [Pa|bar]",\
 101325, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("fan.vol.state_start.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("fan.vol.state_start.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("fan.vol.state_start.X[2]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("fan.vol.useSteadyStateTwoPort", "Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("fan.vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 45300.945, 0.0,0.0,0.0,0,2560)
DeclareAlias2("fan.vol.XiOut_internal[1]", "Internal connector for leaving species concentration of the component [1]",\
 "fan.vol.Xi[1]", 1, 5, 80, 1024)
DeclareVariable("fan.vol.QSen_flow.y", "Value of Real output [W]", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("fan.vol.masExc.k", "Constant output value [kg/s]", 0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("fan.vol.masExc.y", "Connector of Real output signal [kg/s]", 0,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.tau", "Time constant at nominal flow [s]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("fan.vol.V_nominal", "Volume of delay element [m3]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("fan.dynamicBalance", "Set to true to use a dynamic balance, which often leads to smaller systems of equations [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("fan.addPowerToMedium", "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("fan.tau", "Time constant of fluid volume for nominal flow, used if dynamicBalance=true [s]",\
 9, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("fan.heatPort.T", "Port temperature [K|degC]", 300.0, 1.0,\
10000.0,300.0,0,520)
DeclareVariable("fan.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("fan.rho_in", "Density of inflowing fluid [kg/m3|g/cm3]", 0.0, \
0.0,1E+100,0.0,0,2561)
DeclareVariable("fan.preSou.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("fan.preSou.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 1156)
DeclareVariable("fan.preSou.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,2569)
DeclareAlias2("fan.preSou.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 1028)
DeclareAlias2("fan.preSou.port_a.Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 1028)
DeclareAlias2("fan.preSou.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", -1, 5, 17, 1156)
DeclareAlias2("fan.preSou.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "fan.port_b.p", 1, 5, 53, 1028)
DeclareAlias2("fan.preSou.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 1028)
DeclareAlias2("fan.preSou.port_b.Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 1028)
DeclareVariable("fan.preSou.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("fan.preSou.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("fan.preSou.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 10, true, 0.0,0.0,0.0,0,2610)
DeclareParameter("fan.preSou.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 11, 0, 0.0,100000000.0,100000.0,0,2608)
DeclareVariable("fan.preSou.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,2561)
DeclareVariable("fan.preSou.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.944E-005, -100000.0,100000.0,0.0,0,2561)
DeclareVariable("fan.preSou.show_T", "= true, if temperatures at port_a and port_b are computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("fan.preSou.show_V_flow", "= true, if volume flow rate at inflowing port is computed [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("fan.preSou.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 1024)
DeclareVariable("fan.preSou.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|bar]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("fan.preSou.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("fan.preSou.control_m_flow", "= false to control dp instead of m_flow [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("fan.preSou.m_flow_internal", "Needed to connect to conditional connector [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 1024)
DeclareVariable("fan.preSou.dp_internal", "Needed to connect to conditional connector [Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.sta_start.p", "Absolute pressure of medium [Pa|bar]", 101325,\
 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("fan.sta_start.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,2561)
DeclareVariable("fan.sta_start.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("fan.sta_start.X[2]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("fan.h_outflow_start", "Start value for outflowing enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.use_powerCharacteristic", "Use powerCharacteristic (vs. efficiencyCharacteristic) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("fan.motorCooledByFluid", "If true (and if addPowerToMedium = true), then motor heat is added to fluid stream [:#(type=Boolean)]",\
 12, true, 0.0,0.0,0.0,0,562)
DeclareVariable("fan.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("fan.rho_default", "Fluid density at medium default state [kg/m3|g/cm3]",\
 1.2, 0.0,1E+100,0.0,0,513)
DeclareVariable("fan.P", "Electrical power consumed [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("fan.WHyd", "Hydraulic power input (converted to flow work and heat) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("fan.WFlo", "Flow work [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("fan.Q_flow", "Heat input from fan or pump to medium [W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("fan.eta", "Global efficiency [1]", 0.0, 0.0,1.0,0.0,0,512)
DeclareVariable("fan.etaHyd", "Hydraulic efficiency [1]", 0.0, 0.0,1.0,0.0,0,512)
DeclareVariable("fan.etaMot", "Motor efficiency [1]", 0.0, 0.0,1.0,0.0,0,512)
DeclareAlias2("fan.dpMachine", "Pressure increase [Pa|Pa]", "fan.dp", -1, 5, 58,\
 0)
DeclareVariable("fan.VMachine_flow", "Volume flow rate [m3/s]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("fan._perPow.hydraulicEfficiency.V_flow[1]", "Volumetric flow rate at user-selected operating points [m3/s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan._perPow.hydraulicEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [|1]",\
 0.0, 0.0,1.0,0.0,0,2561)
DeclareVariable("fan._perPow.motorEfficiency.V_flow[1]", "Volumetric flow rate at user-selected operating points [m3/s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan._perPow.motorEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [|1]",\
 0.0, 0.0,1.0,0.0,0,2561)
DeclareVariable("fan._perPow.power.V_flow[1]", "Volume flow rate at user-selected operating points [m3/s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan._perPow.power.P[1]", "Fan or pump electrical power at these flow rates [W]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan._perPow.motorCooledByFluid", "If true, then motor heat is added to fluid stream [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("fan._perPow.use_powerCharacteristic", "Use powerCharacteristic instead of efficiencyCharacteristic [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("fan.delta_V_flow", "Factor used for setting heat input into medium to zero at very small flows [m3/s]",\
 0.000162, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.motDer[1]", "Coefficients for polynomial of pressure vs. flow rate",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.hydDer[1]", "Coefficients for polynomial of pressure vs. flow rate",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.QThe_flow", "Heat input from fan or pump to medium [W]", \
0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("fan.control_m_flow", "= false to control head instead of m_flow [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("fan.per.hydraulicEfficiency.V_flow[1]", "Volumetric flow rate at user-selected operating points [m3/s]",\
 13, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("fan.per.hydraulicEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [|1]",\
 14, 0.7, 0.0,1.0,0.0,0,560)
DeclareParameter("fan.per.motorEfficiency.V_flow[1]", "Volumetric flow rate at user-selected operating points [m3/s]",\
 15, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("fan.per.motorEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [|1]",\
 16, 0.7, 0.0,1.0,0.0,0,560)
DeclareParameter("fan.per.power.V_flow[1]", "Volume flow rate at user-selected operating points [m3/s]",\
 17, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("fan.per.power.P[1]", "Fan or pump electrical power at these flow rates [W]",\
 18, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("fan.per.motorCooledByFluid", "If true, then motor heat is added to fluid stream [:#(type=Boolean)]",\
 19, true, 0.0,0.0,0.0,0,562)
DeclareParameter("fan.per.use_powerCharacteristic", "Use powerCharacteristic instead of efficiencyCharacteristic [:#(type=Boolean)]",\
 20, false, 0.0,0.0,0.0,0,562)
DeclareVariable("fan.r_V", "Ratio V_flow/V_flow_max = V_flow/V_flow(dp=0, N=N_nominal) [1]",\
 1, 0.0,0.0,0.0,0,512)
DeclareVariable("fan.p_a_default", "Nominal inlet pressure for predefined fan or pump characteristics [Pa|Pa]",\
 101325, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("fan.V_flow_max", "Maximum volume flow rate [m3/s]", 0.162, \
0.0,0.0,0.0,0,2561)
DeclareVariable("fan.sta_default.p", "Absolute pressure of medium [Pa|bar]", \
101325.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("fan.sta_default.T", "Temperature of medium [K|degC]", 293.15, \
1.0,10000.0,300.0,0,2561)
DeclareVariable("fan.sta_default.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.01, 0.0,1.0,0.1,0,2561)
DeclareVariable("fan.sta_default.X[2]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.99, 0.0,1.0,0.1,0,2561)
DeclareVariable("fan.filteredSpeed", "= true, if speed is filtered with a 2nd order CriticalDamping filter [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("fan.riseTime", "Rise time of the filter (time to reach 99.6 % of the speed) [s]",\
 21, 30, 0.0,0.0,0.0,0,560)
DeclareVariable("fan.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("fan.m_flow_start", "Initial value of mass flow rate [kg/s]", 22,\
 0, 0.0,1E+100,0.0,0,560)
DeclareVariable("fan.m_flow_in", "Prescribed mass flow rate [kg/s]", 0.1944, \
0.0,0.0,0.1944,0,513)
DeclareAlias2("fan.m_flow_actual", "Actual mass flow rate [kg/s]", \
"vol.ports[1].m_flow", 1, 5, 17, 0)
DeclareVariable("fan.filter.u", "Connector of Real input signal [kg/s]", 0.1944,\
 0.0,0.0,0.0,0,2561)
DeclareAlias2("fan.filter.y", "Connector of Real output signal [kg/s]", \
"vol.ports[1].m_flow", 1, 5, 17, 1024)
DeclareVariable("fan.filter.analogFilter", "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI) [:#(type=Modelica.Blocks.Types.AnalogFilter)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("fan.filter.filterType", "Type of filter (LowPass/HighPass/BandPass/BandStop) [:#(type=Modelica.Blocks.Types.FilterType)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("fan.filter.order", "Order of filter [:#(type=Integer)]", 2, 1.0,\
1E+100,0.0,0,2565)
DeclareVariable("fan.filter.f_cut", "Cut-off frequency [Hz]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("fan.filter.gain", "Gain (= amplitude of frequency response at zero frequency)",\
 23, 1.0, 0.0,0.0,0.0,0,2608)
DeclareParameter("fan.filter.A_ripple", "Pass band ripple for Chebyshev filter (otherwise not used); > 0 required [dB]",\
 24, 0.5, 0.0,0.0,0.0,0,2608)
DeclareParameter("fan.filter.f_min", "Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain) [Hz]",\
 25, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("fan.filter.normalized", "= true, if amplitude at f_cut = -3db, otherwise unmodified filter [:#(type=Boolean)]",\
 26, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("fan.filter.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("fan.filter.nx", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareParameter("fan.filter.x_start[1]", "Initial or guess values of states", 27,\
 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("fan.filter.x_start[2]", "Initial or guess values of states", 28,\
 0, 0.0,0.0,0.0,0,2608)
DeclareVariable("fan.filter.y_start", "Initial value of output [kg/s]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("fan.filter.u_nominal", "Nominal value of input (used for scaling the states) [kg/s]",\
 0.1944, 0.0,0.0,0.0,0,2561)
DeclareState("fan.filter.x[1]", "Filter states", 0, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("fan.filter.der(x[1])", "der(Filter states)", 0.0, 0.0,0.0,0.0,\
0,2560)
DeclareState("fan.filter.x[2]", "Filter states", 1, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("fan.filter.der(x[2])", "der(Filter states)", 0.0, 0.0,0.0,0.0,\
0,2560)
DeclareVariable("fan.filter.ncr", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("fan.filter.nc0", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("fan.filter.na", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("fan.filter.nr", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("fan.filter.cr[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.filter.cr[2]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.filter.r[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.filter.r[2]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.filter.uu[1]", "", 1.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("fan.filter.uu[2]", "", "fan.filter.x[1]", 1, 1, 0, 1024)
DeclareAlias2("fan.filter.uu[3]", "", "fan.filter.x[2]", 1, 1, 1, 1024)
DeclareAlias2("fan.m_flow_filtered", "Filtered mass flow rate [kg/s]", \
"vol.ports[1].m_flow", 1, 5, 17, 1024)
DeclareAlias2("TOut.y", "Value of Real output [K]", "theCon.port_a.T", 1, 5, 43,\
 0)
DeclareParameter("TSet.amplitude", "Amplitude of pulse [K]", 29, 4, 0.0,0.0,0.0,\
0,560)
DeclareParameter("TSet.width", "Width of pulse in % of period", 30, 50, 1E-060,\
100.0,0.0,0,560)
DeclareParameter("TSet.period", "Time for one period [s]", 31, 86400, 1E-060,\
1E+100,0.0,0,560)
DeclareParameter("TSet.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 32, -1, 0.0,0.0,0.0,0,564)
DeclareParameter("TSet.offset", "Offset of output signals [K]", 33, 289.15, \
0.0,0.0,0.0,0,560)
DeclareParameter("TSet.startTime", "Output = offset for time < startTime [s]", 34,\
 25200, 0.0,0.0,0.0,0,560)
DeclareVariable("TSet.y", "Connector of Real output signal [K]", 0.0, 0.0,0.0,\
0.0,0,640)
DeclareVariable("TSet.T_width", "[s]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("TSet.T_start", "Start time of current period [s]", 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("TSet.count", "Period count [:#(type=Integer)]", 0, 0.0,0.0,0.0,\
0,2692)
DeclareAlias2("conPI.u_s", "Connector of setpoint input signal [K]", "TSet.y", 1,\
 5, 172, 0)
DeclareAlias2("conPI.u_m", "Connector of measurement input signal [K]", \
"vol.heatPort.T", 1, 5, 24, 0)
DeclareVariable("conPI.y", "Connector of actuator output signal", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("conPI.controlError", "Control error (set point - measurement) [K]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("conPI.controllerType", "Type of controller [:#(type=Modelica.Blocks.Types.SimpleController)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareParameter("conPI.k", "Gain of controller [1]", 35, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("conPI.Ti", "Time constant of Integrator block [s]", 36, 120, \
1E-060,1E+100,0.0,0,560)
DeclareParameter("conPI.Td", "Time constant of Derivative block [s]", 37, 0.1, \
0.0,1E+100,0.0,0,560)
DeclareParameter("conPI.yMax", "Upper limit of output", 38, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("conPI.yMin", "Lower limit of output", 39, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("conPI.wp", "Set-point weight for Proportional block (0..1)", 40,\
 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("conPI.wd", "Set-point weight for Derivative block (0..1)", 41,\
 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("conPI.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 42, 0.9, 1E-013,1E+100,0.0,0,560)
DeclareParameter("conPI.Nd", "The higher Nd, the more ideal the derivative block",\
 43, 10, 1E-013,1E+100,0.0,0,560)
DeclareVariable("conPI.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.InitPID)]",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("conPI.limitsAtInit", "= false, if limits are ignored during initialization [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("conPI.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 44, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("conPI.xd_start", "Initial or guess value for state of derivative block",\
 45, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("conPI.y_start", "Initial value of output", 46, 0, 0.0,0.0,0.0,\
0,560)
DeclareVariable("conPI.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("conPI.unitTime", "[s]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("conPI.addP.u1", "Connector of Real input signal 1 [K]", "TSet.y", 1,\
 5, 172, 0)
DeclareAlias2("conPI.addP.u2", "Connector of Real input signal 2 [K]", \
"vol.heatPort.T", 1, 5, 24, 0)
DeclareVariable("conPI.addP.y", "Connector of Real output signal", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("conPI.addP.k1", "Gain of upper input", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("conPI.addP.k2", "Gain of lower input", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("conPI.P.k", "Gain value multiplied with input signal [1]", 47,\
 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("conPI.P.u", "Input signal connector", "conPI.addP.y", 1, 5, 183, 0)
DeclareVariable("conPI.P.y", "Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("conPI.gainPID.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("conPI.gainPID.u", "Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("conPI.gainPID.y", "Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("conPI.addPID.k1", "Gain of upper input", 48, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("conPI.addPID.k2", "Gain of middle input", 49, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("conPI.addPID.k3", "Gain of lower input", 50, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("conPI.addPID.u1", "Connector 1 of Real input signals", \
"conPI.P.y", 1, 5, 186, 0)
DeclareAlias2("conPI.addPID.u2", "Connector 2 of Real input signals", \
"conPI.Dzero.k", 1, 7, 51, 0)
DeclareAlias2("conPI.addPID.u3", "Connector 3 of Real input signals", \
"conPI.I.y", 1, 1, 6, 0)
DeclareAlias2("conPI.addPID.y", "Connector of Real output signals", \
"conPI.gainPID.u", 1, 5, 188, 0)
DeclareVariable("conPI.limiter.uMax", "Upper limits of input signals", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("conPI.limiter.uMin", "Lower limits of input signals", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("conPI.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("conPI.limiter.limitsAtInit", "= false, if limits are ignored during initialization (i.e., y=u) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("conPI.limiter.u", "Connector of Real input signal", \
"conPI.gainPID.y", 1, 5, 189, 0)
DeclareAlias2("conPI.limiter.y", "Connector of Real output signal", "conPI.y", 1,\
 5, 176, 0)
DeclareVariable("conPI.with_I", "[:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("conPI.with_D", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("conPI.Dzero.k", "Constant output value", 51, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("conPI.Dzero.y", "Connector of Real output signal", \
"conPI.Dzero.k", 1, 7, 51, 0)
DeclareParameter("conPI.reverseAction", "Set to true for throttling the water flow rate through a cooling coil controller [:#(type=Boolean)]",\
 52, false, 0.0,0.0,0.0,0,562)
DeclareVariable("conPI.revAct", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("mFan_flow.k", "Constant output value [kg/s]", 0.1944, 0.0,0.0,\
0.0,0,513)
DeclareVariable("mFan_flow.y", "Connector of Real output signal [kg/s]", 0.1944,\
 0.0,0.0,0.0,0,513)
DeclareVariable("bou.nPorts", "Number of ports [:#(type=Integer)]", 1, 0.0,0.0,\
0.0,0,517)
DeclareVariable("bou.medium.p", "Absolute pressure of medium [Pa|bar]", 101325.0,\
 0.0,1E+100,100000.0,0,513)
DeclareAlias2("bou.medium.Xi[1]", "Structurally independent mass fractions [1]",\
 "bou.X[1]", 1, 7, 56, 0)
DeclareAlias2("bou.medium.h", "Specific enthalpy of medium [J/kg]", \
"bou.ports[1].h_outflow", 1, 5, 217, 0)
DeclareVariable("bou.medium.d", "Density of medium [kg/m3|g/cm3]", 1, 0.0,\
100000.0,1.0,0,513)
DeclareAlias2("bou.medium.T", "Temperature of medium [K|degC]", "bou.T", 1, 7, 54,\
 0)
DeclareAlias2("bou.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 "bou.X[1]", 1, 7, 56, 0)
DeclareVariable("bou.medium.X[2]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.99, 0.0,1.0,0.1,0,513)
DeclareVariable("bou.medium.u", "Specific internal energy of medium [J/kg]", 0.0,\
 -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("bou.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 1000.0, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("bou.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.032, 0.001,0.25,0.032,0,513)
DeclareVariable("bou.medium.state.p", "Absolute pressure of medium [Pa|bar]", \
101325.0, 0.0,100000000.0,100000.0,0,513)
DeclareAlias2("bou.medium.state.T", "Temperature of medium [K|degC]", "bou.T", 1,\
 7, 54, 0)
DeclareAlias2("bou.medium.state.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 "bou.X[1]", 1, 7, 56, 0)
DeclareAlias2("bou.medium.state.X[2]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 "bou.medium.X[2]", 1, 5, 202, 0)
DeclareVariable("bou.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("bou.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("bou.medium.T_degC", "Temperature of medium in [degC] [degC;]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("bou.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("bou.medium.MMX[1]", "Molar masses of components [kg/mol]", \
0.01801528, 0.0,1E+100,0.0,0,2561)
DeclareVariable("bou.medium.MMX[2]", "Molar masses of components [kg/mol]", \
0.0289651159, 0.0,1E+100,0.0,0,2561)
DeclareAlias2("bou.medium.X_steam", "Mass fraction of steam water [kg/kg]", \
"bou.X[1]", 1, 7, 56, 1024)
DeclareVariable("bou.medium.X_air", "Mass fraction of air [kg/kg]", 0.0, 0.0,1.0,\
0.1,0,2561)
DeclareVariable("bou.medium.dT", "Temperature difference used to compute enthalpy [K,]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("bou.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0.0, -1E+060,1E+060,0.0,0,777)
DeclareVariable("bou.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("bou.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareAlias2("bou.ports[1].Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "bou.X[1]", 1, 7, 56, 4)
DeclareVariable("bou.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("bou.use_p", "select p or d [:#(type=Boolean)]", true, 0.0,0.0,\
0.0,0,515)
DeclareVariable("bou.p", "Boundary pressure [Pa|bar]", 101325, 0.0,100000000.0,\
100000.0,0,513)
DeclareParameter("bou.d", "Boundary density [kg/m3|g/cm3]", 53, 1.2, 0.0,\
100000.0,1.0,0,560)
DeclareVariable("bou.use_T", "select T or h [:#(type=Boolean)]", true, 0.0,0.0,\
0.0,0,515)
DeclareParameter("bou.T", "Boundary temperature [K|degC]", 54, 293.15, 1.0,\
10000.0,300.0,0,560)
DeclareParameter("bou.h", "Boundary specific enthalpy [J/kg]", 55, 45300.945, \
-10000000000.0,10000000000.0,1000000.0,0,560)
DeclareParameter("bou.X[1]", "Boundary mass fractions m_i/m [kg/kg]", 56, 0.01, \
0.0,1.0,0.1,0,560)
DeclareParameter("bou.X[2]", "Boundary mass fractions m_i/m [kg/kg]", 57, 0.99, \
0.0,1.0,0.1,0,560)
DeclareVariable("THeaOut.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("THeaOut.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 132)
DeclareVariable("THeaOut.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("THeaOut.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 4)
DeclareAlias2("THeaOut.port_a.Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 4)
DeclareAlias2("THeaOut.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", -1, 5, 17, 132)
DeclareVariable("THeaOut.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("THeaOut.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareAlias2("THeaOut.port_b.Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 4)
DeclareParameter("THeaOut.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 58, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("THeaOut.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 59, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("THeaOut.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 60, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("THeaOut.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 0.1944, 0.0,1E+100,0.0,0,513)
DeclareVariable("THeaOut.m_flow_small", "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 1.944E-005, 0.0,1E+100,0.0,0,513)
DeclareVariable("THeaOut.tau", "Time constant at nominal flow rate [s]", 1, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("THeaOut.initType", "Type of initialization (InitialState and InitialOutput are identical) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("THeaOut.k", "Gain to take flow rate into account for sensor time constant [1]",\
 1, 0.0,0.0,0.0,0,2560)
DeclareVariable("THeaOut.dynamic", "Flag, true if the sensor is a dynamic sensor [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("THeaOut.mNor_flow", "Normalized mass flow rate [1]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareState("THeaOut.T", "Temperature of the passing fluid [K|degC]", 2, 0.0, \
0.0,1E+100,0.0,0,544)
DeclareDerivative("THeaOut.der(T)", "der(Temperature of the passing fluid) [K/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("THeaOut.T_start", "Initial or guess value of output (= state) [K|degC]",\
 61, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("THeaOut.transferHeat", "if true, temperature T converges towards TAmb when no flow [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("THeaOut.TAmb", "Fixed ambient temperature for heat transfer [K|degC]",\
 62, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("THeaOut.tauHeaTra", "Time constant for heat transfer, default 20 minutes [s]",\
 63, 1200, 1.0,1E+100,0.0,0,560)
DeclareVariable("THeaOut.tauHeaTraInv", "Dummy parameter to avoid division by tauLoss [1/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("THeaOut.tauInv", "Dummy parameter to avoid division by tau [1/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("THeaOut.TMed", "Medium temperature to which the sensor is exposed [K|degC]",\
 300.0, 1.0,10000.0,300.0,0,2560)
DeclareVariable("THeaOut.T_a_inflow", "Temperature of inflowing fluid at port_a [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("THeaOut.T_b_inflow", "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("hea.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("hea.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 132)
DeclareAlias2("hea.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "fan.port_b.p", 1, 5, 53, 4)
DeclareAlias2("hea.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 4)
DeclareAlias2("hea.port_a.Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 4)
DeclareAlias2("hea.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", -1, 5, 17, 132)
DeclareVariable("hea.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("hea.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "THeaOut.port_b.h_outflow", 1, 5, 225, 4)
DeclareAlias2("hea.port_b.Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 4)
DeclareParameter("hea.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 64, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("hea.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 65, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("hea.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 66, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("hea.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.1944, \
0.0,0.0,0.0,0,513)
DeclareVariable("hea.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.944E-005, 0.0,1E+100,0.0,0,513)
DeclareVariable("hea.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("hea.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 0)
DeclareVariable("hea.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("hea.computeFlowResistance", "=true, compute flow resistance. Set to false to assume no friction [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.dp_nominal", "Pressure difference [Pa|Pa]", 1000, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("hea.linearizeFlowResistance", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.deltaM", "Fraction of nominal flow rate where flow transitions to laminar [1]",\
 0.1, 0.0,0.0,0.0,0,513)
DeclareVariable("hea.Q_flow_maxHeat", "Maximum heat flow rate for heating (positive) [W]",\
 1080, 0.0,0.0,0.0,0,513)
DeclareVariable("hea.Q_flow_maxCool", "Maximum heat flow rate for cooling (negative) [W]",\
 0, 0.0,0.0,0.0,0,513)
DeclareParameter("hea.tau", "Time constant at nominal flow rate (used if energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState) [s]",\
 67, 10, 0.0,1E+100,0.0,0,560)
DeclareParameter("hea.T_start", "Initial or guess value of set point [K|degC]", 68,\
 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("hea.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("hea.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.TSet", "Set point temperature of the fluid that leaves port_b [K|degC]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("hea.Q_flow", "Heat added to the fluid (if flow is from port_a to port_b) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("hea.preDro.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("hea.preDro.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 1156)
DeclareAlias2("hea.preDro.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "fan.port_b.p", 1, 5, 53, 1028)
DeclareAlias2("hea.preDro.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 1028)
DeclareAlias2("hea.preDro.port_a.Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 1028)
DeclareAlias2("hea.preDro.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", -1, 5, 17, 1156)
DeclareVariable("hea.preDro.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,2569)
DeclareAlias2("hea.preDro.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 1028)
DeclareAlias2("hea.preDro.port_b.Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 1028)
DeclareParameter("hea.preDro.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 69, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("hea.preDro.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 70, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("hea.preDro.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 71, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("hea.preDro.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
0.1944, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.preDro.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.944E-005, 0.0,1E+100,0.0,0,2561)
DeclareVariable("hea.preDro.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("hea.preDro.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 1024)
DeclareVariable("hea.preDro.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,1000.0,0,2560)
DeclareVariable("hea.preDro.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.preDro.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 1000, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.preDro.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.preDro.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.preDro.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.01944, 0.0,1E+100,0.0,0,2561)
DeclareParameter("hea.preDro.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 72, 101325.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("hea.preDro.sta_default.T", "Temperature of medium [K|degC]", 73,\
 293.15, 1.0,10000.0,300.0,0,2608)
DeclareParameter("hea.preDro.sta_default.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 74, 0.01, 0.0,1.0,0.1,0,2608)
DeclareParameter("hea.preDro.sta_default.X[2]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 75, 0.99, 0.0,1.0,0.1,0,2608)
DeclareVariable("hea.preDro.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("hea.preDro.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 0.1944, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.preDro.dp_nominal_pos", "Absolute value of nominal pressure [Pa|bar]",\
 1000, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.preDro.use_dh", "Set to true to specify hydraulic diameter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("hea.preDro.dh", "Hydraulic diameter [m]", 76, 1, 0.0,0.0,0.0,0,2608)
DeclareParameter("hea.preDro.ReC", "Reynolds number where transition to turbulent starts",\
 77, 4000, 0.0,1E+100,0.0,0,2608)
DeclareVariable("hea.preDro.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.1, 0.01,1E+100,0.0,0,2561)
DeclareVariable("hea.preDro.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.00614746777136733, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.preDro.computeFlowResistance", "Flag to enable/disable computation of flow resistance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.heaCoo.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("hea.heaCoo.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 1156)
DeclareVariable("hea.heaCoo.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,2569)
DeclareAlias2("hea.heaCoo.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 1028)
DeclareAlias2("hea.heaCoo.port_a.Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 1028)
DeclareAlias2("hea.heaCoo.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", -1, 5, 17, 1156)
DeclareVariable("hea.heaCoo.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,2569)
DeclareAlias2("hea.heaCoo.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "THeaOut.port_b.h_outflow", 1, 5, 225, 1028)
DeclareAlias2("hea.heaCoo.port_b.Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 1028)
DeclareVariable("hea.heaCoo.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.heaCoo.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("hea.heaCoo.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 78, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("hea.heaCoo.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 0, 0.0,100000000.0,100000.0,0,2561)
DeclareParameter("hea.heaCoo.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 79, 0, -100000.0,100000.0,0.0,0,2608)
DeclareVariable("hea.heaCoo.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.944E-005, -100000.0,100000.0,0.0,0,2561)
DeclareVariable("hea.heaCoo.show_T", "= true, if temperatures at port_a and port_b are computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.heaCoo.show_V_flow", "= true, if volume flow rate at inflowing port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("hea.heaCoo.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 1024)
DeclareVariable("hea.heaCoo.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|bar]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.heaCoo.Q_flow_maxHeat", "Maximum heat flow rate for heating (positive) [W]",\
 1080, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.heaCoo.Q_flow_maxCool", "Maximum heat flow rate for cooling (negative) [W]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.heaCoo.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 0.1944, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.heaCoo.tau", "Time constant at nominal flow rate (used if energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState) [s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("hea.heaCoo.T_start", "Initial or guess value of set point [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("hea.heaCoo.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,2565)
DeclareAlias2("hea.heaCoo.TSet", "Set point temperature of the fluid that leaves port_b [K|degC]",\
 "hea.TSet", 1, 5, 254, 1024)
DeclareAlias2("hea.heaCoo.Q_flow", "Heat added to the fluid (if flow is from port_a to port_b) [W]",\
 "hea.Q_flow", 1, 5, 255, 1024)
DeclareParameter("hea.heaCoo.cp_default", "Specific heat capacity at default medium state [J/(kg.K)]",\
 80, 1014.54, 0.0,0.0,0.0,0,2608)
DeclareVariable("hea.heaCoo.restrictHeat", "Flag, true if maximum heating power is restricted [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.heaCoo.restrictCool", "Flag, true if maximum cooling power is restricted [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.heaCoo.deltah", "Small value for deltah used for regularization [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.heaCoo.dynamic", "Flag, true if the sensor is a dynamic sensor [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.heaCoo.m_flow_pos", "Mass flow rate, or zero if reverse flow [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("hea.heaCoo.m_flow_limited", "Mass flow rate bounded away from zero [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("hea.heaCoo.hSet", "Set point for enthalpy leaving port_b [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("hea.heaCoo.T", "Temperature of outlet state assuming unlimited capacity and taking dynamics into account [K|degC]",\
 3, 288.15, 0.0,1E+100,300.0,0,2592)
DeclareDerivative("hea.heaCoo.der(T)", "der(Temperature of outlet state assuming unlimited capacity and taking dynamics into account) [K/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("hea.heaCoo.dhSetAct", "Actual enthalpy difference from port_a to port_b [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("hea.heaCoo.k", "Gain to take flow rate into account for sensor time constant [1]",\
 1, 0.0,0.0,0.0,0,2560)
DeclareVariable("hea.heaCoo.mNor_flow", "Normalized mass flow rate [1]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareAlias2("tab.u", "Connector of Real input signal", "conPI.y", 1, 5, 176, 0)
DeclareAlias2("tab.y", "Connector of Real output signal [K]", "hea.TSet", 1, 5, 254,\
 0)
DeclareParameter("tab.table[1, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 81, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("tab.table[1, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 82, 288.15, 0.0,0.0,0.0,0,560)
DeclareParameter("tab.table[2, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 83, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("tab.table[2, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 84, 303.15, 0.0,0.0,0.0,0,560)
DeclareParameter("tab.offset", "Offset of output signal", 85, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("tab.constantExtrapolation", "If true, then y=y1 for u<u1, and y=yMax for u>uMax [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("tab.nCol", "Number of columns [:#(type=Integer)]", 4, 0.0,0.0,\
0.0,0,2565)
DeclareVariable("tab.offsetVector[1, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.offsetVector[1, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.offsetVector[2, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.offsetVector[2, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.offsetVector[3, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.offsetVector[3, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.offsetVector[4, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.offsetVector[4, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.tab.n", "Number of inputs (= number of outputs) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,2565)
DeclareAlias2("tab.tab.u[1]", "Connector of Real input signals", "conPI.y", 1, 5,\
 176, 1024)
DeclareAlias2("tab.tab.y[1]", "Connector of Real output signals [K]", "hea.TSet", 1,\
 5, 254, 1024)
DeclareVariable("tab.tab.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("tab.tab.table[1, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.tab.table[1, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.tab.table[2, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.tab.table[2, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.tab.table[3, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.tab.table[3, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.tab.table[4, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tab.tab.table[4, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("tab.tab.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 86, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("tab.tab.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("tab.tab.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 1, 1.0,3.0,0.0,0,2565)
DeclareVariable("tab.tab.tableID.id", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("tab.tab.tableOnFileRead", "= 1, if table was successfully read from file",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("vol.dynBal.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("vol.dynBal.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("vol.dynBal.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("vol.dynBal.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("vol.dynBal.p_start", "Start value of pressure [Pa|bar]", 101325,\
 0.0,100000000.0,100000.0,0,513)
DeclareVariable("vol.dynBal.T_start", "Start value of temperature [K|degC]", \
293.15, 1.0,10000.0,300.0,0,513)
DeclareVariable("vol.dynBal.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("vol.dynBal.X_start[2]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("vol.dynBal.mSenFac", "Factor for scaling the sensible thermal mass of the volume [1]",\
 2.0, 1.0,1E+100,0.0,0,513)
DeclareVariable("vol.dynBal.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("vol.dynBal.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("vol.dynBal.nPorts", "Number of ports [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareAlias2("vol.dynBal.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 132)
DeclareVariable("vol.dynBal.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("vol.dynBal.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 4)
DeclareAlias2("vol.dynBal.ports[1].Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 4)
DeclareAlias2("vol.dynBal.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", -1, 5, 17, 132)
DeclareVariable("vol.dynBal.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("vol.dynBal.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 4)
DeclareAlias2("vol.dynBal.ports[2].Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 4)
DeclareVariable("vol.dynBal.ports[3].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,777)
DeclareVariable("vol.dynBal.ports[3].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("vol.dynBal.ports[3].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 4)
DeclareAlias2("vol.dynBal.ports[3].Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 4)
DeclareVariable("vol.dynBal.medium.p", "Absolute pressure of medium [Pa|bar]", \
101325.0, 0.0,1E+100,100000.0,0,513)
DeclareAlias2("vol.dynBal.medium.Xi[1]", "Structurally independent mass fractions [1]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 0)
DeclareAlias2("vol.dynBal.medium.h", "Specific enthalpy of medium [J/kg]", \
"vol.ports[1].h_outflow", 1, 5, 19, 0)
DeclareVariable("vol.dynBal.medium.d", "Density of medium [kg/m3|g/cm3]", 0.0, \
0.0,100000.0,1.0,0,513)
DeclareVariable("vol.dynBal.medium.T", "Temperature of medium [K|degC]", 300.0, \
1.0,10000.0,300.0,0,512)
DeclareAlias2("vol.dynBal.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 0)
DeclareVariable("vol.dynBal.medium.X[2]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,512)
DeclareVariable("vol.dynBal.medium.u", "Specific internal energy of medium [J/kg]",\
 0.0, -100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("vol.dynBal.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 1000.0, 0.0,10000000.0,1000.0,0,512)
DeclareVariable("vol.dynBal.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.032, 0.001,0.25,0.032,0,512)
DeclareVariable("vol.dynBal.medium.state.p", "Absolute pressure of medium [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,513)
DeclareAlias2("vol.dynBal.medium.state.T", "Temperature of medium [K|degC]", \
"vol.dynBal.medium.T", 1, 5, 342, 0)
DeclareAlias2("vol.dynBal.medium.state.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 0)
DeclareAlias2("vol.dynBal.medium.state.X[2]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 "vol.dynBal.medium.X[2]", 1, 5, 343, 0)
DeclareVariable("vol.dynBal.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("vol.dynBal.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("vol.dynBal.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("vol.dynBal.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("vol.dynBal.medium.MMX[1]", "Molar masses of components [kg/mol]",\
 0.01801528, 0.0,1E+100,0.0,0,2561)
DeclareVariable("vol.dynBal.medium.MMX[2]", "Molar masses of components [kg/mol]",\
 0.0289651159, 0.0,1E+100,0.0,0,2561)
DeclareAlias2("vol.dynBal.medium.X_steam", "Mass fraction of steam water [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 1024)
DeclareVariable("vol.dynBal.medium.X_air", "Mass fraction of air [kg/kg]", 0.0, \
0.0,1.0,0.1,0,2560)
DeclareVariable("vol.dynBal.medium.dT", "Temperature difference used to compute enthalpy [K,]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("vol.dynBal.U", "Internal energy of fluid [J]", 4, 0.0, 0.0,0.0,0.0,\
0,544)
DeclareDerivative("vol.dynBal.der(U)", "der(Internal energy of fluid) [W]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("vol.dynBal.m", "Mass of fluid [kg]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("vol.dynBal.der(m)", "der(Mass of fluid) [kg/s]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareState("vol.dynBal.mXi[1]", "Masses of independent components in the fluid [kg]",\
 5, 0.0, 0.0,1E+100,0.0,0,544)
DeclareDerivative("vol.dynBal.der(mXi[1])", "der(Masses of independent components in the fluid) [kg/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("vol.dynBal.mb_flow", "Mass flows across boundaries [kg/s]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("vol.dynBal.mbXi_flow[1]", "Substance mass flows across boundaries [kg/s]",\
 "vol.dynBal.der(mXi[1])", 1, 6, 5, 0)
DeclareVariable("vol.dynBal.Hb_flow", "Enthalpy flow across boundaries or energy source/sink [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("vol.dynBal.fluidVolume", "Volume [m3]", 97.2, 0.0,0.0,0.0,0,513)
DeclareVariable("vol.dynBal.CSen", "Aditional heat capacity for implementing mFactor [J/K]",\
 118335.94559999999, 0.0,0.0,0.0,0,513)
DeclareAlias2("vol.dynBal.Q_flow", "Sensible plus latent heat flow rate transferred into the medium [W]",\
 "vol.heatPort.Q_flow", 1, 5, 25, 0)
DeclareVariable("vol.dynBal.mWat_flow", "Moisture mass flow rate added to the medium [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("vol.dynBal.hOut", "Leaving specific enthalpy of the component [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 0)
DeclareAlias2("vol.dynBal.XiOut[1]", "Leaving species concentration of the component [1]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 0)
DeclareVariable("vol.dynBal.ports_H_flow[1]", "[W]", 0.0, -100000000.0,\
100000000.0,1000.0,0,2560)
DeclareVariable("vol.dynBal.ports_H_flow[2]", "[W]", 0.0, -100000000.0,\
100000000.0,1000.0,0,2560)
DeclareVariable("vol.dynBal.ports_H_flow[3]", "[W]", 0.0, -100000000.0,\
100000000.0,1000.0,0,2560)
DeclareVariable("vol.dynBal.ports_mXi_flow[1, 1]", "[kg/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("vol.dynBal.ports_mXi_flow[2, 1]", "[kg/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("vol.dynBal.ports_mXi_flow[3, 1]", "[kg/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("vol.dynBal.cp_default", "Heat capacity, to compute additional dry mass [J/(kg.K)]",\
 1014.54, 0.0,0.0,0.0,0,2561)
DeclareVariable("vol.dynBal.rho_start", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("vol.dynBal.computeCSen", "[:#(type=Boolean)]", true, 0.0,0.0,\
0.0,0,2563)
DeclareVariable("vol.dynBal.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("vol.dynBal.state_default.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("vol.dynBal.state_default.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.01, 0.0,1.0,0.1,0,2561)
DeclareVariable("vol.dynBal.state_default.X[2]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 0.99, 0.0,1.0,0.1,0,2561)
DeclareVariable("vol.dynBal.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 1.2, 0.0,1E+100,0.0,0,2561)
DeclareVariable("vol.dynBal.s[1]", "Vector with zero everywhere except where species is [1]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("vol.dynBal.hStart", "Start value for specific enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.steBal.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("fan.vol.steBal.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 1156)
DeclareVariable("fan.vol.steBal.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,2569)
DeclareAlias2("fan.vol.steBal.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 1028)
DeclareAlias2("fan.vol.steBal.port_a.Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 1028)
DeclareAlias2("fan.vol.steBal.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "vol.ports[1].m_flow", -1, 5, 17, 1156)
DeclareVariable("fan.vol.steBal.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325.0, 0.0,100000000.0,100000.0,0,2569)
DeclareAlias2("fan.vol.steBal.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "vol.ports[1].h_outflow", 1, 5, 19, 1028)
DeclareAlias2("fan.vol.steBal.port_b.Xi_outflow[1]", "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0 [kg/kg]",\
 "vol.ports[1].Xi_outflow[1]", 1, 5, 20, 1028)
DeclareParameter("fan.vol.steBal.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 87, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("fan.vol.steBal.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 88, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("fan.vol.steBal.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 89, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("fan.vol.steBal.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 0.1944, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.steBal.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.944E-005, 0.0,1E+100,0.0,0,2561)
DeclareVariable("fan.vol.steBal.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("fan.vol.steBal.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "vol.ports[1].m_flow", 1, 5, 17, 1024)
DeclareVariable("fan.vol.steBal.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.steBal.sensibleOnly", "Set to true if sensible exchange only [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("fan.vol.steBal.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("fan.vol.steBal.prescribedHeatFlowRate", "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("fan.vol.steBal.Q_flow", "Sensible plus latent heat flow rate transferred into the medium [W]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.steBal.mWat_flow", "Moisture mass flow rate added to the medium [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("fan.vol.steBal.hOut", "Leaving specific enthalpy of the component [J/kg]",\
 "fan.vol.hOut_internal", 1, 5, 92, 1024)
DeclareAlias2("fan.vol.steBal.XiOut[1]", "Leaving species concentration of the component [1]",\
 "fan.vol.Xi[1]", 1, 5, 80, 1024)
DeclareVariable("fan.vol.steBal.s[1]", "Vector with zero everywhere except where species is [1]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.steBal.m_flowInv", "Regularization of 1/m_flow [s/kg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("fan.vol.steBal.mXi_flow[1]", "Mass flow rates of independent substances added to the medium [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.steBal.deltaReg", "Smoothing region for inverseXRegularized",\
 1.944E-008, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.steBal.deltaInvReg", "Inverse value of delta for inverseXRegularized",\
 51440329.21810699, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.steBal.aReg", "Polynomial coefficient for inverseXRegularized",\
 -771604938.2716049, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.steBal.bReg", "Polynomial coefficient for inverseXRegularized",\
 3.1488678893800064E+017, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.steBal.cReg", "Polynomial coefficient for inverseXRegularized",\
 -4.913810682583697E+025, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.steBal.dReg", "Polynomial coefficient for inverseXRegularized",\
 3.7390064528397536E+033, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.steBal.eReg", "Polynomial coefficient for inverseXRegularized",\
 -1.368681174071672E+041, 0.0,0.0,0.0,0,2561)
DeclareVariable("fan.vol.steBal.fReg", "Polynomial coefficient for inverseXRegularized",\
 1.9268849104322865E+048, 0.0,0.0,0.0,0,2561)
DeclareAlias2("fan.preSou.m_flow_in", "Prescribed mass flow rate [kg/s]", \
"vol.ports[1].m_flow", 1, 5, 17, 1024)
DeclareVariable("conPI.I.k", "Integrator gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("conPI.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("conPI.I.y_start", "Initial or guess value of output (= state)",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("conPI.I.u", "Connector of Real input signal", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareState("conPI.I.y", "Connector of Real output signal", 6, 0.0, 0.0,0.0,0.0,\
0,544)
DeclareDerivative("conPI.I.der(y)", "der(Connector of Real output signal)", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("conPI.addI.k1", "Gain of upper input", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("conPI.addI.k2", "Gain of middle input", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("conPI.addI.k3", "Gain of lower input", 90, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("conPI.addI.u1", "Connector 1 of Real input signals [K]", "TSet.y", 1,\
 5, 172, 0)
DeclareAlias2("conPI.addI.u2", "Connector 2 of Real input signals [K]", \
"vol.heatPort.T", 1, 5, 24, 0)
DeclareVariable("conPI.addI.u3", "Connector 3 of Real input signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("conPI.addI.y", "Connector of Real output signals", "conPI.I.u", 1,\
 5, 405, 0)
DeclareAlias2("conPI.addSat.u1", "Connector of Real input signal 1", "conPI.y", 1,\
 5, 176, 0)
DeclareAlias2("conPI.addSat.u2", "Connector of Real input signal 2", \
"conPI.gainPID.y", 1, 5, 189, 0)
DeclareVariable("conPI.addSat.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("conPI.addSat.k1", "Gain of upper input", 91, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("conPI.addSat.k2", "Gain of lower input", 92, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("conPI.gainTrack.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("conPI.gainTrack.u", "Input signal connector", "conPI.addSat.y", 1,\
 5, 409, 0)
DeclareAlias2("conPI.gainTrack.y", "Output signal connector", "conPI.addI.u3", 1,\
 5, 408, 0)
EndNonAlias(0)
#define NX_    7
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    411
#define NP_    93
#define NPS_   0
#define MAXAuxStr_   4
#define MAXAuxStrLen_   500
#define NHash1_ -2120979045
#define NHash2_ 354262495
#define NHash3_ 0
#define NI_    0
#define NRelF_ 11
#define NRel_  11
#define NTim_  2
#define NSamp_ 0
#define NCons_ 0
#define NA_    142
#define SizePre_ 1
#define SizeEq_ 3
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 20
#define NrDymolaTimers_ 0
#define NWhen_ 1
#define NCheckIf_ 0
#define NGlobalHelp_ 11
#ifndef NExternalObject_
#define NExternalObject_ 1
#endif

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double *time, double X_[], double XD_[], double U_[], 
double DP_[], long IP_[], Dymola_bool LP_[], double F_[], double Y_[], double W_[], double QZ_[], double duser_[], long iuser_[], void*cuser_[]) {
static Real initStore[1];
}
StartDataBlock
StartPreBlock
pre(W_[175],"TSet.count", 0, 0);
EndPreBlock
StartEqBlock
DoRemember_(W_[124], 0.0, 2);
DoRemember_(W_[342], W_[329], 1);
DoRemember_(W_[20], W_[330], 0);
EndEqBlock
UpdateQEvaluate(1)
EndDataBlock
BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionCallNew(2);
BreakSectionFunctionCallNew(3);
BreakSectionFunctionCallNew(4);
BreakSectionFunctionEnd()
